[{"id":1,"content":"몇년 전에 블로그를 만들어서 포스트를 연재했던 시절이 있었습니다. 개발 블로그였는데 바빠지면서 건드리지 않게 되었죠. 그렇다고 해도 블로그는 결국 필요한 것이었습니다. 그래서 새롭게 시작하기 위해 새로 블로그를 만들었습니다. 이번에도 **NextJS**를 이용해서 만든 블로그인데 저번에 만들었던 블로그보다는 좀 더 블로그다운 기능에 치중하고자 했습니다.\r\n\r\n이전 블로그에서 작성했던 글들을 다 옮겨올까 생각도 했지만 수도 많고 바꿔야 할 것들도 많아서 그것은 포기하고 그냥 새롭게 시작하기로 했으니 처음부터 글을 작성해보려고 합니다. 이 블로그의 존재의의는 간단합니다. 코딩 초보 입장에서 코딩 초보들에게 지금까지 배운 지식을 공유하는 것과 앞으로 알게 될 것들을 기록하는 것입니다. 그리고 간간히 진행할 수도 있는 토이 프로젝트 등의 과정을 기록하는 것도 가능할 듯합니다.\r\n\r\n새로 시작하는 시점에서 가장 먼저 해야 할 것은 간단하게 썸네일을 생성하는 프로그램과 제가 할 일을 기록할 수 있는 투두리스트를 손수 구현하고자 합니다. 심심하니까요. 아무튼 이 블로그를 찾는 몇몇 분들에게 적지 않은 도움이 되었으면 합니다.\r\n"},{"id":10,"content":"# 개요\r\n텍스트를 설정하고 배경 이미지나 색상을 선택해서 썸네일을 생성하는 작업은 모두 마쳤습니다. 이제 해야할 것은 구글 드라이브에 이미지를 업로드하고, 만들었던 썸네일 데이터를 데이터베이스에 저장하고 필요할 때 불러올 수 있는 기능을 구현하기 위해서 일단 페이지 분할을 하려고 합니다.\r\n\r\n데이터베이스를 안쓰려고 했는데 안쓰기에는 너무 비효율적인 것 같아서 사용할 생각입니다. 연습삼아서 **Supabase**를 사용할 예정이고 구글 아이디를 이용해서 로그인을 한 후에 자신이 만들었던 썸네일들을 관리할 수 있도록 만들 예정입니다.\r\n\r\n새롭게 필요한 페이지는 만들었던 썸네일을 확인하는 페이지, 썸네일 생성 페이지입니다. 기존의 `index.tsx` 에는 생성 페이지가 있는데 이걸 다른 페이지로 옮기고 홈 페이지는 심플하게 로그인 버튼만 둘 생각입니다. 아마도..?\r\n\r\n<Image src='https://drive.google.com/file/d/1FELWuQWKPX6Bbmy1kjDiIR29vUu5hcV1/view?usp=drive_link' alt='페이지 분리 시작하기' drive />\r\n\r\n이렇게 만드는 것을 목표로 하려고 합니다.\r\n\r\n# 공통 레이아웃 만들기\r\n여러 페이지를 구성할 때 공통 레이아웃을 만드는 편입니다. 그 공통 레이아웃을 한 번 만들어보도록 합시다. `header`의 역할을 하는 `Header`, `nav` 의 역할을 하는 `Menu`, `main` 은 `Main`, `footer` 는 `Footer` 를 이용해서 구성합니다. `Meta` 컴포넌트의 경우에는 웹사이트의 메타데이터를 담당하는 컴포넌트입니다.\r\n\r\n<Image src='https://drive.google.com/file/d/14GcNsPOnMzFY7tX4M-IxDK6Fd4xYwBOd/view?usp=drive_link' alt='레이아웃 컴포넌트의 재료들' drive />\r\n\r\n이 컴포넌트들이 어떻게 구성되어있는지는 그다지 중요한 것이 아니므로 세세한 구성을 건너뛰도록 하겠습니다. 이제 이 컴포넌트들을 이용해서 공통 레이아웃을 만들도록 합니다. `AppLayout` 이라는 이름으로 만드는 편입니다. 레이아웃이 여러개인 경우도 있겠지만 저같은 경우는 하나의 레이아웃을 이용하는 것을 선호합니다.\r\n\r\n<Image src='https://drive.google.com/file/d/18JNJqWllY6ZSDOpBSWqIKURdsF3dIGdZ/view?usp=drive_link' alt='레이아웃 컴포넌트 만들기' drive />\r\n\r\n레이아웃 컴포넌트는 아래처럼 구성하고 있습니다. 항상 사용하는 구성이긴한데 세세하게 바뀔 뿐입니다.\r\n\r\n<Image src='https://drive.google.com/file/d/1Z3R18B0b1iTkx-FsVs9nP1vsXIYFVwTJ/view?usp=drive_link' alt='레이아웃 모습..' drive />\r\n\r\n<CodeBlock title='AppLayout.tsx'>\r\n```tsx\r\nexport function AppLayout({\r\n  children, title, description, keywords, author, image, created, updated, tags, type, section,\r\n}: IAppLayoutProps) {\r\n  const router = useRouter();\r\n\r\n  const meta: IMetaData = {\r\n    title,\r\n    url: router.asPath,\r\n    description,\r\n    keywords,\r\n    author,\r\n    image,\r\n    tags,\r\n    type,\r\n    section,\r\n    created,\r\n    updated,\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <Meta meta={meta} />\r\n      <Header />\r\n\r\n      <Main>\r\n        {children}\r\n      </Main>\r\n\r\n      <Footer />\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n페이지별로 필요한 데이터를 받아서 이를 `Meta` 컴포넌트에 전달하는 구조입니다. 이렇게 하면 **SEO**가 정상적으로 동작하게 되고 검색엔진의 영향을 받을 수도 있습니다. 자 이제 레이아웃은 나중에 꾸미도록 하고 페이지를 만들어봅시다.\r\n\r\n# 페이지 분할하기\r\n\r\n다음과 같은 모습으로 페이지를 만들어둔 상태입니다.\r\n\r\n<Image src='https://drive.google.com/file/d/1CLUQJPEf7rL9KyMD6TQnjVebYYIEYl6r/view?usp=drive_link' alt='페이지 분할하기' drive />\r\n\r\n먼저 기존의 `index.tsx` 파일의 내용은 `generate.tsx` 파일로 옮기고 여기에는 솔직히 어떤 페이지를 넣을지 좀 더 생각해보려고 합니다. 로그인 버튼만 있으면 솔직히 재미가 없을 것 같고.. 기본적인 프로그램의 설명으로 채워 넣는 게 좋을 듯합니다.\r\n\r\n아무튼 현재 상태의 `index.tsx` 파일의 내용은 다음과 같습니다.\r\n\r\n<CodeBlock title='index.tsx'>\r\n```tsx\r\nexport default function IndexPage() {\r\n  const style = {\r\n    default: css([\r\n      tw`  `,\r\n    ]),\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <AppLayout title='홈'>\r\n        <div css={style.default}>\r\n          홈화면\r\n        </div>\r\n      </AppLayout>\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n이번에는 `generate.tsx` 파일입니다. 여기의 내용은 기존의 `index.tsx` 파일에서 가져왔을 뿐이라서 크게 달라진 부분은 없습니다. 그냥 이름만 바뀐 수준입니다.\r\n\r\n<CodeBlock title='generate.tsx'>\r\n```tsx\r\nexport default function GeneratePage() {\r\n  const style = {\r\n    default: css([\r\n      tw`  `,\r\n    ]),\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <AppLayout title='생성하기'>\r\n        <div css={style.default}>\r\n          <Thumbnail />\r\n          <TextConfig />\r\n          <BackgroundConfig />\r\n        </div>\r\n      </AppLayout>\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n그리고 마지막으로 `mypage.tsx` 파일에는 썸네일들을 관리하고 수정하거나 하는 기능들을 넣으려고 합니다. 텅 비어있어서 굳이 보여줄 필요는 없을 것 같습니다. 아무튼 이렇게 분할을 끝냈습니다. 좀 더 이어서 다음 기능을 구현하고 싶지만 이번 글의 목적은 페이지 분할이었기 때문에 여기서 마치도록 해야겠습니다.\r\n\r\n# 마치며\r\n이번 글에서는 간단하게 공통 레이아웃을 만들었고 페이지를 분할했습니다. 사실 페이지는 더 필요할 수도 있는데 그건 추후에 생각해보기로 하고 당장 다음 글에서는 홈 페이지를 꾸며보도록 하겠습니다. 임시로 말이죠. 프로그램을 설명하기 위해서는 프로그램이 완성되어야 하기 때문에 제대로 된 홈 페이지는 가장 나중에 만들게 될 것 같습니다.\r\n\r\n그럼 언젠가 다음 글로 찾아오도록 하겠습니다.\r\n"},{"id":11,"content":"\r\n# 개요\r\n이번 글에서는 로그인을 구현해보려고 합니다. 본래라면 로그인 같은 것들을 위해서 백엔드를 구현해야하지만 이번 프로젝트에서는 Supabase 라는 서비스를 이용해서 백엔드 처리를 해보려고 합니다. 그래서 로그인도 회원가입도 간단하게 진행할 수 있습니다.\r\n\r\n썸네일 생성기는 nihilapps 라는 이름의 제 프로그램들의 묶음에 포함시킬 것이고 썸네일 생성기에서 회원가입을 하면 다른 nihilapps 의 프로그램들도 사용할 수 있도록 하려고 합니다. 자 그럼 시작해봅시다.\r\n\r\n# Supabase 설정\r\nSupabase의 기능을 이용하기 위해서는 가장 먼저 Supabase에 가입하고 프로젝트를 생성해야 합니다. 사이트는 구글링하면 다 나올 것이라 생략하고 간략하게 이미지만 올려두도록 하겠습니다.\r\n\r\n<Image src='https://drive.google.com/file/d/1fa7XWUEGwDILuLXFwaoVcRRxozc6k0bQ/view?usp=drive_link' alt='새 프로젝트 만들기' drive />\r\n\r\n녹색 버튼을 클릭하면 새로운 프로젝트를 만들 수 있습니다. 저는 이미 만들어놔서 굳이 다시 만들 필요는 없을 것 같고 유료 플랜을 사용하지 않는 이상은 프로젝트는 3개 이상은 만들 수 없습니다. 즉 2개까지만 가능하다는 소리죠. Supabase를 사용해본 후에 괜찮다 싶으면 유료 플랜을 결제해서 사용하면 됩니다. 저는 아직 무료 플랜을 사용하고 있습니다.\r\n\r\n## 로그인 설정\r\n저는 이 사이트에서 구글 로그인과 깃허브 로그인 그리고 이메일 로그인을 제공할 겁니다. 그럼 이걸 설정해줘야합니다. Supabase 대시보드의 왼쪽에는 사용할 수 있는 기능들 아이콘이 모여 있는데, 마우스를 올려서 **Authentication**을 찾아서 클릭을 하면 됩니다.\r\n\r\n<Image src='https://drive.google.com/file/d/1mZGxBdvFPvTMcv8OGWZ5hg_9K8buB4_j/view?usp=drive_link' alt='가입한 사용자들의 목록이 보이는 곳' drive />\r\n\r\n클릭하면 이런 페이지가 뜨는데 여기는 사용자들의 목록을 볼 수 있는 곳입니다. 저는 테스트를 이미 한 번 해봐서 유저가 한 명 있는 것이고 원래는 비어있겠죠. 이 화면에서 왼쪽 메뉴에 Providers 를 클릭하면 지원하는 사이트들이 나옵니다.\r\n\r\n여기서 이메일은 이미 설정되어있고 깃허브와 구글을 추가로 설정을 해서 아래처럼 만들어야 합니다.\r\n\r\n<Image src='https://drive.google.com/file/d/1Cxr3IJyreVLXVTwJhnPzA-FkMnH_vLwq/view?usp=drive_link' alt='소셜 로그인 설정하기' drive />\r\n\r\n### 이메일 로그인 설정\r\n\r\n<Image src='https://drive.google.com/file/d/1j-KLgoqigXWahqE08fXZRe1jKh4jUzKz/view?usp=drive_link' alt='이메일 로그인 설정' drive />\r\n\r\n이메일의 경우 딱히 건드릴 것은 없습니다. 저같은 경우는 비밀번호 관련해서 체크를 하나 하긴 했는데 뭐 상관 없는 수준이고 진짜 중요한건 나머지 두 사이트 로그인 설정입니다.\r\n\r\n### 깃허브 로그인 설정\r\n<Image src='https://drive.google.com/file/d/1d-ucsG3JXI6a7OX0c4D5Izlj7oKgdKpY/view?usp=drive_link' alt='깃허브 로그인 설정' drive />\r\n\r\n깃허브 로그인을 이용하기 위해서는 깃허브에서 설정을 해줘야 할 게 있습니다. 클라이언트 아이디와 시크릿 부분을 채워줘야 합니다. 처음에는 이렇게 채워져 있지 않기 때문에 채워줘야 합니다. 먼저 깃허브에 로그인 합니다.\r\n\r\n계정 설정에 들어간 후에 Developer Settings 로 진입합니다. 여기서 OAuth Apps을 만들어줍니다. 앱의 이름, 등등은 그냥 적어주면 됩니다.\r\n\r\n<Image src='https://drive.google.com/file/d/1LoQjjc1AwLLUqteR4f1IjIym169H14Ef/view?usp=drive_link' alt='클라이언트 아이디와 시크릿 생성해두기' drive />\r\n\r\n여기서 만든 클라이언트 아이디와 시크릿을 Supabase의 깃허브 로그인 설정하는 곳에 넣으면 됩니다. 그리고 콜백 주소를 잘 보관해둡시다. 복사를 할 수 있게 되어있을겁니다. 복사를 해줍니다.\r\n\r\n깃허브에서 좀 더 진행하다보면 또 채워야 하는 부분이 있습니다.\r\n\r\n<Image src='https://drive.google.com/file/d/1g-4gqi29A9vFh8Wz_i3M7OeG94XLt3kQ/view?usp=drive_link' alt='채워넣습니다.' drive />\r\n\r\n첫번째 사각형에는 로그인을 필요로 하는 프로젝트가 배포된 주소를 입력하면 되고 두 번째 사각형에는 복사한 콜백 주소를 넣으면 됩니다. 이렇게 하고 앱을 저장하면 된 겁니다.\r\n\r\n### 구글 로그인 설정\r\n구글도 마찬가지로 클라이언트 아이디와 시크릿을 필요로 합니다. 구글 클라우드 플랫폼에서 프로젝트를 만들고, 클라이언트 아이디와 시크릿을 생성하면 됩니다.\r\n\r\n<Image src='https://drive.google.com/file/d/1iRtZr1Vo07TUI_JJJn-XdH70kF-hY8cu/view?usp=drive_link' alt='구글 클라우드 플랫폼 프로젝트 만들기' drive />\r\n\r\n<Image src='https://drive.google.com/file/d/11ScsHIEj2Cv-LfEu_BMQwBk7CfExbeEg/view?usp=drive_link' alt='프로젝트 정보 입력하기' drive />\r\n\r\n구글 계정을 통해서 구글 클라우드 플랫폼을 시작하면 프로젝트를 만들어줍니다. 이름은 원하는대로 입력하면 되겠죠. 그러면 프로젝트가 생성될 때까지 기다렸다가 생성이 되면 다음의 절차를 진행하면 됩니다.\r\n\r\n<Image src='https://drive.google.com/file/d/1Ph_MVOs1mme5AgD6GXSrwAH1GK2E9TZz/view?usp=drive_link' alt='API 라이브러리를 선택해야 합니다.' drive />\r\n\r\nAPI 라이브러리를 선택하러 가는 겁니다. 목록에서 구글 드라이브 API를 찾아서 사용하도록 설정하면 됩니다.\r\n\r\n<Image src='https://drive.google.com/file/d/1wV33L-4aNMCQCEEMjbuMTu6pQvx8kTQF/view?usp=drive_link' alt='구글 드라이브 API를 찾습니다.' drive />\r\n\r\n<Image src='https://drive.google.com/file/d/1Xe4d-nbHk-uN_tUsLq3XfZOmMX3OpveM/view?usp=drive_link' alt='사용 설정을 진행합니다.' drive />\r\n\r\n이렇게 사용하도록 설정을 한 뒤에 이렇게 진행하면 됩니다.\r\n\r\n<Image src='https://drive.google.com/file/d/17iD2rwb6wdf3UGt2t6l78TUY7jXi1RNu/view?usp=drive_link' alt='사각형을 따라가줍니다.' drive />\r\n\r\nOAuth 동의 화면으로 넘어왔으면 가장 처음에 **외부**를 선택합니다. **앱 이름**과 **사용자 지원 이메일**을 입력하면 되고 승인된 도메인에는 깃허브 쪽에서 입력했던 것과 마찬가지로 우리 서비스의 주소를 넣으면 됩니다. 테스트중이니까 localhost도 가능합니다. 개발자 연락처 정보도 입력을 해줍니다.\r\n\r\n저장 후 계속을 클릭해서 그 다음으로 넘어가면 범위 라는 것을 설정해야 합니다. 세가지를 추가하면 됩니다.\r\n\r\n<Image src='https://drive.google.com/file/d/171yX2Q0st15PAQQxOmybVJOWk4qdcvRj/view?usp=drive_link' alt='범위를 추가합니다.' drive />\r\n\r\n이미지대로 설정을 진행한 후에 다음으로 넘어가줍니다. 테스트 사용자를 등록하는 과정인데 이걸 등록하지 않으면 아예 테스트를 할 수가 없게 됩니다. 앱을 배포하기 전까지는 테스트 사용자를 등록한 후에 테스트를 진행해야 합니다.\r\n\r\n<Image src='https://drive.google.com/file/d/1-3fAzW1DuBk4fWEPPc5vu09y-tyEA9Hl/view?usp=drive_link' alt='테스트 사용자를 등록합니다.' drive />\r\n\r\n이거까지 하고 난 후에는 마지막 관문인 클라이언트 키와 시크릿을 만드는 일만 남았습니다. 좌측 메뉴에서 사용자 인증 정보로 들어갑니다.\r\n\r\n<Image src='https://drive.google.com/file/d/15ftL7uZzFjTdBz7I-zOtv1vy9O43wfEf/view?usp=drive_link' alt='클라이언트 ID 선택합니다.' drive />\r\n\r\n<Image src='https://drive.google.com/file/d/1bbr8hGRVKGseZ_OtvUkENWC-QAdXjfql/view?usp=drive_link' alt='필요 정보를 입력해줍니다.' drive />\r\n\r\n유형은 웹 애플리케이션을 선택해야 합니다. 이름은 원하는 거 입력하면 되고 리디렉션을 입력하면 되는데 여기에는 이제 Supabase에서 복사한 값을 넣으면 됩니다. 깃허브 쪽에 넣었던 것과 똑같은거 그대로 넣으면 됩니다. 이렇게 하고 만들기를 클릭하면 클라이언트 아이디와 시크릿이 만들어집니다.\r\n\r\n만들어진 것들을 복사해서 Supabase 쪽에 넣으면 됩니다.\r\n\r\n<Image src='https://drive.google.com/file/d/1qA0wa5zFbEIUVHBNfeNQSDeeHN7qMJ9T/view?usp=drive_link' alt='필요한 값들 넣어주고 save를 클릭합니다.' drive />\r\n\r\n마지막으로 save를 클릭해주면 필요한 로그인 설정은 다 끝낸겁니다. 이번 글은 별 내용은 없는데 이미지가 많아서 참 길어보일 것 같네요. 그래서 Supabase와 NextJS를 연동하는 과정은 다음 글에서 진행하도록 하겠습니다.\r\n\r\n# 마치며\r\n이번 글에서는 Supabase를 사용하기 위한 설정을 진행했습니다. 이메일 로그인과 구글, 깃허브 로그인을 지원할 예정이기 때문에 그 과정을 짧게 보여드렸습니다. 그냥 스킵하려고 했는데 막상 글로만 다루면 재미가 없어서 이렇게 진행을 해봤습니다.\r\n\r\n다음 글에서는 본격적으로 자바스크립트를 이용해서 Supabase와 NextJS를 연동하는 것을 진행할 예정입니다. 로그인 페이지를 간략하게 만들고, 회원가입과 로그인, 로그아웃 테스트를 진행해보도록 합시다.\r\n"},{"id":12,"content":"# 개요\r\n이번 글에서는 본격적으로 개발을 시작해보도록 합시다. 이번 글에서 할 것은 지난 글에서 작업했던 로그인 설정을 이용해서 로그인 페이지. 회원가입 페이지를 만드는 겁니다. 그리고 조금 최신 트렌드를 따라가기 위해서 프로젝트 구조를 살짝 엎었습니다. 기존에는 pages 라우팅을 사용했었는데 이제는 app 라우팅을 사용합니다. 장단점이 있기는 한데 일단 겪어보고 다음 프로젝트는 어떻게 할지 생각해보려고 합니다.\r\n\r\n아무튼 app 라우팅 체제로 변환하면서 바뀐 게 여러가지 있는데 전부 파헤치는 것은 중요하지 않으니 넘어가도록 하고 폴더 구조를 좀 살펴보도록 합시다.\r\n\r\n<Image src='https://drive.google.com/file/d/1EJET9ZPtWA3rdYIgss0Rj209pBR2xAvs/view?usp=drive_link' alt='pages 라우터 구조' drive />\r\n\r\n<Image src='https://drive.google.com/file/d/1FMN4GqJ7lHDZbJ391gvpnNrUf8wJoe_n/view?usp=drive_link' alt='app 라우터 구조' drive />\r\n\r\npages 라우터 구조와 app 라우터 구조입니다. pages 라우터는 `pages` 폴더 안에서 파일, 폴더 이름으로 페이지를 생성해줍니다. 공통된 레이아웃은 별도로 구성해야합니다.\r\n\r\napp 라우터는 `app` 폴더 안에서 동작하게 됩니다. 생성할 페이지의 이름으로 폴더를 만들고 그 안에 `page.tsx` 라는 이름으로 파일을 만들면 이 파일의 내용이 폴더명과 똑같은 페이지의 내용이 됩니다. 또한 `layout.tsx` 파일의 존재로 인해 공통 레이아웃을 간단하게 만들 수 있습니다.\r\n\r\n뭐 아무튼 이런 차이가 있고 pages 라우터를 사용할 때에는 emotion을 사용했었는데 이제는 TailwindCSS 만을 사용합니다. 이제 본격적으로 시작해봅시다. 이번에 만들 페이지는 두개이고 회원가입, 로그인, 로그아웃, 깃허브 로그인, 구글 로그인을 다룰 겁니다. Supabase는 이미 설정을 해두었기 때문에 다시 설정할 필요는 없고 연동만 하면 됩니다. 그럼 시작해봅시다.\r\n\r\n# Supabase와 NextJS 연동하기\r\n`src` 폴더 안에 있는 `utils` 폴더 안에 `supabase` 라는 폴더를 만들어주었습니다. 여기에 `client.ts` 파일과 `server.ts` 파일을 만들겁니다.\r\n\r\n<Image src='https://drive.google.com/file/d/1EMHUlQxiO8bsP9t9NgWx44xF0i_i_50h/view?usp=drive_link' alt='폴더들과 파일을 만들어줍니다.' drive />\r\n\r\n그 다음에는 Supabase와 연동하기 위해 라이브러리 두개를 받아줍니다. **@supabase/supabase-js** **@supabase/ssr** 이 두가지를 받아주면 됩니다.\r\n\r\n<CodeBlock title=''>\r\n```bash\r\n# npm\r\nnpm install @supabase/supabase-js @supabase/ssr\r\n\r\n# yarn\r\nyarn add @supabase/supabase-js @supabase/ssr\r\n\r\n```\r\n</CodeBlock>\r\n\r\n그 후에 `.env.local` 파일을 만들고 이 안에 변수를 두개 만들어줍니다. `NEXT_PUBLIC_SUPABASE_PROJECT` 와 `NEXT_PUBLIC_SUPABASE_ANON_KEY` 를 만들어줍니다.\r\n\r\n<CodeBlock title='.env.local'>\r\n```text\r\nNEXT_PUBLIC_SUPABASE_PROJECT='...'\r\nNEXT_PUBLIC_SUPABASE_ANON_KEY='...'\r\n```\r\n</CodeBlock>\r\n\r\n이제 여기에 값을 넣어야 하는데 Supabase의 설정에 들어가면 볼 수 있습니다.\r\n\r\n<Image src='https://drive.google.com/file/d/1Qoz7gcvQsXgcVYBKGxN-volvqeZ1bfyE/view?usp=drive_link' alt='Supabase 설정에서 값을 가져옵니다.' drive />\r\n\r\n**Project Settings** 에 들어가서 **API Settings** 를 클릭하면 **Project URL** 과 **Project API keys** 가 보이는데 **Project URL** 의 값을 `NEXT_PUBLIC_SUPABASE_PROJECT` 에 넣고 **Project API keys** 중에 **anon** 에 해당하는 값을 `NEXT_PUBLIC_SUPABASE_ANON_KEY` 에 넣겠습니다.\r\n\r\n이렇게 하면 이제 코드를 작성할 수 있습니다.\r\n\r\n`supbase` 폴더에 만들었던 `client.ts` 파일과 `server.ts` 파일에다가 코드 작성을 시작합니다.\r\n\r\n<CodeBlock title='client.ts'>\r\n```ts\r\nimport { createBrowserClient } from '@supabase/ssr';\r\n\r\nexport const supabase = createBrowserClient(\r\n  process.env.NEXT_PUBLIC_SUPABASE_PROJECT!,\r\n  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!\r\n);\r\n```\r\n</CodeBlock>\r\n\r\n<CodeBlock title='server.ts'>\r\n```ts\r\nimport { createServerClient, type CookieOptions } from '@supabase/ssr';\r\nimport { cookies } from 'next/headers';\r\n\r\nconst cookieStore = cookies();\r\n\r\nexport const supabase = createServerClient(\r\n  process.env.NEXT_PUBLIC_SUPABASE_PROJECT!,\r\n  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\r\n  {\r\n    cookies: {\r\n      get(name: string) {\r\n        return cookieStore.get(name)?.value;\r\n      },\r\n      set(name: string, value: string, options: CookieOptions) {\r\n        cookieStore.set({ name, value, ...options, });\r\n      },\r\n      remove(name: string, options: CookieOptions) {\r\n        cookieStore.set({ name, value: '', ...options, });\r\n      },\r\n    },\r\n  }\r\n);\r\n```\r\n</CodeBlock>\r\n\r\n클라이언트 에서는 `createBrowserClient` 를 이용한 변수를 사용하고 서버에서는 `createServerClient` 를 이용한 변수를 사용할 겁니다. 이렇게 필요한 것을 작성한 후에는 페이지를 설정해주면 됩니다.\r\n\r\n# 페이지 구성하기\r\n지금까지는 각 페이지들에서 사용할 supabase 모듈을 가져오기 위해서 필요한 부분이었고 이제부터는 **signin** 페이지와 **signup** 페이지를 만듭니다. 사실 이미 만들어져 있죠.\r\n\r\n<Image src='https://drive.google.com/file/d/1UGpgsHNRB3OVNLJNhGp1Wct7JYMc7r8M/view?usp=drive_link' alt='두개의 페이지를 만들어줍니다.' drive />\r\n\r\napp 라우터에서는 폴더 이름으로 페이지를 구분하기 때문에 일단 `signin` 폴더와 `signup` 폴더를 만들어주고 그 안에 각각 `page.tsx` 파일을 만들어주면 됩니다. 먼저 signup 페이지부터 정리를 해봅시다.\r\n\r\n## signup 페이지\r\n회원가입 페이지죠 이 페이지에서는 두가지의 선택지를 줄 겁니다. 첫번째는 이메일로 가입을 할 수 있는 것이고 다른 하나는 구글이나 깃허브 계정을 통해 가입을 하는 겁니다. 사실상 그냥 로그인을 하는 것이죠. 화면 구성을 먼저 해봅시다. 진지한 디자인은 나중에 하도록 하고 지금은 일단 모양만 알아볼 수 있게 만들어보겠습니다.\r\n\r\n이메일 회원가입의 경우 이메일과 비밀번호 그리고 비밀번호 확인 칸을 만들어두고 가입하기 버튼을 배치하면 되겠죠 다른 로그인들은 그냥 각각의 버튼만 두면 될 겁니다.\r\n\r\n`page.tsx` 에서 화면을 만드는 것은 지양하려고 합니다. 왜냐면 리액트의 **hooks** 를 사용하면 클라이언트 컴포넌트가 되어야 하기 때문에 **metadata** 설정을 하지 못하게 됩니다. 그래서 따로 컴포넌트를 만들어서 그 컴포넌트를 `page.tsx` 에서 호출하도록 하겠습니다.\r\n\r\n<CodeBlock title='signup/page.tsx'>\r\n```tsx\r\nimport React from 'react';\r\nimport { Metadata } from 'next';\r\nimport { setMeta } from '@/src/hooks/setMeta';\r\nimport { SignUpForm } from '@/src/components/Content/signup';\r\n\r\nexport const metadata: Metadata = setMeta({\r\n  title: '회원가입',\r\n  url: '/signup',\r\n});\r\n\r\nexport default function SignUpPage() {\r\n  return (\r\n    <>\r\n      <SignUpForm />\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n## SignUpForm 컴포넌트 만들기\r\n`SignUpForm` 컴포넌트에서 본격적인 화면 구성을 해보도록 합시다. 아, `setMeta` 함수의 경우 제가 편하자고 만들어둔 함수입니다. 원래 metadata 타입에는 `url` 프로퍼티를 받지 않습니다. 하하. form 을 만들어야 하는데 이번에는 **react-hook-form** 라이브러리를 사용하려고 합니다.\r\n\r\n<CodeBlock title='SignUpForm.tsx'>\r\n```tsx {14-18, 21-25, 27-35, 52-61, 63-65, 74-83, 85-87, 96-110, 112-114, 120-122, 124-126}\r\n'use client';\r\n\r\nimport { DevTool } from '@hookform/devtools';\r\nimport React, { useCallback } from 'react';\r\nimport { SubmitHandler, useForm } from 'react-hook-form';\r\nimport { ClassNameValue, twJoin } from 'tailwind-merge';\r\nimport { supabase } from '@/src/utils/supabase/client';\r\nimport { AuthButton } from '../../Common';\r\n\r\ninterface Props {\r\n  styles?: ClassNameValue;\r\n}\r\n\r\ninterface Inputs {\r\n  email: string;\r\n  password: string;\r\n  passwordCheck: string;\r\n}\r\n\r\nexport function SignUpForm({ styles, }: Props) {\r\n  const {\r\n    register, handleSubmit, control, watch, formState: { errors, },\r\n  } = useForm<Inputs>({\r\n    mode: 'all',\r\n  });\r\n\r\n  const onSubmitForm: SubmitHandler<Inputs> = useCallback(\r\n    (data) => {\r\n      supabase.auth.signUp({\r\n        email: data.email,\r\n        password: data.password,\r\n      });\r\n    },\r\n    []\r\n  );\r\n\r\n  const style = {\r\n    default: twJoin([\r\n      ``,\r\n      styles,\r\n    ]),\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <form onSubmit={handleSubmit(onSubmitForm)} noValidate>\r\n        <label htmlFor='email'>\r\n          <span>이메일</span>\r\n          <input\r\n            type='email'\r\n            id='email'\r\n            {...register('email', {\r\n              required: {\r\n                value: true,\r\n                message: '이메일을 입력하세요.',\r\n              },\r\n              pattern: {\r\n                value: /(\\w+)@(\\w+.\\w+)/g,\r\n                message: '이메일 형식이 아닙니다.',\r\n              },\r\n            })}\r\n          />\r\n          {errors.email && (\r\n            <span>{errors.email?.message}</span>\r\n          )}\r\n        </label>\r\n\r\n        <label htmlFor='password'>\r\n          <span>비밀번호</span>\r\n          <input\r\n            type='password'\r\n            id='password'\r\n            autoComplete='off'\r\n            {...register('password', {\r\n              required: {\r\n                value: true,\r\n                message: '비밀번호를 입력하세요.',\r\n              },\r\n              minLength: {\r\n                value: 8,\r\n                message: '비밀번호는 8자 이상이어야합니다.',\r\n              },\r\n            })}\r\n          />\r\n          {errors.password && (\r\n            <span>{errors.password?.message}</span>\r\n          )}\r\n        </label>\r\n\r\n        <label htmlFor='password-check'>\r\n          <span>비밀번호</span>\r\n          <input\r\n            type='password'\r\n            id='password-check'\r\n            autoComplete='off'\r\n            {...register('passwordCheck', {\r\n              required: {\r\n                value: true,\r\n                message: '비밀번호를 입력하세요.',\r\n              },\r\n              minLength: {\r\n                value: 8,\r\n                message: '비밀번호는 8자 이상이어야합니다.',\r\n              },\r\n              validate: {\r\n                misMatchPassword: (value) => {\r\n                  return watch('password') === value || '입력한 비밀번호와 다릅니다.';\r\n                },\r\n              },\r\n            })}\r\n          />\r\n          {errors.passwordCheck && (\r\n            <span>{errors.passwordCheck?.message}</span>\r\n          )}\r\n        </label>\r\n\r\n        <button>회원가입</button>\r\n      </form>\r\n\r\n      {process.env.NODE_ENV === 'development' && (\r\n        <DevTool control={control} placement='top-right' />\r\n      )}\r\n\r\n      <div className='border-t border-black-300'>\r\n        <AuthButton />\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n<Image src='https://drive.google.com/file/d/1owH7-ZMYwxHQY-bTAve_3o_ggBWrnMen/view?usp=drive_link' alt='대충 이런식으로 생겼습니다.' drive />\r\n\r\n14-18번에서 `Inputs` 인터페이스를 선언해줍니다. 이건 form 에서 사용될 프로퍼티가 될 겁니다. 21-25번에서 `useForm` 을 불러와서 필요한 것들을 꺼내둡니다. `register` 는 `useForm` 에서 관리할 input 을 설정하는 것이라고 생각하면 되고 `handleSubmit` 은 form 의 `onSubmit` 과 연결할 녀석이고 `control` 은 데브툴과 연결할 겁니다. `watch` 는 현재 input 의 값을 참조할 수 있습니다. `errors` 에는 에러 사항이 들어 있습니다.\r\n\r\n52-61번, 74-83번, 96-110번은 유효성체크를 하는 부분입니다. 이걸 생으로 구현하려면 정말 귀찮은데 이렇게 라이브러리로 처리하니까 아주 빠르게 정리가 끝났습니다. 모든 값들은 필수값이어야하고 이메일은 이메일 형식이 아니면 에러, 비밀번호는 서로 같지 않으면 에러, 8자가 넘지 않으면 에러. 이런식으로 설정을 해뒀습니다.\r\n\r\n이렇게 설정을 하면 사용자가 알아서 비밀번호와 비밀번호 확인을 같게 작성할테니 데이터를 Supabase로 보낼 때 체크를 해줄 필요가 없습니다. 물론 이중으로 체크를 해주면 더 좋은데 일단은 그냥 넘어가도록 하겠습니다.\r\n\r\n`errors` 에는 에러 객체들이 들어있는데 에러가 있을 때 값이 생겨나서 에러 메시지를 띄워주는 것이 가능합니다. 그걸 하고 있는 게 이제 63-65번, 85-87번, 112-114번 입니다. 이런 곳의 스타일은 보통 빨간색으로 설정을 해두죠. 저도 그렇게 할 겁니다.\r\n\r\n값을 다 입력하면 엔터 혹은 회원가입 버튼을 클릭하겠죠. 그렇게 submit이 동작하면 form 의 `onSubmit={handleSubmit(onSubmitForm)}` 이 부분으로 이동을 합니다. 그러면 `onSubmitForm` 함수가 실행이 되면서 `supabase.auth.signUp` 함수를 통해 supabase로 데이터가 넘어가게 됩니다. 사실 이 함수는 덜 완성했는데 여기서 then을 통해서 아래처럼 수정이 가능할 듯 합니다.\r\n\r\n<CodeBlock title=''>\r\n```ts\r\nconst router = useRouter();\r\n\r\nconst onSubmitForm: SubmitHandler<Inputs> = useCallback(\r\n  (data) => {\r\n    supabase.auth.signUp({\r\n      email: data.email,\r\n      password: data.password,\r\n    }).then(() => {\r\n      toast.success('회원가입이 완료되었습니다.');\r\n      router.push('/');\r\n    });\r\n  },\r\n  []\r\n);\r\n```\r\n</CodeBlock>\r\n\r\n회원가입에 성공하게 되면 토스트 메시지와 함께 홈 페이지로 이동하게 됩니다. 회원가입이 성공하면 supabase에서 이메일을 보내주는데요. 이메일의 링크를 클릭하게 되면 인증까지 마치게 됩니다.\r\n\r\n<Image src='https://drive.google.com/file/d/1z5Hi3c1KM10yzbB-uNm5acj9lRJcmxIg/view?usp=drive_link' alt='이메일이 날아오면 클릭해줍니다.' drive />\r\n\r\n이메일 회원가입을 하고 깃허브 혹은 구글 로그인을 하게 되어도 로그인이 가능합니다. 하나의 이메일이 여러가지 경우의 로그인을 처리하게끔 supabase에서 처리 해둔 것 같습니다.\r\n\r\n자 그럼 이제 `AuthButton` 컴포넌트를 만들어봅시다.\r\n\r\n## AuthButton 컴포넌트 만들기\r\n<CodeBlock title='AuthButton.tsx'>\r\n```tsx\r\n'use client';\r\n\r\nimport { supabase } from '@/src/utils/supabase/client';\r\nimport React, { useCallback } from 'react';\r\nimport { ClassNameValue, twJoin } from 'tailwind-merge';\r\n\r\ninterface Props {\r\n  styles?: ClassNameValue;\r\n}\r\n\r\nexport function AuthButton({ styles, }: Props) {\r\n  const onClickGoogle = useCallback(\r\n    () => {\r\n      supabase.auth.signInWithOAuth({\r\n        provider: 'google',\r\n        options: {\r\n          redirectTo: '/',\r\n        },\r\n      });\r\n    },\r\n    []\r\n  );\r\n\r\n  const onClickGithub = useCallback(\r\n    () => {\r\n      supabase.auth.signInWithOAuth({\r\n        provider: 'github',\r\n        options: {\r\n          redirectTo: '/',\r\n        },\r\n      });\r\n    },\r\n    []\r\n  );\r\n\r\n  const style = {\r\n    buttons: twJoin([\r\n      'flex flex-col gap-2 mt-5 w-1/4',\r\n      styles,\r\n    ]),\r\n    button: twJoin([\r\n      'p-2 bg-black-200 hover:bg-blue-200 border border-black-400 hover:border-blue-400',\r\n    ]),\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <div className={style.buttons}>\r\n        <button onClick={onClickGoogle} className={style.button}>구글로 가입하기</button>\r\n        <button onClick={onClickGithub} className={style.button}>깃허브로 가입하기</button>\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n이 컴포넌트에서 중요한 것은 `onClickGoogle` 함수와 `onClickGithub` 함수 입니다. 각 버튼을 클릭하면 `supabase.auth.signInWithOAuth` 함수가 실행이 되는데, `provider` 프로퍼티의 값에 따라서 다르게 동작을 하게 됩니다. 여기에 설정해둔 `provider` 프로퍼티는 supabase 에서 설정했던 provider 에 해당하는데, 알아서 콜백주소로 이동해서 토큰을 받아옵니다.\r\n\r\n뭐 아무튼 supabase가 알아서 다 처리해준다는 점이 편리하다는 것만 알아두면 좋을 것 같습니다. 이런 비슷한 서비스가 하나 더 있죠. 아주 유명한 firebase 라는 서비스말입니다. firebase를 두고 supabase를 선택한 이유는 얘는 관계형 데이터베이스를 사용하고, firebase는 비관계형이라는 점이 큰 영향을 둔 것 같습니다.\r\n\r\n그래서 이 버튼들을 클릭하면 구글과 깃허브에서 토큰을 받아오고, 홈 페이지로 이동시키도록 설정해두었습니다. 회원가입 페이지는 이렇게 구성을 하면 될 것 같고, 이제 로그인 페이지를 만들어봅시다. 비슷한 부분은 다 건너뛰고 중요한 부분만 다루도록 합시다.\r\n\r\n# signin 페이지 구성하기\r\n로그인 페이지는 이메일, 비밀번호 입력하는 폼이 있으면 되고 로그인 버튼을 클릭하는 순간 supabase 에 이메일이 등록되어 있는지 알아서 검사를 하고, 없으면 당연히 로그인에 문제가 있겠죠. signin 페이지에도 직접적으로 hooks를 사용할 수 없기 때문에 `SignInForm` 컴포넌트를 만들어서 진행했습니다.\r\n\r\n<Image src='https://drive.google.com/file/d/1yifEN0hWT2Z8KtLSSD63Kz4nyA5FiV9A/view?usp=drive_link' alt='로그인 페이지 프로토타입' drive />\r\n\r\n그리고 이게 그 결과물입니다. 충격적인 디자인은 일단 뒤로하고 이메일과 비밀번호를 입력한 후에 로그인 버튼을 클릭하면 아래의 코드가 실행됩니다.\r\n\r\n<CodeBlock title=''>\r\n```ts\r\nconst onSubmitForm: SubmitHandler<Inputs> = useCallback(\r\n  (data) => {\r\n    supabase.auth.signInWithPassword(data)\r\n      .then((response) => {\r\n        console.log(response);\r\n\r\n        router.push('/');\r\n      });\r\n  },\r\n  []\r\n);\r\n```\r\n</CodeBlock>\r\n\r\n`supabase.auth.signInWithPassword` 함수가 실행되면서 데이터를 supabase에 넘겨주고 위에서 언급했던 프로세스로 동작하게 됩니다. 근데 여기서 문제점은 현재 이 코드는 로그인이 실패했을 경우를 잡아내지 못합니다. 그래서 수정을 해야하는데 아래처럼 수정을 하면 될 것 같아요.\r\n\r\n<Image src='https://drive.google.com/file/d/15DeKJGdkmkL_GtJoBS4OKw27Dq1HCvMt/view?usp=drive_link' alt='실패했을 때 응답 결과' drive />\r\n\r\n<Image src='https://drive.google.com/file/d/1x8YCuRu7pYMZAo4-mTF_CSNbtIjvQUst/view?usp=drive_link' alt='성공했을 때 응답 결과' drive />\r\n\r\n여기 보면 실패했을 때에는 `error` 프로퍼티에 문자열이 들어있습니다. 그리고 성공하면 `error` 프로퍼티가 `null` 이에요. 이 부분을 이용해서 처리를 하면 될 것 같습니다. 그리고 처리를 했습니다.\r\n\r\n<CodeBlock title=''>\r\n```ts\r\nconst onSubmitForm: SubmitHandler<Inputs> = useCallback(\r\n  (data) => {\r\n    supabase.auth.signInWithPassword(data)\r\n      .then((response) => {\r\n        if (response.error) {\r\n          toast.error('로그인 실패. 이메일 혹은 비밀번호를 확인해주세요.');\r\n          return;\r\n        }\r\n\r\n        toast.success('로그인 성공.');\r\n\r\n        router.push('/');\r\n      });\r\n  },\r\n  []\r\n);\r\n```\r\n</CodeBlock>\r\n\r\n`then` 으로 응답 결과를 `response` 로 받아오고 `response.error` 가 있으면 로그인에 실패한 것이고 없으면 성공한 것임을 이렇게 알려주게끔 개선했습니다. 성공을 했을 때에만 홈 페이지로 넘어가도록 만들어두었습니다.\r\n\r\n# 로그아웃 처리\r\n로그인은 이렇게 끝내도록 하고 이제 남은 건 로그아웃인데 로그아웃은 공통 레이아웃에 쓰이는 `UserNav` 컴포넌트에서 로직을 만들어놨습니다. 테스트를 하면서 로그인 로그아웃은 되어야 마음이 편하기 때문에 가장 먼저 만들어두었는데 한 번 어떻게 생겼는지 보도록 합시다.\r\n\r\n<CodeBlock title='UserNav.tsx'>\r\n```tsx\r\n'use client';\r\n\r\nimport { useAppSelector } from '@/src/hooks/rtk';\r\nimport { supabase } from '@/src/utils/supabase/client';\r\nimport Link from 'next/link';\r\nimport React, { useCallback } from 'react';\r\nimport { toast } from 'react-toastify';\r\nimport { ClassNameValue, twJoin } from 'tailwind-merge';\r\n\r\ninterface Props {\r\n  styles?: ClassNameValue;\r\n}\r\n\r\nexport function UserNav({ styles, }: Props) {\r\n  const user = useAppSelector(\r\n    (state) => state.auth.user\r\n  );\r\n\r\n  const onClickSignOut = useCallback(\r\n    () => {\r\n      supabase.auth.signOut()\r\n        .then(() => {\r\n          toast.success('로그아웃 되었습니다.');\r\n        });\r\n    },\r\n    []\r\n  );\r\n\r\n  console.log('user >> ', user);\r\n\r\n  const style = {\r\n    default: twJoin([\r\n      ``,\r\n      styles,\r\n    ]),\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <nav className={style.default}>\r\n        {user ? (\r\n          <>\r\n            <Link href='/mypage'>마이페이지</Link>\r\n            <button onClick={onClickSignOut}>로그아웃</button>\r\n          </>\r\n        ) : (\r\n          <>\r\n            <Link href='/signup'>회원가입</Link>\r\n            <Link href='/signin'>로그인</Link>\r\n          </>\r\n        )}\r\n      </nav>\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n이게 `UserNav` 컴포넌트입니다. 이건 상단 메뉴 오른쪽에 배치를 할건데 지금은 아주 초라한 상태로 보여지고 있습니다.\r\n\r\n<Image src='https://drive.google.com/file/d/1XTPBwU2ms4aKqz3I9vDSqK5eLecVSa1z/view?usp=drive_link' alt='로그인 안된 상태' drive />\r\n\r\n이건 지금 로그인을 하지 않은 상태입니다. 로그인을 하면 세션이 생성되면서 리덕스로 관리하고 있는 user 스테이트에 유저 정보가 들어가게 되고 이 유저 정보를 감지해서 로그인 상태를 유지하는 그런 시스템입니다. user 스테이트에 세션에 담겨 있는 유저 정보를 넣는 로직은 `Nav` 컴포넌트에 만들어두었습니다.\r\n\r\n<CodeBlock title='Nav.tsx'>\r\n```tsx\r\n'use client';\r\n\r\nimport React, { useEffect } from 'react';\r\nimport Link from 'next/link';\r\nimport { ClassNameValue, twJoin } from 'tailwind-merge';\r\nimport { supabase } from '@/src/utils/supabase/client';\r\nimport { useAppDispatch } from '@/src/hooks/rtk';\r\nimport { setUser } from '@/src/reducers';\r\n\r\ninterface Props {\r\n  styles?: ClassNameValue\r\n}\r\n\r\nexport function Nav({ styles, }: Props) {\r\n  const dispatch = useAppDispatch();\r\n\r\n  useEffect(() => {\r\n    const { data, } = supabase.auth.onAuthStateChange(\r\n      (event, session) => {\r\n        switch (event) {\r\n          case 'SIGNED_IN':\r\n            dispatch(setUser(session?.user));\r\n            break;\r\n          case 'SIGNED_OUT':\r\n            dispatch(setUser(null));\r\n            break;\r\n          default:\r\n            break;\r\n        }\r\n      }\r\n    );\r\n\r\n    return () => {\r\n      data.subscription.unsubscribe();\r\n    };\r\n  }, []);\r\n\r\n  const style = {\r\n    default: twJoin([\r\n      ``,\r\n      styles,\r\n    ]),\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <nav className={style.default}>\r\n        <Link href='/'>홈</Link>\r\n        <Link href='/generate'>생성</Link>\r\n      </nav>\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n`supabase.auth.onAuthStateChange` 함수는 세션의 상태를 감지해서 로그인된 상태인지 아닌지에 따라 특정 행동을 하게 만들 수 있는 역할을 합니다. 사실 이 로직은 공통 레이아웃에 포함되는 컴포넌트라면 어디에 있든 상관이 없어서 그냥 `Nav` 컴포넌트에 만들어두었습니다.\r\n\r\n이렇게 해서 회원가입, 로그인, 로그아웃, 구글 로그인, 깃허브 로그인을 전부 다뤄봤습니다. 이제 계정을 생성할 수 있기 때문에 세션이 있느냐 없느냐에 따라 썸네일 생성의 결과 처리에 대한 분기를 설정할 수 있을 것 같습니다. 계속 느끼는 거지만 이런 것들을 직접 구현하려면 다소 시간이 걸리는 편입니다. 액세스 토큰을 관리하는 것도 사실 귀찮은 일이고 리프레시도 해줘야 해서 진짜 그냥 귀찮은 게 아니라 상당히 귀찮은데 이렇게 간단하게 처리할 수 있어서 아주 편합니다.\r\n\r\nSupabase 강력 추천합니다!\r\n\r\n# 마치며\r\n여기까지 Supabase 와 NextJS 의 첫 연결 과정을 다뤄봤습니다. 연결이 끝났으니까 이제 본격적으로 썸네일 관련된 설정을 데이터베이스에 하나 하나 저장하고, 이미지의 결과물은 구글 드라이브에 저장할 수 있도록 처리를 해볼까 합니다. 그 과정을 다음 글에서 진행해보려고 합니다.\r\n\r\n생각해볼 게 하나 있는데 이건 다음 글에서 고민해보도록 하겠습니다.\r\n"},{"id":13,"content":"# 개요\r\n저번 시간에는 Supabase와의 연동에 필요한 것들을 준비하는 시간을 가져봤고 이제부터는 이 Supabase를 사용해보도록 할 겁니다. 본래는 바로 구글 드라이브와의 연동을 하려고 했지만 다소 문제가 있는 것을 깨달아서 순서를 좀 바꿔봤습니다. 먼저 Supabase에서 제공하고 있는 데이터베이스와 스토리지에 데이터와 이미지를 보관하고 사용자가 원하면 구글 드라이브에 이미지를 업로드하는 방향으로 설정하려고 합니다.\r\n\r\n기능 구상을 좀 더 자세하게 다뤄보겠습니다.\r\n\r\n# 기능 구상\r\n<Image src='https://drive.google.com/file/d/1Ax1gozUwXoDdSN4pp_cms88elucSYedd/view?usp=drive_link' alt='이미지로 저장 버튼 보강을 위해..' drive />\r\n\r\n간단한 기능이긴한데 현재 구상은 이렇습니다. 원하는 썸네일 설정을 한 후에 이미지로 저장 버튼을 클릭하면 **html-to-image** 라이브러리를 통해서 html을 `canvas` 로 변환을 해서 변환한 `canvas` 를 가공해서 이미지 URL을 만드는 것이 첫번째입니다. 이 부분까지는 되어있죠. 그리고 `Blob` 데이터를 통해서 Supabase에 파일을 업로드합니다.\r\n\r\n파일을 업로드하면서 동시에 데이터베이스에 사용자가 생성한 이미지의 설정도 함께 저장하는겁니다. 그리고 데이터베이스의 이 테이블에는 생성한 이미지의 주소가 포함되게끔 만들 생각입니다. 그래서 동시에 진행을 하는 것이죠. 역시나 마찬가지로 디자인은 일단 개나주고 기능부터 구현하도록 하겠습니다.\r\n\r\n# Supabase의 스토리지 살펴보기\r\n<Image src='https://drive.google.com/file/d/11E-YakK8IsoikjG24dPUbn1w8RFwHVQM/view?usp=drive_link' alt='스토리지 살펴보기' drive />\r\n\r\nSupabase의 스토리지에는 버킷이라는 파일들의 컨테이너가 있고 그 버킷의 안에 파일이나 폴더를 넣을 수 있습니다. 저는 **thumbnails** 라는 이름으로 버킷을 만들고 이 안에 유저의 식별 번호를 이름으로 만든 폴더 안에 유저가 생성하는 이미지를 넣을 겁니다.\r\n\r\n권한 설정도 해야하는데, 이 부분은 여기서는 굳이 다루지 않으려고 했지만 간단하게 짚고 넘어가봅시다. 나중에 Supabase를 주제로 포스트를 작성하게 되면 그때 하나하나 상세하게 다루는 게 좋을 듯합니다.\r\n\r\nNew bucket 버튼을 클릭하면 새로운 버킷을 만들 수 있고 프라이빗이 아니라 퍼블릭으로 만들어줍니다.\r\n\r\n<Image src='https://drive.google.com/file/d/15vVNKI4pXcx-iosbYjGxX02gaZ0TViFL/view?usp=drive_link' alt='버킷을 만듭니다.' drive />\r\n\r\n그 다음에는 이 버킷에 정책 설정 같은 것들을 해줘야합니다. 쉽게 말해서 권한 설정입니다. 특정 조건이 되어야지만 읽을 수 있고, 업데이트, 삭제할 수 있다 같은 것들이죠.\r\n\r\n좌측 메뉴에서 컨피규레이션에 policies 가 있는데 이걸 클릭하면 정책을 만들 수 있습니다. 새로운 정책 만드는 버튼을 클릭하면 이미 만들어져 있는 템플릿을 쓸건지 직접 커스텀할 것인지 선택할 수 있는데 후자를 선택했습니다.\r\n\r\n그리고 이런식으로 작성을 하는겁니다.\r\n\r\n<Image src='https://drive.google.com/file/d/13cCrxNMS5NpoCA--jUtCoGbU3k3WAlP2/view?usp=drive_link' alt='버킷 권한 설정하기' drive />\r\n\r\n버킷의 이름이 thumbnails 이고 폴더의 이름이 세션에 로그인한 유저의 uuid와 일치할 때에 true가 되기 때문에 그 때 허용한다. 라는 의미입니다. Supabase에서 사용하는 이 문법?들이 정확히 뭔지는 솔직히 제대로 이해가 되지는 않았는데 하다보면 이해가 될 것도 같습니다. 뭐든 사용하려면 공부는 해야겠죠.\r\n\r\n## 스토리지에 이미지 업로드하기\r\n이제 정책을 만들었으니 이미지를 업로드해보도록 합시다. 기존에 이미지로 저장 버튼의 기능은 아래와 같았습니다.\r\n\r\n<CodeBlock title=''>\r\n```tsx\r\nuseEffect(() => {\r\n  if (isLoading) {\r\n    toCanvas(thRef.current, {\r\n      includeQueryParams: true,\r\n      backgroundColor: `rgb(${bgColor.red}, ${bgColor.green}, ${bgColor.blue})`,\r\n      cacheBust: true,\r\n      type: 'image/png',\r\n    }).then((canvas) => {\r\n      setImageSrc(canvas.toDataURL('image/png'));\r\n    }).then(() => {\r\n      setIsLoading(false);\r\n      toast.success('썸네일 이미지가 생성되었습니다.');\r\n    });\r\n  }\r\n}, [ isLoading, thRef, bgColor, ]);\r\n```\r\n</CodeBlock>\r\n\r\n`canvas.toDataURL` 메소드로 `img` 태그에 넣을 주소를 생성하고 이걸 그냥 보여주기만 했었는데 주소는 주소대로 생성을 하고 추가적으로 파일을 업로드하기 위한 준비 작업을 추가해야합니다. 이 때 `Blob` 데이터가 필요한데 `canvas` 는 `Blob` 데이터를 우리한테 제공해줄 수 있습니다.\r\n\r\n<CodeBlock title=''>\r\n```tsx {10-25}\r\nuseEffect(() => {\r\n  if (isLoading) {\r\n    toCanvas(thRef.current, {\r\n      includeQueryParams: true,\r\n      backgroundColor: `rgb(${bgColor.red}, ${bgColor.green}, ${bgColor.blue})`,\r\n      cacheBust: true,\r\n      type: 'image/png',\r\n    }).then((canvas) => {\r\n      setImageSrc(canvas.toDataURL('image/png'));\r\n      canvas.toBlob((blob) => {\r\n        const file = new File([ blob, ], 'image.png', {\r\n          type: 'image/png',\r\n        });\r\n\r\n        const folder = user.id;\r\n        const nowDate = Nihil.date().format();\r\n\r\n        supabase.storage.from('thumbnails').upload(\r\n          `${folder}/${nowDate}.png`,\r\n          file,\r\n          {\r\n            contentType: 'image/png',\r\n          }\r\n        )\r\n      });\r\n    });\r\n  }\r\n}, [ isLoading, thRef, bgColor, ]);\r\n```\r\n</CodeBlock>\r\n\r\n10-25번이 파일을 업로드하는 로직입니다. 먼저 `canvas.toBlob` 으로 `Blob` 을 생성하고 그 내부에서 파일 객체를 만듭니다. 폴더 아이디는 세션에 로그인된 유저의 uuid이고 파일의 이름은 업로드하는 현재 시간을 사용하기로 했습니다. 그럼 중복이 되지 않겠죠.\r\n\r\n`Nihil.date().format()` 는 제가 만든 메소드입니다. 이렇게 하고 `supabase.storage.from('thumbnails')` 으로 버킷을 지정해줍니다. 그 다음에 `upload` 메소드로 파일에 대한 정보를 전달하면 됩니다. 그리고 버튼을 클릭해봅시다.\r\n\r\n<Image src='https://drive.google.com/file/d/1E3uftQW-EOQGwUzymRNG9SVjFCgSf4UU/view?usp=drive_link' alt='이미지가 업로드됩니다.' drive />\r\n\r\n이렇게 이미지가 업로드 되는 모습을 볼 수 있습니다. 클릭을 해보면 설정한대로 잘 올라가 있습니다. 잘 활용만 하면 편리한 서비스가 될 거 같은데 좀 더 사용해보고 판단해야겠습니다.\r\n\r\n# Supabase의 데이터베이스 살펴보기\r\n이제 썸네일 이미지가 올라갔으니까 썸네일에 사용된 설정을 저장해야합니다. 그래야 같이 엮어서 관리가 가능합니다. 그러기 위해서는 데이터베이스를 활용해야 합니다. Supabase의 데이터베이스는 특별한 것은 없고 **PostgreSQL**을 사용하고 있습니다. 테이블을 만들거나 테이블에 데이터를 입력하고, 삭제하고 등등 전부 일반 데이터베이스를 활용하는 방법과 같습니다.\r\n\r\n다만 Supabase에서 제공하는 메소드로 처리한다는 점이 다를 뿐이죠. 경우에 따라서는 prisma를 이용할 수도 있습니다. 저는 그렇게 안했지만요. 자 저는 이미 테이블을 만들어놨습니다. 임시로 데이터도 대충 넣어봤습니다.\r\n\r\n<Image src='https://drive.google.com/file/d/1-wsFiOQVCJLau6mULmq059NwCQG0kuYL/view?usp=drive_link' alt='테이블과 레코드' drive />\r\n\r\n테이블을 만들고 권한 설정을 하는 것도 스토리지 버킷 만들기와 별반 차이가 없으니 이 부분은 과감하게 생략하도록 하겠습니다. 이제 이번 글의 최종적인 코드를 보면서 설명을 마저 하도록 하겠습니다.\r\n\r\n## 테이블에 데이터 INSERT 하기\r\n테이블을 선택하는 방법은 `supabase.from()` 메소드를 이용하는 겁니다. `supabase.from('thumbnails')` 이런식으로 테이블을 지정해줍니다. 그리고나서 조회면 `select()` 삽입이면 `insert()` 이런 메소드들을 추가로 이용해서 기능을 구현하면 됩니다.\r\n\r\n우리한테 필요한 기능은 `insert()` 입니다.\r\n\r\n<CodeBlock title=''>\r\n```tsx {24-57}\r\nuseEffect(() => {\r\n  if (isLoading) {\r\n    toCanvas(thRef.current, {\r\n      includeQueryParams: true,\r\n      backgroundColor: `rgb(${bgColor.red}, ${bgColor.green}, ${bgColor.blue})`,\r\n      cacheBust: true,\r\n      type: 'image/png',\r\n    }).then((canvas) => {\r\n      setImageSrc(canvas.toDataURL('image/png'));\r\n      canvas.toBlob((blob) => {\r\n        const file = new File([ blob, ], 'image.png', {\r\n          type: 'image/png',\r\n        });\r\n\r\n        const folder = user.id;\r\n        const nowDate = Nihil.date().format();\r\n\r\n        supabase.storage.from('thumbnails').upload(\r\n          `${folder}/${nowDate}.png`,\r\n          file,\r\n          {\r\n            contentType: 'image/png',\r\n          }\r\n        ).then(async (response) => {\r\n          const fileUrl = supabase.storage\r\n            .from('thumbnails')\r\n            .getPublicUrl(response.data.path);\r\n\r\n          const settingSave = await supabase.from('thumbnails').insert({\r\n            title,\r\n            subTitle,\r\n            usersId: user.id,\r\n            textRed: textColor.red,\r\n            textGreen: textColor.green,\r\n            textBlue: textColor.blue,\r\n            bgRed: bgColor.red,\r\n            bgGreen: bgColor.green,\r\n            bgBlue: bgColor.blue,\r\n            imageSrc: imgSrc,\r\n            imagePosition: imageY,\r\n            imageLink: fileUrl.data.publicUrl,\r\n          }).select('id');\r\n\r\n          if (settingSave.data) {\r\n            setRowId(settingSave.data[0].id);\r\n          }\r\n\r\n          if (!settingSave.error) {\r\n            toast.success('설정이 저장되었습니다.');\r\n          } else {\r\n            toast.error('설정이 저장되지 않았습니다.');\r\n          }\r\n\r\n          setImagePath(response.data.path);\r\n          setIsLoading(false);\r\n          toast.success('썸네일 이미지가 생성되었습니다.');\r\n        });\r\n      });\r\n    });\r\n  }\r\n}, [ isLoading, thRef, bgColor, ]);\r\n```\r\n</CodeBlock>\r\n\r\n업로드가 끝나면 실행될 수 있게 `then` 을 통해 다음 코드를 작성합니다. `response` 에는 업로드 된 파일의 주소가 있습니다. 이 주소를 통해서 공개 URL을 가져올 수도 있습니다. 25번에서 27번줄이 그 내용입니다. 일단 주소를 가져오는 이유는 데이터베이스에 함께 저장하기 위해서입니다.\r\n\r\n그리고 29-42번 줄에 보이는 것처럼 데이터를 `insert` 합니다. 마지막에 `imageLink` 링크 라는 컬럼에 가져온 주소를 넣어줍니다. 이렇게 하면 썸네일 관리 목록에서 썸네일을 띄워주고, 구분짓게 할 수 있겠죠. `.select('id')` 는 `insert` 한 뒤에 새로 추가된 레코드의 `id` 값을 반환하라. 라는 의미입니다. `id` 값을 저장해두고 다음에 만들 기능에 사용하기 위해서 받는다고 보면 됩니다.\r\n\r\n아직은 준비된 페이지가 아니지만 썸네일 관리를 할 때 각 항목들의 페이지가 있어야 하고 그 페이지의 링크에 사용할 예정입니다. `rowId` 스테이트에 레코드의 아이디 값을 저장해두고 이걸 링크에 이용하는 것이죠.\r\n\r\n<CodeBlock title=''>\r\n```tsx\r\nconst onClickManage = useCallback(() => {\r\n  router.push(`/thumbnails/${rowId}`);\r\n}, [ rowId, ]);\r\n```\r\n</CodeBlock>\r\n\r\n이런식으로 `router.push` 를 시켜서 썸네일 개별 관리 페이지로 넘어가게 만들었습니다. 최종적인 썸네일 생성 완료 화면은 아래와 같습니다. 버튼을 클릭하고 이미지를 생성중인 모습과 생성이 완료된 후의 모습입니다.\r\n\r\n<Image src='https://drive.google.com/file/d/1qpwFd2uZDIWVs9h5NzTUmX1ZDdLVLsAH/view?usp=drive_link' alt='썸네일을 생성중인 모습' drive />\r\n\r\n<Image src='https://drive.google.com/file/d/11psaiMksSgieNbocjvYFQmUd5BONsOiF/view?usp=drive_link' alt='썸네일이 생성된 후의 모습' drive />\r\n\r\n하지만 아직 저 **썸네일 관리** 버튼을 클릭한다고 페이지가 넘어가지는 않습니다. 에러 페이지로는 넘어가겠네요. 왜냐면 아직 만들어진 페이지가 아니라서 그렇습니다. 그러면 썸네일 관리 페이지도 간단하게 만들기만 하고 넘어가도록 해야겠습니다. 디자인은 지금 안할 것이기 때문에 생략하고 시작해보도록 합시다.\r\n\r\n# 관리 페이지 만들기\r\n관리 페이지는 마이페이지에서 접근이 가능하게 만들 겁니다. 마이 페이지는 이미 만들어놨는데 페이지만 있을 뿐이고 아직 내부는 만들지 않았습니다. 그래서 이제 간단하게 항목들의 이름만 보이게 만들어놓고 클릭하면 각각의 관리 페이지로 넘어가게끔 하려고 합니다. 지금 당장은 말이죠.\r\n\r\n<Image src='https://drive.google.com/file/d/11W3Ge0n9-JiCbF_8agO5xd34pijJlgS4/view?usp=drive_link' alt='초라한 마이 페이지..' drive />\r\n\r\n이제 컨텐츠를 가져와야겠죠. 우리는 컨텐츠를 데이터베이스에 저장해두었기 때문에 그걸 가져오면 됩니다. Supabase의 강력한 기능을 이용해서 말이죠.\r\n\r\n<CodeBlock title='MyThumbnails.tsx'>\r\n```tsx\r\nconst [ thumbnails, setThumbnails, ] = useState([]);\r\n\r\nuseEffect(() => {\r\n  const getThmubnails = async () => {\r\n    const thumbnails = await supabase.from('thumbnails').select();\r\n\r\n    setThumbnails(thumbnails.data);\r\n  };\r\n\r\n  getThmubnails();\r\n}, []);\r\n```\r\n</CodeBlock>\r\n\r\n먼저 스테이트를 만듭니다. 이 페이지 자체에서 데이터를 보관할 수단이 필요하거든요. 다른 페이지에서는 쓰이지 않을 것이라서 `useState` 만 있으면 됩니다. 이게 1번이죠.\r\n\r\n그리고나서 `useEffect` 로 데이터를 고정시키면 됩니다. 이게 3번부터의 내용입니다. `supabase.from()` 과 `select()` 로 데이터를 가져온 후에 `setThumbnails` 로 데이터를 스테이트에 넣어줍니다. 그러면 아래처럼 데이터를 뿌려줄 수가 있죠.\r\n\r\n<CodeBlock title='MyThumbnails.tsx'>\r\n```tsx\r\nexport function MyThumbnails({ styles, }: Props) {\r\n  return (\r\n    <>\r\n      <div>\r\n        {thumbnails.map((thumbnail) => (\r\n          <div key={Nihil.uuid(0)}>\r\n            {thumbnail.title}\r\n          </div>\r\n        ))}\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n<Image src='https://drive.google.com/file/d/1X6EGigO2iBiOcdISt1Rj4RjTwV8BXq52/view?usp=drive_link' alt='제목들이 나열된 모습' drive />\r\n\r\n이제 이 제목들에 링크를 주고 링크를 클릭하면 각 페이지로 넘어가게 하면 됩니다. 페이지를 하나 더 만드는데 이번에는 동적 라우팅이 되어야합니다. app router 에서는 아래처럼 구현합니다. 기존에는 `getStaticPaths` 가 필요했는데 이제는 `generateStaticParams` 가 필요합니다. 아무튼 아래처럼 경로 매개변수 정보를 배열 형태로 넘겨주면 되는겁니다.\r\n\r\n<CodeBlock title='app/thumbnails/[id]/page.tsx'>\r\n```tsx\r\nexport async function generateStaticParams() {\r\n  const { data, } = await supabase\r\n    .from('thumbnails').select();\r\n\r\n  return data.map((item) => ({\r\n    id: item.id,\r\n  }));\r\n}\r\n\r\ninterface Props {\r\n  params: {\r\n    id: string;\r\n  };\r\n}\r\n\r\nexport default function ThumbnailManagePage({ params: { id, }, }: Props) {\r\n  console.log('id >> ', id);\r\n\r\n  return (\r\n    <>\r\n      <ThumbnailData id={id} />\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n`generateStaticParams` 를 통해서 데이터를 가져오고 배열 형태로 가공해서 리턴해주면 NextJS 는 이런 경로가 있겠구나 하는걸 인지하고 해당 경로면 페이지를 던져줍니다. 만약에 이 페이지가 없다면 에러페이지로 넘겨주면 될 것 같습니다.\r\n\r\n그러면 이제 `ThumbnailManagePage` 컴포넌트에서 `params` 라는 프롭을 사용할 수 있게 됩니다. 여기에 데이터가 들어있죠. 이걸 콘솔로 찍어봤습니다.\r\n\r\n<Image src='https://drive.google.com/file/d/1MvtV4XSX40fCYcaUil9QiAS39qAYyBoV/view?usp=drive_link' alt='id가 경로 매개변수로 잘 넘어오는 모습' drive />\r\n\r\n이렇게 잘 넘어오고 있죠. 이제 리스트 항목을 클릭하면 이 페이지로 잘 넘어오게 되고 여기서 또 개별 데이터를 fetching 해서 데이터를 뿌려주면 되겠죠. 이렇게요.\r\n\r\n<CodeBlock title='ThumbnailData.tsx'>\r\n```tsx\r\ninterface Props {\r\n  id: string;\r\n  styles?: ClassNameValue;\r\n}\r\n\r\nexport function ThumbnailData({ id, styles, }: Props) {\r\n  const [ thumbnail, setThumbnail, ] = useState(null);\r\n  useEffect(() => {\r\n    const getThumbnailById = async () => {\r\n      const { data: [ thumbnail, ], } = await supabase\r\n        .from('thumbnails').select().eq('id', id);\r\n\r\n      setThumbnail(thumbnail);\r\n    };\r\n\r\n    getThumbnailById();\r\n  }, []);\r\n\r\n  const style = {\r\n    default: twJoin([\r\n      ``,\r\n      styles,\r\n    ]),\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <div className={style.default}>\r\n        <div>{thumbnail?.title}</div>\r\n        <div>{thumbnail?.user_id}</div>\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n<Image src='https://drive.google.com/file/d/11pJFTLs1JmPQUBkpPeOG7A-Hj6UxLZIf/view?usp=drive_link' alt='관리 페이지에 데이터 뿌려주기' drive />\r\n\r\n다른 건 다 똑같은데 `eq` 함수를 이용해서 특정 컬럼의 같은 값만 가져오는 로직이 있습니다. 이를 통해서 하나의 값만을 가져올 수가 있고 이렇게 가져와서 스테이트에 넣어주고 렌더링을 하는 과정입니다. 여기까지 했으니까 이번 글은 여기서 마치도록 하고 다음 글 준비를 해야겠습니다.\r\n\r\n# 마치며\r\nSupabase를 통해서 썸네일 이미지를 업로드하고, 설정 데이터들도 데이터베이스에 저장을 해서 관리하기 편하게 만드는 발판을 마련했습니다. 다음 글에서는 그동안 미뤄놨던 디자인이 어느정도 되어 있을 거고 이 오늘 작업한 썸네일 관리 페이지도 대강의 모습을 갖추지 않을까 생각됩니다.\r\n"},{"id":2,"content":"\r\n# 개요\r\n첫 번째 글에서 예고했던 대로 썸네일 생성기를 만들어 보려고 합니다. 솔직히 이미 답은 정해져 있는 것 같지만 어떤 스택을 활용할 것인지 생각해 본 후에 개발을 위한 구상 작업을 하려고 합니다. 이번 글에서는 기능에 대해 구상하고 활용 기술 스택에 대해서 구상을 해보는 시간을 가져봅니다.\r\n\r\n완성까지 얼마나 걸릴지, 그리고 몇편의 글이 작성되어야 완성할 수 있을지 모르겠지만 일단 시작해보도록 합시다!\r\n\r\n# 기술 스택\r\n\r\n- NextJS(리액트, 라우팅)\r\n- TailwindCSS & Emotion\r\n- Googleapis\r\n\r\n## NextJS(리액트, 라우팅)\r\n기술 스택은 사실 전부 정해져 있습니다. HTML, CSS, JS가 기본적으로 사용되기 때문에 리액트를 사용하지 않을 수가 없죠. 이번 토이 프로젝트는 **NextJS**를 이용해서 만들려고 합니다. 단일 페이지라면 굳이 **NextJS**가 필요 없겠지만 단일 페이지로 만들지는 않을 것이기 때문에 **NextJS**를 사용하려고 합니다.\r\n\r\n## TailwindCSS & Emotion\r\n이 두가지는 스타일링을 위한 라이브러리입니다. <A href='https://emotion.sh/docs/introduction' external>Emotion</A>은 <A href='https://styled-components.com/' external>StyledComponents</A>처럼 리액트 내에서 스타일이 적용된 컴포넌트를 만들 수도 있고 CSS 규칙을 컴포넌트에 적용하는 방법도 사용할 수 있는 편리한 라이브러리입니다.\r\n\r\n<A href='https://tailwindcss.com/' external>TailwindCSS</A> 또한 유명하죠. 부트스트랩처럼 클래스이름을 입력하면 스타일이 적용되는 아주 편리한 스타일시트 프레임워크입니다. 저는 이 두가지를 합쳐서 사용합니다. 설정은 다소 필요하지만 그 설정만 하면 좀 더 편리하게 두가지 라이브러리를 사용할 수 있습니다.\r\n\r\nTailwindCSS의 경우에는 클래스 이름으로 스타일링을 하기 때문에 복잡한 스타일의 경우에는 클래스가 길어지는 안타까운 현상이 존재합니다. 하지만 이 두가지를 합치게 되면 그 문제가 많이 해소됩니다. 두가지 라이브러리를 합치는 방법은 <A href='https://github.com/ben-rogerson/twin.macro' external>twin.macro</A>를 사용하는 것입니다.\r\n\r\n## Googleapis\r\n이미지를 생성하면 구글 드라이브에 업로드를 하고, 그 주소를 가져와서 관리할 수 있는 시스템을 구현하려고 합니다. 그래서 필요한 것은 구글 API를 사용하는 것입니다. 최근 회사에서 구글 API를 이용해서 업무를 진행한 적이 있는데 그때는 리액트로 한 것이 아니었고 이번에는 리액트로 진쟁해보고 싶었습니다.\r\n\r\n어차피 포스트도 작성해야하니까 구글 클라우드 콘솔에서 클라이언트 키를 받는 것부터 라이브러리를 활용해 토큰을 받아 활용하는 것까지 전부 포스트에 담아낼 예정입니다.\r\n\r\n# 기능 구상\r\n일단 다른 것보다도 제가 썸네일을 만들기 위해서 진행하는 부분도 있기 때문에 제가 편해야합니다. 그 다음에 다른 기능들도 추가하는 것이 좋을 듯합니다. 기본적으로 해상도는 1280\\*720으로 생각하고 있습니다.\r\n\r\n- 제목과 부제 입력하기\r\n- 단색 배경, 이미지 배경 지원\r\n- 사용자 구글 드라이브 연동\r\n\r\n## 제목과 부제 입력하기\r\n썸네일에 텍스트는 반드시 필요합니다. 썸네일이라고 해서 단순히 이미지만 있어서는 이게 어떤 글인지 전혀 알 수가 없기 때문입니다. 때문에 텍스트는 입력할 수 있어야합니다. 이 때 간편하게 폼 요소를 컨트롤 할 수 있도록 <A href='https://www.react-hook-form.com/' external>react-form-hook</A>을 사용하려고 합니다.\r\n\r\n## 단색 배경, 이미지 배경 지원\r\n단색 배경은 기본으로 제공하고 이미지 배경을 원할 시에는 이미지를 가져와서 설정할 수 있도록 개발할 생각입니다. 이미지가 들어가면 제목이나 다른 텍스트들이 잘 안보일 수 있기 때문에 잘 보일 수 있게끔 추가적으로 처리하는 것도 생각해봐야합니다.\r\n\r\n단색의 경우에는 사용자가 원하는 색상을 선택할 수 있도록 RGB 값을 입력하게 할 예정입니다.\r\n\r\n## 사용자 구글 드라이브와의 연동\r\n위에서 언급했듯이 구글 드라이브에 이미지를 업로드 할 수 있는 기능까지 제공할 예정입니다. 구글 드라이브인 이유는 제가 이미지 호스팅을 구글 드라이브에 하고 있기 때문이죠 하하. 이미 저장한 이미지를 관리한다고 해서 수정할 수 있는 것은 아닙니다. 아마도요..?\r\n\r\n이미지를 업로드 할 때에는 사용자가 폴더를 선택하는 것이 아니라 업로드 할 때부터 썸네일 생성기가 지정한 폴더에 업로드 되게 할 것입니다. 이런 부분도 나중에 살펴보도록 합시다.\r\n\r\n# 간략한 화면에 대한 구상\r\n자 그럼 마지막으로 화면에 대한 구상을 해보도록 해야겠습니다. 아주 간단하게 어떤 블럭들이 위치할지 레이아웃을 잡아보려고 합니다. 이미지 관리 페이지는 나중으로 미뤄두고 일단은 썸네일을 생성하는 메인 페이지부터 생각해봐야합니다.\r\n\r\n<Image src='https://drive.google.com/file/d/1xjTBjwOhyFgE0xxgOlie_gF_E4oLPvUL/view?usp=drive_link' alt='화면 와이어 프레임' drive />\r\n\r\n간단하게 Low-Fi 와이어 프레임을 만들어봤습니다. 상단의 제일 큰 부분은 이미지가 될 부분이고 그 아래에는 제목과 부제가 들어갈 텍스트입니다. 텍스트의 아래에는 이제 탭이 들어올 자리인데 단색 배경이냐 이미지 배경이냐에 따라서 다르게 보일 부분입니다. 대략적으로 이런 그림.. 일 것 같은데 또 하다가 바뀔 수도 있을 듯합니다.\r\n\r\n자 이제 대략적인 구상은 끝났으니까 본격적으로 작업을 하는 것은 다음 글부터인 것으로 결정하고 이번 글은 여기서 마무리 하겠습니다.\r\n"},{"id":3,"content":"\r\n# 개요\r\n저번 시간에는 썸네일 생성기에 대한 기본적인 구상을 해봤습니다. 사용할 기술 스택도 정해졌고 아주 대략이지만 어떤 화면을 구성해볼지도 간단하게 정해봤습니다. 이번 글에서는 개발을 위한 환경을 구성하고 구상한 화면을 만들어보도록 하겠습니다.\r\n\r\n저는 제가 프로젝트를 할 때마다 사용하는 템플릿이 따로 있는데 이번에는 그걸 사용하기보다는 처음부터 환경을 만들어보려고 합니다. 그럼 시작해봅시다.\r\n\r\n# `create-next-app`을 통한 개발환경 구축\r\n<CodeBlock title=''>\r\n```bash\r\nyarn create next-app thumbnail-generator\r\n```\r\n</CodeBlock>\r\n\r\n가장 먼저 `create-next-app`을 이용해서 **NextJS** 프로젝트를 만들어줍니다. 저같은 경우는 이 도구를 사용하지 않고 하나 하나 만들었었는데 요즘에는 그냥 이런 도구를 사용하는 것이 더 효율적이라서 사용하자라고 생각하는 중입니다.\r\n\r\n<Image src='https://drive.google.com/file/d/1qJZXr-e8JH9cyc6gcZcy_-NtfqTwtORS/view?usp=drive_link' alt='create-next-app 설정 화면' drive />\r\n\r\n필요한 것을 알아서 설정을 해주면 됩니다. 저는 여기 설정을 전부 사용하기 때문에 전부 Yes로 설정했습니다. 사실 이런 도구를 사용하면 바로 사용할 수 있습니다. **TailwindCSS**와 **Emotion**을 연동하기만 하면 말이죠. 그 외에도 자잘한 설정을 좀 해야합니다. 여기서부터 그냥 진행하고 싶다면 `yarn run dev` 혹은 `npm run dev` 를 실행해서 NextJS 서버를 실행해도 됩니다.\r\n\r\nNextJS는 pages 라우트와 app 라우트가 있는데 저는 항상 pages 라우트를 사용하기 때문에 이번에도 pages 라우트로 가도록 하겠습니다. 이 두가지가 어떤 차이가 있는지는 NextJS에 대한 포스트를 작성할 때 제대로 해보도록 하고 지금은 설정을 마저 진행하도록 하겠습니다.\r\n\r\n# Emotion 설정하기\r\nTailwindCSS는 설치가 되어있지만 Emotion은 직접 설치를 해야합니다. twin.macro도 같이 설치해주도록 합시다.\r\n\r\n<CodeBlock title=''>\r\n```bash\r\nyarn add @emotion/react @emotion/styled @emotion/serialize\r\nyarn add -D twin.macro babel-loader @emotion/babel-plugin babel-plugin-macros @babel/plugin-syntax-typescript @babel/preset-react @svgr/webpack\r\nyarn add -D @babel/core babel-plugin-macros @emotion/babel-plugin @emotion/babel-preset-css-prop\r\n```\r\n</CodeBlock>\r\n\r\nEmotion과 관련된 패키지들입니다. 전부 설치를 한 후에 설정을 진행해봅시다. 먼저 루트 폴더에 `.babelrc.js` 파일을 만들어서 바벨 관련된 설정을 하면서 twin.macro 설정을 해줄 겁니다.\r\n\r\n<CodeBlock title='.babelrc.js'>\r\n```js\r\nmodule.exports = {\r\n  presets: [\r\n    [\r\n      'next/babel',\r\n      {\r\n        'preset-react': {\r\n          runtime: 'automatic',\r\n          importSource: '@emotion/react',\r\n        },\r\n      },\r\n    ],\r\n  ],\r\n  plugins: [\r\n    '@emotion/babel-plugin',\r\n    'babel-plugin-macros',\r\n    [\r\n      '@babel/plugin-syntax-typescript',\r\n      { isTSX: true },\r\n    ],\r\n  ],\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n이렇게 해주면 NextJS가 실행될 때 알아서 바벨 설정을 이 내용으로 덮어씌워줍니다.\r\n\r\n# 타입스크립트 관련 설정하기\r\n루트폴더에 `twin.d.ts` 파일을 만들거나 `src/types` 폴더를 만들어서 그 안에 이 파일을 만들거나 원하는대로 진행하시면 되는데 `twin.d.ts`의 내용물은 아래와 같아야 합니다.\r\n\r\n<CodeBlock title='twin.d.ts'>\r\n```ts\r\nimport 'twin.macro';\r\nimport { css as cssImport } from '@emotion/react';\r\nimport { CSSInterpolation } from '@emotion/serialize';\r\nimport styledImport from '@emotion/styled';\r\n\r\ndeclare module 'twin.macro' {\r\n  // The styled and css imports\r\n  // eslint-disable-next-line no-unused-vars\r\n  const styled: typeof styledImport;\r\n  // eslint-disable-next-line no-unused-vars\r\n  const css: typeof cssImport;\r\n}\r\n\r\ndeclare module 'react' {\r\n  // The css prop\r\n  // eslint-disable-next-line no-unused-vars\r\n  interface HTMLAttributes<T> extends DOMAttributes<T> {\r\n    css?: CSSInterpolation\r\n  }\r\n  // The inline svg css prop\r\n  // eslint-disable-next-line no-unused-vars\r\n  interface SVGProps<T> extends SVGProps<SVGSVGElement> {\r\n    css?: CSSInterpolation\r\n  }\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n`SVGProps` 부분은 없어도 됩니다. 저는 `svg` 파일도 즐겨쓰다보니 넣어둔 것이므로 무시하셔도 무방합니다. 이렇게 만든 파일을 적용해야하는데 루트 폴더 안에 있는 `tsconfig.json` 파일에서 아래의 내용들을 추가해주면 됩니다.\r\n\r\n<CodeBlock title='tsconfig.json'>\r\n```json {11, 36}\r\n{\r\n  \"compilerOptions\": {\r\n    \"target\": \"es5\",\r\n    \"lib\": [\r\n      \"dom\",\r\n      \"dom.iterable\",\r\n      \"esnext\"\r\n    ],\r\n    \"allowJs\": true,\r\n    \"skipLibCheck\": true,\r\n    \"strict\": false,\r\n    \"noEmit\": true,\r\n    \"esModuleInterop\": true,\r\n    \"module\": \"esnext\",\r\n    \"moduleResolution\": \"bundler\",\r\n    \"resolveJsonModule\": true,\r\n    \"isolatedModules\": true,\r\n    \"jsx\": \"preserve\",\r\n    \"incremental\": true,\r\n    \"plugins\": [\r\n      {\r\n        \"name\": \"next\"\r\n      }\r\n    ],\r\n    \"paths\": {\r\n      \"@/*\": [\r\n        \"./src/*\"\r\n      ]\r\n    }\r\n  },\r\n  \"include\": [\r\n    \"next-env.d.ts\",\r\n    \"**/*.ts\",\r\n    \"**/*.tsx\",\r\n    \".next/types/**/*.ts\",\r\n    \"**/*.d.ts\"\r\n  ],\r\n  \"exclude\": [\r\n    \"node_modules\"\r\n  ]\r\n}\r\n```\r\n</CodeBlock>\r\n\r\nEmotion과 TailwindCSS를 아주 유연하게 사용할 수 있게 됩니다.\r\n\r\n# next.config.js 설정하기\r\n<CodeBlock title='next.config.js'>\r\n```js\r\n/** @type {import('next').NextConfig} */\r\nconst config = {\r\n  swcMinify: false,\r\n  eslint: {\r\n    dirs: [],\r\n  },\r\n  typescript: {\r\n    ignoreBuildErrors: true,\r\n  },\r\n  images: {\r\n    domains: [ '여기에 도메인', ],\r\n  },\r\n  experimental: {\r\n    largePageDataBytes: 128 * 100000,\r\n  },\r\n  webpack(config) {\r\n    config.module.rules.push({\r\n      test: /\\.svg$/,\r\n      use: [ '@svgr/webpack', ],\r\n    });\r\n    return config;\r\n  },\r\n};\r\n\r\nmodule.exports = config;\r\n```\r\n</CodeBlock>\r\n\r\n`swcMinify`는 true로 해두면 가끔 에러를 만나서 그냥 false로 설정해서 꺼두는 편인데 자유롭게 하시면 됩니다. 사실 저 설정들은 그냥 여러분이 원하는대로 설정하면 됩니다. 이 설정은 저에게 최적화된 설정들입니다.\r\n\r\n# ESLint 설정\r\nESLint는 개발을 하는데에 있어서 빠질 수 없는 요소중 하나입니다. 코드의 규칙을 설정할 수 있고 그 규칙에 맞지 않는 코드가 있으면 빨간색으로 에러 표시를 띄워줍니다. 타입스크립트랑 같이 사용하면 더할나위 없이 좋습니다.\r\n\r\n설정을 하기에 앞서 설치해야 하는 패키지들이 있습니다.\r\n\r\n<CodeBlock title=''>\r\n```bash\r\nyarn add -D eslint eslint-config-airbnb eslint-plugin-html eslint-plugin-react eslint-plugin-import eslint-plugin-react-hooks eslint-plugin-jsx-a11y @typescript-eslint/eslint-plugin @typescript-eslint/parser\r\n```\r\n</CodeBlock>\r\n\r\n설치를 한 다음에 `.eslintrc.js` 파일을 수정해주면 됩니다.\r\n\r\n<CodeBlock title='.eslintrc.js'>\r\n```js\r\nmodule.exports = {\r\n  root: true,\r\n  env: {\r\n    browser: true,\r\n    commonjs: true,\r\n    node: true,\r\n    es2021: true,\r\n  },\r\n  parser: '@typescript-eslint/parser',\r\n  extends: [\r\n    'airbnb',\r\n    'airbnb/hooks',\r\n    'plugin:import/errors',\r\n    'plugin:import/warnings',\r\n    'eslint:recommended',\r\n    'plugin:react/recommended',\r\n    'plugin:@typescript-eslint/recommended',\r\n  ],\r\n  parserOptions: {\r\n    ecmaVersion: 2021,\r\n    sourceType: 'module',\r\n    ecmaFeatures: {\r\n      jsx: true,\r\n    },\r\n  },\r\n  plugins: [ '@typescript-eslint', 'import', 'react', 'react-hooks', 'html', ],\r\n  rules: {\r\n    // 일반 규칙 ...\r\n    // 임포트 규칙 ...\r\n    // 타입스크립트 규칙 ...\r\n    // 리액트 규칙 ...\r\n    // 리액트 훅스 규칙 ...\r\n    // jsx 규칙 ...\r\n  },\r\n};\r\n```\r\n</CodeBlock>\r\n\r\n제가 리액트를 사용할 때면 항상 사용하는 규칙입니다. 코드 설정 때문에 글이 길어지는 것처럼 보이지만 사실은 정말 별거 아닌 내용인게 참 재밌는 것 같네요.\r\n\r\n# Tailwind 설정하기\r\n\r\n아무튼 이제 마지막입니다. TailwindCSS 설정을 해야됩니다.\r\n\r\n기본적인 것은 이미 되어있는 상태입니다. 루트 폴더 아래에 있는 `tailwind.config.js` 파일을 내키는대로 꾸며주면 됩니다! 저같은 경우는 다른 건 그렇다 치고 의사 클래스 부분과 미디어 쿼리를 편하게 사용하기 위해서 아래처럼 설정해두었습니다.\r\n\r\n<CodeBlock title='tailwind.config.js'>\r\n```js\r\nconst plugin = require('tailwindcss/plugin');\r\n\r\n/** @type {import('tailwindcss').Config} */\r\nmodule.exports = {\r\n  darkMode: 'class',\r\n  content: [\r\n    './src/components/**/*.{js,ts,jsx,tsx}',\r\n    './src/layouts/**/*.{js,ts,jsx,tsx}',\r\n    './src/pages/**/*.{js,ts,jsx,tsx}',\r\n  ],\r\n  theme: {\r\n    extend: {\r\n      // ...\r\n      screens: {\r\n        'mf-sm': { min: '480px', },\r\n        'mf-md': { min: '768px', },\r\n        'mf-lg': { min: '1024px', },\r\n      },\r\n      // ...\r\n    },\r\n  },\r\n  plugins: [\r\n    require('@tailwindcss/typography'),\r\n    plugin(({ addVariant, }) => {\r\n      addVariant('first', [ '&:first-of-type', ]);\r\n      addVariant('last', [ '&:last-of-type', ]);\r\n      addVariant('not-first', [ '&:not(:first-of-type)', ]);\r\n      addVariant('not-last', [ '&:not(:last-of-type)', ]);\r\n      addVariant('hocus', [ '&:hover', '&:focus', ]);\r\n      addVariant('nth-1', '&:nth-of-type(1)');\r\n      addVariant('nth-2', '&:nth-of-type(2)');\r\n      addVariant('nth-3', '&:nth-of-type(3)');\r\n      addVariant('nth-4', '&:nth-of-type(4)');\r\n      addVariant('nth-5', '&:nth-of-type(5)');\r\n      addVariant('nth-last-1', '&:nth-last-of-type(1)');\r\n      addVariant('nth-last-2', '&:nth-last-of-type(2)');\r\n      addVariant('nth-last-3', '&:nth-last-of-type(3)');\r\n      addVariant('nth-last-4', '&:nth-last-of-type(4)');\r\n      addVariant('nth-last-5', '&:nth-last-of-type(5)');\r\n    }),\r\n  ],\r\n};\r\n```\r\n</CodeBlock>\r\n\r\n저는 반응형을 만들때 모바일 퍼스트를 주로 사용하기 때문에 저런 순서로 설정을 했고 플러그인 같은 경우에는 의사 클래스를 추가해줄 수 있습니다. 자주 사용할 것 같은 것들만 모아다가 이렇게 설정을 해둔 상태입니다.\r\n\r\n그리고 TailwindCSS의 기본 css 파일도 조금 수정하겠습니다.\r\n\r\n<CodeBlock title='global.css'>\r\n```css {7}\r\n@import url(https://fonts.googleapis.com/earlyaccess/notosanskr.css);\r\n@import url(https://fonts.cdnfonts.com/css/cascadia-code);\r\n\r\n@tailwind base;\r\n@tailwind components;\r\n@tailwind utilities;\r\n@tailwind variants;\r\n```\r\n</CodeBlock>\r\n\r\n7번..이 맞았을겁니다. 아무튼 저 네가지가 다 있으면 됩니다. 이렇게 하면 정말로 모든 설정이 끝난겁니다. 설정이 잘 적용되었는지 이제 `next dev`를 통해서 서버를 한 번 실행시켜봅시다.\r\n\r\n# 첫 실행\r\n\r\n<CodeBlock title=''>\r\n```bash\r\nyarn run dev\r\n```\r\n</CodeBlock>\r\n\r\n<Image src='https://drive.google.com/file/d/1tW2IOONEvuq29exxKPrrwqt8Ped23Wj9/view?usp=drive_link' alt='vscode 상에서의 index.tsx 파일 화면' drive />\r\n\r\n<Image src='https://drive.google.com/file/d/1lKVbUAAqab18mn5y8glIsaxWNrzH0pFa/view?usp=drive_link' alt='홈페이지' drive />\r\n\r\nNextJS는 app 라우트 혹은 pages 라우트를 사용하고 여기서는 pages 라우트를 사용하니까 pages 라우트의 관점에서 보도록 하겠습니다. `pages` 폴더 안의 파일들이 하나 하나의 페이지라고 생각하면 됩니다. `index.tsx` 파일은 NextJS로 만들 사이트의 홈 페이지가 되는 것입니다.\r\n\r\n즉 `index.tsx`의 내용이 `localhost:3000` 페이지에 띄워지는 것이죠. 파일을 보면 아시겠지만 className에 덕지 덕지 붙어있는 게 바로 TailwindCSS의 스타일링 방식 입니다. 이런식으로 스타일링을 하면 편하기야 하겠지만 정말 보기에 안좋죠. 이걸 해소할 수 있는 게 바로 twin.macro인 것입니다.\r\n\r\n# twin.macro 사용해보기\r\ntwin.macro를 사용한다는 것은 사실 별 거 없습니다. 그냥 Emotion이랑 TailwindCSS를 같이 사용하는 것이니까요. 테스트를 위해서 `index.tsx`의 태그들을 전부 밀어버리고 다시 작성해보겠습니다.\r\n\r\n<CodeBlock title='index.tsx'>\r\n```tsx\r\nimport React from 'react';\r\n\r\nexport default function index() {\r\n  return (\r\n    <>\r\n      <div>Hello World!!</div>\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n<Image src='https://drive.google.com/file/d/1l_PnkA-8mcnGgSbZxNfkyo3f-aNLL0qW/view?usp=drive_link' alt='아무런 스타일이 없는 모습' drive />\r\n\r\n이제 새로운 방식으로 스타일링을 진행할 겁니다. **StyledComponents**나 **Emotion**을 사용한 분이라면 아래처럼 스타일링을 하실겁니다. 스타일드 컴포넌트를 만들던가 css 프로퍼티에 스타일을 전달하던가 하는 식으로 말이죠. 이게 바로 **CSS in JS**의 편리한 점이었죠.\r\n\r\n<CodeBlock title='index.tsx'>\r\n```tsx\r\nimport React from 'react';\r\nimport { css, styled } from 'twin.macro';\r\n\r\nconst StyledDiv = styled.div`\r\n  font-family: 'Noto Sans KR', sans-serif;\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  font-size: 2rem;\r\n  color: white;\r\n  background-color: #333333;\r\n  padding: 12px;\r\n`;\r\n\r\nexport default function index() {\r\n  const style = (css`\r\n    font-family: 'Noto Sans KR', sans-serif;\r\n    display: flex;\r\n    align-items: center;\r\n    justify-content: center;\r\n    font-size: 2rem;\r\n    color: white;\r\n    background-color: #333333;\r\n    padding: 12px;\r\n  `);\r\n\r\n  return (\r\n    <>\r\n      <div css={style}>Hello World!!</div>\r\n      <br />\r\n      <StyledDiv>Hello World!!</StyledDiv>\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n<Image src='https://drive.google.com/file/d/1jpwecuQgDKpI_nW9vhbs9m4dERUkkYsY/view?usp=drive_link' alt='emotion의 스타일링 방식' drive />\r\n\r\n좀 더 편리하게 스타일링을 할 수 있습니다. 바로 TailwindCSS를 섞어서 말이죠. twin.macro에는 `tw`라는 함수가 제공되는데 Emotion의 css처럼 사용할 수 있습니다. 여기에는 TailwindCSS의 클래스명들이 들어갑니다. 위와 똑같은 스타일을 만들어봅시다.\r\n\r\n<CodeBlock title='index.tsx'>\r\n```tsx\r\nimport React from 'react';\r\nimport tw from 'twin.macro';\r\n\r\nexport default function index() {\r\n  const style = tw` font-sans flex items-center justify-center text-[2rem] text-white bg-black-base p-3 `;\r\n\r\n  return (\r\n    <>\r\n      <div css={style}>Hello World!!</div>\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n<Image src='https://drive.google.com/file/d/1oEzfWJnYGf1VOA_AqQkUrvxoJw9gwy6M/view?usp=drive_link' alt='twin.macro를 사용하면 지저분한 클래스들을 안봐도 된다' drive />\r\n\r\n이런식으로 사용할 수가 있습니다. 저는 이걸 응용해서 객체 형식으로 스타일을 만듭니다. 그럼 이제 기본적인 기능에 대해서는 알아봤으니까 썸네일 생성기라는 주제에 맞는 개발을 시작해봅시다.\r\n\r\n# 썸네일 생성기 레이아웃 잡기\r\n저번에 만들어놓은 와이어 프레임을 어느정도 참고해서 거창한 스타일은 입히지 않은 상태의 레이아웃만 대충 잡아보도록 합시다. 기능적인 부분은 차차 잡아가기로 하고 일단은 있을 수 있는 부분만 만들어보겠습니다.\r\n\r\n<CodeBlock title='index.tsx'>\r\n```tsx\r\nimport React from 'react';\r\n\r\nexport default function index() {\r\n  return (\r\n    <>\r\n      <div>\r\n        <div />\r\n        <input type='text' id='title' placeholder='제목' />\r\n        <input type='text' id='sub-title' placeholder='부제' />\r\n\r\n        <div>\r\n          <div>단색 배경</div>\r\n          <div>이미지 배경</div>\r\n        </div>\r\n\r\n        <div>\r\n          <input type='range' min={0} max={255} defaultValue={50} id='hex-red' />\r\n          <input type='range' min={0} max={255} defaultValue={50} id='hex-blue' />\r\n          <input type='range' min={0} max={255} defaultValue={50} id='hex-green' />\r\n        </div>\r\n\r\n        <div>\r\n          <input type='text' id='image-src' placeholder='이미지 주소를 입력하세요' />\r\n        </div>\r\n\r\n        <div>\r\n          <button>초기화</button>\r\n          <button>이미지로 저장</button>\r\n        </div>\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n<Image src='https://drive.google.com/file/d/10Z6j06_tjhjeZqyEae0rmuIbL_uJHL2U/view?usp=drive_link' alt='스타일링하기 전의 레이아웃' drive />\r\n\r\n이미지로 변환할 부분과 제목, 부제 입력란들. 배경 설정 등등의 기능을 수행할 수 있는 레이아웃입니다. TailwindCSS 특성상 초기화가 심할 정도로 되어있어서 초기 디자인들이 존재하지 않습니다. 간단하게 디자인을 입혀보도록 합시다.\r\n\r\n<CodeBlock title='index.tsx'>\r\n```tsx\r\nimport React from 'react';\r\nimport tw, { css } from 'twin.macro';\r\n\r\nexport default function index() {\r\n  const style = {\r\n    default: css([\r\n      tw` w-[1280px] mx-auto `,\r\n    ]),\r\n    frame: css([\r\n      tw` box-content border border-black-base aspect-video mb-10 `,\r\n    ]),\r\n    input: css([\r\n      tw` p-2 text-normal text-blue-600 placeholder:text-blue-400 block bg-blue-50 w-full border border-blue-500 `,\r\n    ]),\r\n    colors: tw` flex mt-10 `,\r\n    colorTab: css([\r\n      tw` [&[data-selected=\"true\"]]:( p-3 flex-1 shrink-0 border border-black-300 border-b-0 bg-white text-black-base text-center ) `,\r\n      tw` [&[data-selected=\"false\"]]:( p-3 flex-1 shrink-0 border border-black-300 border-b-0 bg-black-300 text-black-600 text-center ) `,\r\n    ]),\r\n    colorTabBottom: css([\r\n      tw` border border-black-300 border-t-0 p-3 bg-white mb-10 `,\r\n    ]),\r\n    buttons: css([\r\n      tw` flex gap-5 `,\r\n      tw` [button]:( flex-1 shrink-0 bg-blue-400 text-white p-3 hover:( bg-blue-600 ) ) `,\r\n    ]),\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <div css={style.default}>\r\n        <div css={style.frame} />\r\n        <input type='text' id='title' placeholder='제목' css={style.input} />\r\n        <input type='text' id='sub-title' placeholder='부제' css={style.input} />\r\n\r\n        <div css={style.colors}>\r\n          <button css={style.colorTab} data-selected='true'>단색 배경</button>\r\n          <button css={style.colorTab} data-selected='false'>이미지 배경</button>\r\n        </div>\r\n\r\n        <div css={style.colorTabBottom}>\r\n          <input type='range' min={0} max={255} defaultValue={50} id='hex-red' />\r\n          <input type='range' min={0} max={255} defaultValue={50} id='hex-blue' />\r\n          <input type='range' min={0} max={255} defaultValue={50} id='hex-green' />\r\n        </div>\r\n\r\n        <div css={style.colorTabBottom}>\r\n          <input type='text' id='image-src' placeholder='이미지 주소를 입력하세요' css={style.input} />\r\n        </div>\r\n\r\n        <div css={style.buttons}>\r\n          <button>초기화</button>\r\n          <button>이미지로 저장</button>\r\n        </div>\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n<Image src='https://drive.google.com/file/d/1nd5It5wng6RPBqBhtOgqzFLYHL78IQgs/view?usp=drive_link' alt='대충 스타일링한 상태의 레이아웃' drive />\r\n\r\n대충 꾸민 것이지만 이제부터 디테일을 높이고 기능을 채워가면 됩니다. 이제 이 화면을 점점 발전시켜나갈 겁니다. 코드 설명을 하고 이것 저것 하느라 글이 많이 길어졌네요 여기서 끊고 다음 글부터 계속 이어서 진행하도록 하겠습니다.\r\n"},{"id":4,"content":"\r\n# 개요\r\n이번 글에서는 썸네일에 들어갈 텍스트를 구현할겁니다. 사용자가 제목과 부제를 입력하면 혹은 제목만 입력을 하면 입력한 내용이 썸네일에 적용되게끔 만드는 것이죠.\r\n\r\n그럼 바로 시작해보도록 합시다.\r\n\r\n# 텍스트 입력 구현\r\n그 전에 지금까지 진행한 부분에 대해서 간략하게 넘어가도록 하겠습니다. 코드는 길기때문에 접어두도록 하겠습니다. 보고 싶으면 펼쳐서 보시면 됩니다.\r\n\r\n<CodeBlock title='index.tsx' fold>\r\n```jsx\r\nimport React from 'react';\r\nimport tw, { css } from 'twin.macro';\r\n\r\nexport default function index() {\r\n  const style = {\r\n    default: css([\r\n      tw` w-[1280px] mx-auto `,\r\n    ]),\r\n    frame: css([\r\n      tw` box-content border border-black-base aspect-video mb-10 `,\r\n    ]),\r\n    input: css([\r\n      tw` p-2 text-normal text-blue-600 placeholder:text-blue-400 block bg-blue-50 w-full border border-blue-500 `,\r\n    ]),\r\n    colors: tw` flex mt-10 `,\r\n    colorTab: css([\r\n      tw` [&[data-selected=\"true\"]]:( p-3 flex-1 shrink-0 border border-black-300 border-b-0 bg-white text-black-base text-center ) `,\r\n      tw` [&[data-selected=\"false\"]]:( p-3 flex-1 shrink-0 border border-black-300 border-b-0 bg-black-300 text-black-600 text-center ) `,\r\n    ]),\r\n    colorTabBottom: css([\r\n      tw` border border-black-300 border-t-0 p-3 bg-white mb-10 `,\r\n    ]),\r\n    buttons: css([\r\n      tw` flex gap-5 `,\r\n      tw` [button]:( flex-1 shrink-0 bg-blue-400 text-white p-3 hover:( bg-blue-600 ) ) `,\r\n    ]),\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <div css={style.default}>\r\n        <div css={style.frame} />\r\n        <input type='text' id='title' placeholder='제목' css={style.input} />\r\n        <input type='text' id='sub-title' placeholder='부제' css={style.input} />\r\n\r\n        <div css={style.colors}>\r\n          <button css={style.colorTab} data-selected='true'>단색 배경</button>\r\n          <button css={style.colorTab} data-selected='false'>이미지 배경</button>\r\n        </div>\r\n\r\n        <div css={style.colorTabBottom}>\r\n          <input type='range' min={0} max={255} defaultValue={50} id='hex-red' />\r\n          <input type='range' min={0} max={255} defaultValue={50} id='hex-blue' />\r\n          <input type='range' min={0} max={255} defaultValue={50} id='hex-green' />\r\n        </div>\r\n\r\n        <div css={style.colorTabBottom}>\r\n          <input type='text' id='image-src' placeholder='이미지 주소를 입력하세요' css={style.input} />\r\n        </div>\r\n\r\n        <div css={style.buttons}>\r\n          <button>초기화</button>\r\n          <button>이미지로 저장</button>\r\n        </div>\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n<Image src='https://drive.google.com/file/d/1nd5It5wng6RPBqBhtOgqzFLYHL78IQgs/view?usp=drive_link' alt='대충 스타일링한 상태의 레이아웃' drive />\r\n\r\n각 부분을 대충 만들어두고 마쳤었는데요. 이번 글부터 보완을 하면서 진행할겁니다. 디자인도 조금씩 개선을 하고 기능을 붙여 나갈거에요. 일단 첫번째 파트에서 우리가 주목할 부분은 썸네일이 위치할 `div`와 두개의 텍스트입니다. 그럼 진행해보도록 합시다.\r\n\r\n## `input` 컨트롤하기\r\n저는 `input`을 컨트롤 하기 위해서 **react-form-hook**을 사용할까 생각도 했었는데 그냥 순수하게 구현을 해보려고 합니다. `input`을 컨트롤 하는 이유는 `input`의 `value`를 **state**로 관리를 해야하기 때문입니다. 리액트에서는 그런식으로  관리를 해야합니다.\r\n\r\n<CodeBlock title='index.tsx'>\r\n```tsx {1-17, 29-30, 37-38}\r\nexport default function IndexPage() {\r\n  const [ title, setTitle, ] = useState('제목을 입력하세요.');\r\n  const [ subTitle, setSubTitle, ] = useState('부제');\r\n\r\n  const onChangeTitle = useCallback(\r\n    (event: ChangeEvent<HTMLInputElement>) => {\r\n      setTitle(event.target.value);\r\n    },\r\n    []\r\n  );\r\n\r\n  const onChangeSubTitle = useCallback(\r\n    (event: ChangeEvent<HTMLInputElement>) => {\r\n      setSubTitle(event.target.value);\r\n    },\r\n    []\r\n  );\r\n\r\n  // ...\r\n\r\n  return (\r\n    <>\r\n      <div css={style.default}>\r\n        {/* ... */}\r\n        <input\r\n          type='text'\r\n          id='title'\r\n          placeholder='제목'\r\n          value={title}\r\n          onChange={onChangeTitle}\r\n          css={style.input}\r\n        />\r\n        <input\r\n          type='text'\r\n          id='sub-title'\r\n          placeholder='부제'\r\n          value={subTitle}\r\n          onChange={onChangeSubTitle}\r\n          css={style.input}\r\n        />\r\n        {/* ... */}\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n<Image src='https://drive.google.com/file/d/1FBcryAEwNd5Cc398JRsWX908JjKwFCkP/view?usp=drive_link' alt='데이터 바인딩이 완료된 상태' drive />\r\n\r\n리액트에서 `input.value`의 변경은 `onChange` 이벤트로 진행합니다. `input`이 두개니까 `useState`를 두개 사용해서 각각 제목과 부제를 저장하도록 세팅해두었습니다. 기본값도 부여한 상태입니다. 아무래도 텍스트가 비어있으면 테스트를 할 때 매번 입력하는 게 귀찮을테니까요.\r\n\r\n위에서 설정을 한 다음에는 `input` 태그에 연결을 해줘야합니다. 29번 30번에는 `title` 값을 저장합니다. 37번 38번은 `subTitle` 값을 저장합니다. 이렇게 하면 텍스트가 입력될 때 값도 함께 저장이 됩니다. 이 저장된 값을 이용해서 썸네일 부분에 출력 해보도록 합시다. 아주 간단합니다.\r\n\r\n<CodeBlock title='index.tsx'>\r\n```tsx {6-11}\r\nexport default function IndexPage() {\r\n  // ...\r\n  return (\r\n    <>\r\n      <div css={style.default}>\r\n        <div css={style.frame}>\r\n          <div>\r\n            <h1>{title}</h1>\r\n            <h2>{subTitle}</h2>\r\n          </div>\r\n        </div>\r\n\r\n        {/* ... */}\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n<Image src='https://drive.google.com/file/d/19pT6P5q_KAAJUeRaUP4e_zZoh_0_jDfa/view?usp=drive_link' alt='썸네일 부분에 바인딩이 된 모습' drive />\r\n\r\n이렇게만 해주면 알아서 바인딩이 된 상태로 출력이 되겠죠. 이제 이 텍스트들의 위치를 조정할 필요가 있습니다. 일단 스타일만 주었기 때문에 이름을 좀 붙여보겠습니다.\r\n\r\n## 썸네일의 텍스트 스타일 설정하기\r\n\r\n<CodeBlock title='index.tsx'>\r\n```tsx {6-8, 14-19}\r\nexport default function IndexPage() {\r\n  // ...\r\n\r\n  const style = {\r\n    // ...\r\n    frame: css([\r\n      tw` box-content border border-black-base aspect-video mb-10 relative `,\r\n    ]),\r\n    // ...\r\n  };\r\n  return (\r\n    <>\r\n      <div css={style.default}>\r\n        <div id='th-frame' css={style.frame}>\r\n          <div id='th-titles'>\r\n            <h1 id='th-title'>{title}</h1>\r\n            <h2 id='th-sub-title'>{subTitle}</h2>\r\n          </div>\r\n        </div>\r\n\r\n        {/* ... */}\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n썸네일 전체가 될 부분을 `th-frame` 라고 부르겠습니다. 제목은 보이는대로 `th-title`, 부제는 `th-sub-title` 가 되겠죠. `th-titles` 는 제목과 부제 두 요소의 위치를 잡기 위한 컨테이너입니다.\r\n\r\n7번을 보면 `th-frame` 에 포지션 스타일을 추가로 지정했습니다. 이녀석의 자식 노드들은 원하는대로 배치될 수 있어야 하기 때문이죠. 이제 각 노드에 스타일을 입히면 됩니다. 먼저 `th-titles` 에다가 스타일을 입혀서 썸네일의 가운데로 몰아보도록 합시다.\r\n\r\n<CodeBlock title='index.tsx'>\r\n```tsx {9-11, 17-22}\r\nexport default function IndexPage() {\r\n  // ...\r\n\r\n  const style = {\r\n    // ...\r\n    frame: css([\r\n      tw` box-content border border-black-base aspect-video mb-10 relative `,\r\n    ]),\r\n    titles: css([\r\n      tw` absolute top-[50%] translate-y-[-50%] left-[50%] translate-x-[-50%] text-center w-full `,\r\n    ]),\r\n    // ...\r\n  };\r\n  return (\r\n    <>\r\n      <div css={style.default}>\r\n        <div id='th-frame' css={style.frame}>\r\n          <div id='th-titles' css={style.titles}>\r\n            <h1 id='th-title'>{title}</h1>\r\n            <h2 id='th-sub-title'>{subTitle}</h2>\r\n          </div>\r\n        </div>\r\n\r\n        {/* ... */}\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n<Image src='https://drive.google.com/file/d/1HGm7zLCfuSdwOpp2e0fNeCDw72LyVLNQ/view?usp=drive_link' alt='텍스트가 가운데로 몰려진 모습' drive />\r\n\r\n텍스트는 이제 대략적인 준비는 끝났습니다. 나머지 스타일링을 하고 제목에 줄바꿈 처리도 한 번 해보도록 합시다. 줄바꿈을 하려면 사용자가 입력한 **\\\\n** 를 감지해서 줄을 바꿔주면 됩니다.\r\n\r\n<CodeBlock title='index.tsx'>\r\n```tsx {6-11, 17-26}\r\nexport default function IndexPage() {\r\n  // ...\r\n\r\n  const style = {\r\n    // ...\r\n    title: css([\r\n      tw` text-[4rem] font-black whitespace-pre-line `,\r\n    ]),\r\n    subTitle: css([\r\n      tw` text-[3rem] font-semibold `,\r\n    ]),\r\n    // ...\r\n  };\r\n  return (\r\n    <>\r\n      <div css={style.default}>\r\n        <div id='th-frame' css={style.frame}>\r\n          <div id='th-titles' css={style.titles}>\r\n            <h1 id='th-title' css={style.title}>\r\n              {title.split('\\\\n').map((item) => (\r\n                <>{item}<br /></>\r\n              ))}\r\n            </h1>\r\n            <h2 id='th-sub-title' css={style.subTitle}>{subTitle}</h2>\r\n          </div>\r\n        </div>\r\n\r\n        {/* ... */}\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n제목을 입력하는 `input` 태그에서 `title` 이라는 `state` 에 값을 저장한 상태에서 출력을 하는 것 까지는 좋은데 제목이 길어지거나 그럴 때를 대비해서 줄바꿈 기능을 넣었습니다. 20번 ~ 22번 라인입니다. `title` 을 **\\\\n**을 기준으로 쪼개서 `br` 태그를 넣어 줄바꿈이 되도록 만들었습니다.\r\n\r\n이 결과가 바로 이것입니다. 사용자는 그저 제목에 **\\\\n**을 넣어서 입력하기만 하면 됩니다.\r\n\r\n<Image src='https://drive.google.com/file/d/1VnThwzG2OO1IiYA27g9Tf5l4c2mA1Mem/view?usp=drive_link' alt='텍스트 줄바꿈 적용한 모습' drive />\r\n\r\n## 텍스트 입력 스타일 재정비하기\r\n\r\n이제 텍스트 입력하는 부분을 좀 더 다듬어야겠습니다. 입력란에 라벨도 만들어주고 개선을 해봅시다. 디자인에 조예가 있는 편은 아니라서 그냥 그럴듯하게만 만든 결과는 아래와 같습니다.\r\n\r\n<CodeBlock title='index.tsx'>\r\n```tsx\r\nexport default function IndexPage() {\r\n  // ...\r\n\r\n  return (\r\n    <>\r\n      <div css={style.default}>\r\n        <div id='th-frame' css={style.frame}>\r\n          {/* ... */}\r\n        </div>\r\n\r\n        <div css={style.inputs}>\r\n          <label htmlFor='title' css={style.input}>\r\n            <span>제목</span>\r\n            <input\r\n              type='text'\r\n              id='title'\r\n              placeholder='제목'\r\n              value={title}\r\n              onChange={onChangeTitle}\r\n            />\r\n          </label>\r\n          <label htmlFor='sub-title' css={style.input}>\r\n            <span>부제</span>\r\n            <input\r\n              type='text'\r\n              id='sub-title'\r\n              placeholder='부제'\r\n              value={subTitle}\r\n              onChange={onChangeSubTitle}\r\n            />\r\n          </label>\r\n        </div>\r\n\r\n        {/* ... */}\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n<Image src='https://drive.google.com/file/d/1wjAWlfqIy0gm3ybSQNqH24U4mWcjoxrb/view?usp=drive_link' alt='스타일 디자인 개선 결과' drive />\r\n\r\n입력란의 스타일을 확 바꿔서 포커싱이 되면 파란색 테두리가 아래에 나타나게끔 개선했습니다. 나중에 텍스트 쪽에도 배티할 요소가 많아지거나 하면 텍스트와 배경 부분을 따로 펼치고 접을 수 있게끔 만들어야겠다는 생각이 들었습니다.\r\n\r\n# 마치며\r\n\r\n이렇게 해서 이번 글의 목표를 마쳤습니다. 사실 내용은 별 게 아닌데 글이 너무 길어지는 것 같아서 쪼개는 중입니다. 다음 글에서는 배경을 적용해볼 겁니다. 색상을 선택하게 해서 설정을 하면 그대로 적용이 되게 만들 것인데 이 과정에서 필요하다면 텍스트 색상도 바꿀 수 있게끔 개선을 해보려고 합니다.\r\n\r\n작은 토이 프로젝트지만 할 게 많은 것 같은 느낌입니다. 역시 천천히 진행해서 그런 것이겠죠. 언제 완성할 수 있을지조차 가늠이 안가네요. 그럼 다음 글로 찾아오도록 하겠습니다.\r\n"},{"id":5,"content":"\r\n# 개요\r\n배경 관련 작업을 하려고 조금씩 살펴보다가 문득 떠오른 게 있었습니다. 이제 슬슬 컴포넌트들을 쪼개서 관리를 해야하는데 이럴 경우에 스테이트도 그에 맞게 관리를 해야한다는 것이었죠. 하지만 제가 정한 이 프로젝트의 컴포넌트 분할 계획은 두개의 컴포넌트에서 만들어지는 스테이트를 하나의 컴포넌트에서 활용하는 구조였습니다.\r\n\r\n컴포넌트와 컴포넌트가 부모 형제 사이가 아니기 때문에 스테이트를 전달할 방법이 없었다는 것이죠. 그래서 결론은 리덕스의 도입이었습니다. 리덕스 툴킷을 이용해서 중앙 저장소를 만들고 컴포넌트를 분할하는 것을 이 글에서 다루려고 합니다. 그럼 시작해봅시다.\r\n\r\n# 리덕스 환경 설정\r\n먼저 리덕스 환경을 구성하는 것부터 진행해보도록 합시다. 관련 패키지를 설치하고, 리듀서를 구성하고, 중앙 저장소인 스토어까지 만드는 과정을 간략하게 보여드리려고 합니다. 일단 리덕스가 필요한 이유는 위에서도 짧게 언급했는데, 컴포넌트가 분산되어 있어서 프롭스를 통해서 스테이트를 전달받을 수가 없습니다.\r\n\r\n리액트에서는 부모에서 자식에게 자산을 물려주는 식으로 프롭스를 전달하는데 이 프로젝트는 같은 계층의 컴포넌트끼리 스테이트를 사용해야하기 때문에 프롭스를 이용하는 것은 불가능하기 때문에 리덕스를 사용하는 것입니다. 리덕스는 중앙 저장소를 통해서 데이터를 관리하고 프롭스로의 스테이트 전달이 아닌 곧바로 중앙 저장소에서 호출하는 시스템이기 때문에 현재 프로젝트의 구조와 알맞습니다.\r\n\r\n<Image src='https://i.ibb.co/xCpxrC4/image.png' alt='리덕스를 사용하는 이유' />\r\n\r\n리덕스가 무엇인지 자체에 대해 설명하는 것은 여기서 다룰 내용은 아닌 것 같으니 이미지로 설명을 대체하고 이제 리덕스 사용 환경을 구축해보도록 합시다.\r\n\r\n## 리덕스 관련 패키지 설치\r\n\r\n<CodeBlock title=''>\r\n```bash\r\nyarn add @reduxjs/toolkit react-redux redux redux-persist\r\n```\r\n</CodeBlock>\r\n\r\n우선 관련 패키지를 설치해야합니다. 이 글에서는 리덕스 툴킷을 사용할 것이기 때문에 툴킷은 필수적으로 설치를 해줍니다. **redux-persist** 같은 경우에는 리덕스를 사용하면 스테이트의 값을 로컬스토리지에 저장해주는 기능을 합니다. 새로고침을 해도 그 데이터가 남아있는 것이죠.\r\n\r\n데이터를 저장은 해야 하는데 데이터베이스에 저장하기엔 뭐한 데이터의 경우에는 이걸 사용하는 편입니다. 설치를 진행하고나서 이제 리듀서를 만들어야합니다.\r\n\r\n<Image src='https://drive.google.com/file/d/1j_Tze5nEXReXvBQzR1SPGCRBLlULGw82/view?usp=drive_link' alt='리덕스 폴더 구조' drive />\r\n\r\n폴더 구조를 이렇게 해두었습니다. `src` 폴더 안에 `redux` 폴더를 만들고 그 안에 스토어와 리듀서를 둘 겁니다.\r\n\r\n## 리듀서 생성\r\n리듀서는 각각의 스테이트를 갖습니다. 그래서 기능에 따라 여러개의 리듀서를 만들고 리듀서별로 스테이트를 저장하고 관리할 수 있는 게 리덕스의 큰 특징입니다. 하지만 이 프로젝트는 큰 편은 아니고 하나의 리듀서만 있으면 될 것 같아서 하나의 리듀서만 만들어볼 것입니다.\r\n\r\n`app.reducer.ts` 파일을 열고 작성을 시작합니다.\r\n\r\n<CodeBlock title='app.reducer.ts'>\r\n```ts\r\nimport { PayloadAction, createSlice } from '@reduxjs/toolkit';\r\n\r\ntype AppState = {\r\n  bgType: ('color' | 'image');\r\n  title: string;\r\n  subTitle: string;\r\n  textColor: string;\r\n  bgColor: string;\r\n  imgSrc: string;\r\n}\r\n\r\nconst initialState: AppState = {\r\n  bgType: 'color',\r\n  title: '제목을 입력하세요',\r\n  subTitle: '',\r\n  textColor: '#ffffff',\r\n  bgColor: '#333333',\r\n  imgSrc: '',\r\n};\r\n\r\nconst appReducer = createSlice({\r\n  name: 'app',\r\n  initialState,\r\n  reducers: {\r\n    initState(state) {\r\n      state.bgType = 'color';\r\n      state.title = '제목을 입력하세요';\r\n      state.subTitle = '';\r\n      state.textColor = '#ffffff';\r\n      state.bgColor = '#333333';\r\n      state.imgSrc = '';\r\n    },\r\n    setBgType(\r\n      state,\r\n      { payload, }: PayloadAction<{value: ('color' | 'image')}>\r\n    ) {\r\n      state.bgType = payload.value;\r\n    },\r\n    setTitle(\r\n      state,\r\n      { payload, }: PayloadAction<{value: string}>\r\n    ) {\r\n      state.title = payload.value;\r\n    },\r\n    setSubTitle(\r\n      state,\r\n      { payload, }: PayloadAction<{value: string}>\r\n    ) {\r\n      state.subTitle = payload.value;\r\n    },\r\n    setTextColor(\r\n      state,\r\n      { payload, }: PayloadAction<{value: string}>\r\n    ) {\r\n      state.textColor = payload.value;\r\n    },\r\n    setBgColor(\r\n      state,\r\n      { payload, }: PayloadAction<{value: string}>\r\n    ) {\r\n      state.bgColor = payload.value;\r\n    },\r\n    setImg(\r\n      state,\r\n      { payload, }: PayloadAction<{value: string}>\r\n    ) {\r\n      state.imgSrc = payload.value;\r\n    },\r\n  },\r\n});\r\n\r\nexport const {\r\n  initState, setBgType, setTitle, setSubTitle, setTextColor, setBgColor, setImg,\r\n} = appReducer.actions;\r\nexport default appReducer.reducer;\r\n```\r\n</CodeBlock>\r\n\r\n리듀서는 이름, 스테이트 기본값, 액션으로 이루어져 있습니다. 리덕스 툴킷에서는 `createSlice` 함수를 이용해서 리듀서를 만듭니다. `initialState` 에는 여섯개의 스테이트를 만들어놨습니다. 제목과 부제, 배경 타입, 배경 색상, 이미지 주소, 텍스트 색상입니다. 나중에 더 늘어날 수도 있는데 일단은 이렇게만 만들어놨습니다.\r\n\r\n액션은 기본 스테이트로 돌려주는 액션 하나와 각 스테이트에 대응하는 액션 하나씩 해서 총 7개의 액션이 있습니다. 역시나 더 늘어날 수도 있습니다. 지금 당장에는 이렇게만 있으면 될 것 같네요.\r\n\r\n이렇게 만들어준 다음에는 `appReducer.actions` 에서 액션들을 분리시켜서 `export` 시켜주고 `appReducer.reducer` 도 `export` 시켜주면 됩니다.\r\n\r\n## 중앙 저장소 생성\r\n그 다음에는 **store**를 만들어야 합니다. 이 store에 **redux-persist**도 적용 할 겁니다. `store.ts` 파일을 열어서 작업을 시작합니다.\r\n\r\n<CodeBlock title='store.ts'>\r\n```ts\r\nimport { combineReducers, configureStore } from '@reduxjs/toolkit';\r\nimport { persistReducer } from 'redux-persist';\r\nimport createWebStorage from 'redux-persist/lib/storage/createWebStorage';\r\nimport appReducer from './app.reducer';\r\n\r\nconst createNoopStorage = () => {\r\n  return {\r\n    // eslint-disable-next-line no-unused-vars\r\n    getItem(_key: any) {\r\n      return Promise.resolve(null);\r\n    },\r\n    setItem(_key: any, value: any) {\r\n      return Promise.resolve(value);\r\n    },\r\n    // eslint-disable-next-line no-unused-vars\r\n    removeItem(_key: any) {\r\n      return Promise.resolve();\r\n    },\r\n  };\r\n};\r\n\r\nconst storage = typeof window === 'undefined'\r\n  ? createNoopStorage()\r\n  : createWebStorage('local');\r\n\r\nconst reducers = combineReducers({\r\n  app: appReducer,\r\n});\r\n\r\nconst persistedReducer = persistReducer({\r\n  key: 'root',\r\n  storage,\r\n  whitelist: [ 'app', ],\r\n}, reducers);\r\n\r\nexport const store = configureStore({\r\n  reducer: persistedReducer,\r\n  middleware: [],\r\n});\r\n\r\nexport type RootState = ReturnType<typeof store.getState>;\r\nexport type AppDispatch = typeof store.dispatch;\r\n```\r\n</CodeBlock>\r\n\r\n스토어는 이렇게 만들면 되는데 간단하게 코드를 살펴보도록 하겠습니다.\r\n\r\n<CodeBlock title=''>\r\n```ts\r\nconst reducers = combineReducers({\r\n  app: appReducer,\r\n});\r\n```\r\n</CodeBlock>\r\n\r\n먼저 `combineReducers` 함수를 이용해서 리듀서들을 하나로 합쳐주는 작업을 진행합니다. 리듀서가 여러개일 때에 사용하는 방법인데 굳이 하나임에도 이렇게 하는 이유는 리듀서가 추가될 수도 있기 때문입니다. 만일을 대비해서 미리 이렇게 만들어둔 것이죠.\r\n\r\n이렇게 만들어진 `reducers` 를 아래에서 사용합니다.\r\n\r\n<CodeBlock title=''>\r\n```ts\r\nconst storage = typeof window === 'undefined'\r\n  ? createNoopStorage()\r\n  : createWebStorage('local');\r\n\r\nconst persistedReducer = persistReducer({\r\n  key: 'root',\r\n  storage,\r\n  whitelist: [ 'app', ],\r\n}, reducers);\r\n\r\nexport const store = configureStore({\r\n  reducer: persistedReducer,\r\n  middleware: [],\r\n});\r\n```\r\n</CodeBlock>\r\n\r\n`persistReducer` 함수는 어떤 리듀서를 로컬스토리지에 저장해서 관리할 것인가를 포함하는 데이터를 명시하는 역할을 합니다. 이런식으로 작성을 하면 되고 `configureStore` 함수를 통해서 스토어를 생성합니다.\r\n\r\n`createNoopStorage` 함수의 경우에는 **redux-persist** 가 제역할을 못하는 경우가 있어서 구글링을 통해서 발견한 해결책으로 나온 함수입니다.\r\n\r\n<CodeBlock title=''>\r\n```ts\r\nconst createNoopStorage = () => {\r\n  return {\r\n    // eslint-disable-next-line no-unused-vars\r\n    getItem(_key: any) {\r\n      return Promise.resolve(null);\r\n    },\r\n    setItem(_key: any, value: any) {\r\n      return Promise.resolve(value);\r\n    },\r\n    // eslint-disable-next-line no-unused-vars\r\n    removeItem(_key: any) {\r\n      return Promise.resolve();\r\n    },\r\n  };\r\n};\r\n```\r\n</CodeBlock>\r\n\r\n이렇게까지 하면 이제 만들어진 스토어와 함께 타입을 내보내기만 하면 됩니다.\r\n\r\n<CodeBlock title=''>\r\n```ts\r\nexport type RootState = ReturnType<typeof store.getState>;\r\nexport type AppDispatch = typeof store.dispatch;\r\n```\r\n</CodeBlock>\r\n\r\n리듀서에서 만든 액션들을 사용(dispatch)하기 위해서 필요한 `AppDispatch` 타입과 중앙 저장소에서 데이터를 가져올 때 필요한 `RootState` 타입을 내보내줍니다. 이제 마지막으로 커스텀 훅을 만들어서 스테이트와 액션을 편하게 사용할 수 있도록 준비해두는 일만 남았습니다.\r\n\r\n## 커스텀 훅 만들기\r\n\r\n<Image src='https://drive.google.com/file/d/1lxjgmOo2mCcQmHnIaF00qVbPEsT-0PKB/view?usp=drive_link' alt='커스텀 훅 폴더 구성' drive />\r\n\r\n먼저 폴더와 파일을 이렇게 만들어줍니다.\r\n\r\n`rtk.ts` 파일을 열고 아래의 내용을 작성합니다.\r\n\r\n<CodeBlock title='rtk.ts'>\r\n```ts\r\nimport { useDispatch, useSelector } from 'react-redux';\r\nimport type { TypedUseSelectorHook } from 'react-redux';\r\nimport { AppDispatch, RootState } from '@/redux';\r\n\r\nexport const useAppDispatch: () => AppDispatch = useDispatch;\r\nexport const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;\r\n```\r\n</CodeBlock>\r\n\r\n이제는 액션을 사용할 때 `useAppDispatch` 훅으로 사용하면 되고 스테이트를 가져올 때에는 `useAppSelector` 훅으로 가져오면 됩니다.\r\n\r\n## 마지막, Provider 설정하기\r\n\r\n마지막 작업을 위해서는 `pages` 폴더의 `_app.tsx` 파일을 열어서 수정 해야합니다.\r\n\r\n<CodeBlock title='_app.tsx'>\r\n```tsx\r\nimport React from 'react';\r\nimport Head from 'next/head';\r\nimport { AppProps } from 'next/app';\r\nimport { Provider } from 'react-redux';\r\nimport { PersistGate } from 'redux-persist/integration/react';\r\nimport { persistStore } from 'redux-persist';\r\nimport { store } from '@/redux';\r\nimport '@/styles/global.css';\r\n\r\nexport const persistor = persistStore(store);\r\n\r\nconst App = ({ Component, pageProps, }: AppProps) => (\r\n  <Provider store={store}>\r\n    <PersistGate loading={null} persistor={persistor}>\r\n      <Head>\r\n        <meta charSet='UTF-8' />\r\n        <meta httpEquiv='X-UA-Compatible' content='ie=edge' />\r\n        <meta\r\n          name='viewport'\r\n          content='width=device-width, initial-scale=1.0'\r\n        />\r\n      </Head>\r\n      <Component {...pageProps} />\r\n    </PersistGate>\r\n  </Provider>\r\n);\r\n\r\nexport default App;\r\n```\r\n</CodeBlock>\r\n\r\n`Provider` 로 기존의 내용물을 감싸주고, `store` 를 전달해줍니다. 그 안에서는 `persistStore` 함수에 인자로 `store` 를 넘겨주고 얻은 `persistor` 를 `PersistGate` 에 전달해주면 됩니다. 코드상에서 보이는대로 설정하면 모든 준비는 끝난겁니다. 이제 컴포넌트 분할하러 가봅시다.\r\n\r\n# 컴포넌트 분할의 이유\r\n컴포넌트를 분할하는 이유는 하나의 컴포넌트에서 여러가지의 일을 처리하면 혼선이 올 수도 있고 보기에도 좋지 않기 때문도 있고 가장 큰 건 재사용성이지만 굳이 재사용성이 아니더라도 컴포넌트를 분리하는 것을 통해서 그 부분만 신경쓰고 관리할 수 있기 때문에 가독성도 좋아지고 편의성이 향상되기 때문인 듯합니다.\r\n\r\n그래서 이 프로젝트는 세개의 컴포넌트를 추가로 만들어서 그 안에 각각의 내용을 채워넣도록 할 겁니다. 썸네일이 될 화면을 분리하고, 텍스트 설정 부분을 분리하고, 배경 설정 부분을 분리하면 될 것 같습니다.\r\n\r\n시작하기 전에 기존의 `index.tsx` 를 보고 시작하도록 하겠습니다. 코드는 접힌 상태이므로 버튼을 클릭해서 펼쳐서 보시면 됩니다.\r\n\r\n<CodeBlock title='index.tsx' fold>\r\n```tsx\r\nimport React, {\r\n  ChangeEvent, useCallback, useState\r\n} from 'react';\r\nimport tw, { css } from 'twin.macro';\r\n\r\nexport default function IndexPage() {\r\n  const [ title, setTitle, ] = useState('제목을 입력하세요.');\r\n  const [ subTitle, setSubTitle, ] = useState('부제');\r\n\r\n  const onChangeTitle = useCallback(\r\n    (event: ChangeEvent<HTMLInputElement>) => {\r\n      setTitle(event.target.value);\r\n    },\r\n    []\r\n  );\r\n\r\n  const onChangeSubTitle = useCallback(\r\n    (event: ChangeEvent<HTMLInputElement>) => {\r\n      setSubTitle(event.target.value);\r\n    },\r\n    []\r\n  );\r\n\r\n  const style = {\r\n    default: css([\r\n      tw` w-[1280px] mx-auto `,\r\n    ]),\r\n    frame: css([\r\n      tw` box-content border border-black-base aspect-video mb-10 relative `,\r\n    ]),\r\n    inputs: css([\r\n      tw` space-y-2 `,\r\n    ]),\r\n    input: css([\r\n      tw` flex flex-col gap-1 `,\r\n      tw` [span]:( font-semibold text-normal text-black-base ) `,\r\n      tw` [input]:( p-2 outline-none text-normal bg-black-100 text-black-base placeholder:text-black-300 border-b-[2px] border-transparent transition-colors duration-200 ) `,\r\n      tw` [input]:( focus:( border-blue-500 ) ) `,\r\n    ]),\r\n    colors: tw` flex mt-10 `,\r\n    colorTab: css([\r\n      tw` [&[data-selected=\"true\"]]:( p-3 flex-1 shrink-0 border border-black-300 border-b-0 bg-white text-black-base text-center ) `,\r\n      tw` [&[data-selected=\"false\"]]:( p-3 flex-1 shrink-0 border border-black-300 border-b-0 bg-black-300 text-black-600 text-center ) `,\r\n    ]),\r\n    colorTabBottom: css([\r\n      tw` border border-black-300 border-t-0 p-3 bg-white mb-10 `,\r\n    ]),\r\n    buttons: css([\r\n      tw` flex gap-5 `,\r\n      tw` [button]:( flex-1 shrink-0 bg-blue-400 text-white p-3 hover:( bg-blue-600 ) ) `,\r\n    ]),\r\n    titles: css([\r\n      tw` absolute top-[50%] translate-y-[-50%] left-[50%] translate-x-[-50%] text-center w-full `,\r\n    ]),\r\n    title: css([\r\n      tw` text-[4rem] font-black whitespace-pre-line `,\r\n    ]),\r\n    subTitle: css([\r\n      tw` text-[3rem] font-semibold `,\r\n    ]),\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <div css={style.default}>\r\n        <div id='th-frame' css={style.frame}>\r\n          <div id='th-titles' css={style.titles}>\r\n            <h1 id='th-title' css={style.title}>\r\n              {title.split('\\\\n').map((item, index) => (\r\n                // eslint-disable-next-line react/no-array-index-key\r\n                <React.Fragment key={`${item}-${index}`}>{item}<br /></React.Fragment>\r\n              ))}\r\n            </h1>\r\n            <h2 id='th-sub-title' css={style.subTitle}>{subTitle}</h2>\r\n          </div>\r\n        </div>\r\n\r\n        <div css={style.inputs}>\r\n          <label htmlFor='title' css={style.input}>\r\n            <span>제목</span>\r\n            <input\r\n              type='text'\r\n              id='title'\r\n              placeholder='제목'\r\n              value={title}\r\n              onChange={onChangeTitle}\r\n            />\r\n          </label>\r\n          <label htmlFor='sub-title' css={style.input}>\r\n            <span>부제</span>\r\n            <input\r\n              type='text'\r\n              id='sub-title'\r\n              placeholder='부제'\r\n              value={subTitle}\r\n              onChange={onChangeSubTitle}\r\n            />\r\n          </label>\r\n        </div>\r\n\r\n        <div css={style.colors}>\r\n          <button css={style.colorTab} data-type='color'>단색 배경</button>\r\n          <button css={style.colorTab} data-type='image'>이미지 배경</button>\r\n        </div>\r\n\r\n        <div css={style.colorTabBottom}>\r\n          <input type='range' min={0} max={255} defaultValue={50} id='hex-red' />\r\n          <input type='range' min={0} max={255} defaultValue={50} id='hex-blue' />\r\n          <input type='range' min={0} max={255} defaultValue={50} id='hex-green' />\r\n        </div>\r\n\r\n        <div css={style.colorTabBottom}>\r\n          <input type='text' id='image-src' placeholder='이미지 주소를 입력하세요' css={style.input} />\r\n        </div>\r\n\r\n        <div css={style.buttons}>\r\n          <button>초기화</button>\r\n          <button>이미지로 저장</button>\r\n        </div>\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n## 썸네일 부분 분리하기 => Thumbnail\r\n\r\n<Image src='https://drive.google.com/file/d/14bTfA-2J5hpuZgSA7xbM4g3UB9xN21vH/view?usp=drive_link' alt='컴포넌트 폴더 구조' drive />\r\n\r\n`components` 폴더를 만들고 그 안에 세개의 파일을 만들겁니다. `Thumbnail.tsx`, `TextConfig.tsx`, `BackgroundConfig.tsx` 입니다. 이 세가지의 파일이 각각 썸네일, 텍스트 설정, 배경 설정 부분이 될 겁니다.\r\n\r\n<CodeBlock title='Thumbnail.tsx'>\r\n```tsx\r\nimport React from 'react';\r\nimport tw, { css } from 'twin.macro';\r\nimport { useAppSelector } from '@/hooks/rtk';\r\n\r\nexport function Thumbnail() {\r\n  const { title, subTitle, } = useAppSelector((state) => state.app);\r\n\r\n  const style = {\r\n    frame: css([\r\n      tw` box-content border border-black-base aspect-video mb-10 relative `,\r\n    ]),\r\n    titles: css([\r\n      tw` absolute top-[50%] translate-y-[-50%] left-[50%] translate-x-[-50%] text-center w-full `,\r\n    ]),\r\n    title: css([\r\n      tw` text-[4rem] font-black whitespace-pre-line `,\r\n    ]),\r\n    subTitle: css([\r\n      tw` text-[3rem] font-semibold `,\r\n    ]),\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <div id='th-frame' css={style.frame}>\r\n        <div id='th-titles' css={style.titles}>\r\n          <h1 id='th-title' css={style.title}>\r\n            {title.split('\\\\n').map((item, index) => (\r\n              // eslint-disable-next-line react/no-array-index-key\r\n              <React.Fragment key={`${item}-${index}`}>{item}<br /></React.Fragment>\r\n            ))}\r\n          </h1>\r\n          <h2 id='th-sub-title' css={style.subTitle}>{subTitle}</h2>\r\n        </div>\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n썸네일 부분을 그대로 옮겨왔는데, 중요한 것은 `useAppSelector` 함수를 통해서 중앙 저장소에 저장되어있는 `title`, `subTitle` 스테이트를 가져오는 점이 달라졌다는 것입니다. 이런 식으로 편리하고 간단하게 스테이트를 끌어다가 사용할 수 있습니다.\r\n\r\n## 텍스트 설정 부분 분리하기 => TextConfig\r\n<CodeBlock title='TextConfig.tsx'>\r\n```tsx\r\nimport React, { ChangeEvent, useCallback } from 'react';\r\nimport tw, { css } from 'twin.macro';\r\nimport { useAppDispatch, useAppSelector } from '@/hooks/rtk';\r\nimport { setSubTitle, setTitle } from '@/redux';\r\n\r\nexport function TextConfig() {\r\n  const { title, subTitle, } = useAppSelector(\r\n    (state) => state.app\r\n  );\r\n\r\n  const dispatch = useAppDispatch();\r\n\r\n  const onChangeTitle = useCallback(\r\n    (event: ChangeEvent<HTMLInputElement>) => {\r\n      dispatch(setTitle({\r\n        value: event.target.value,\r\n      }));\r\n    },\r\n    []\r\n  );\r\n\r\n  const onChangeSubTitle = useCallback(\r\n    (event: ChangeEvent<HTMLInputElement>) => {\r\n      dispatch(setSubTitle({\r\n        value: event.target.value,\r\n      }));\r\n    },\r\n    []\r\n  );\r\n\r\n  const style = {\r\n    inputs: css([\r\n      tw` space-y-2 `,\r\n    ]),\r\n    input: css([\r\n      tw` flex flex-col gap-1 `,\r\n      tw` [span]:( font-semibold text-normal text-black-base ) `,\r\n      tw` [input]:( p-2 outline-none text-normal bg-black-100 text-black-base placeholder:text-black-300 border-b-[2px] border-transparent transition-colors duration-200 ) `,\r\n      tw` [input]:( focus:( border-blue-500 ) ) `,\r\n    ]),\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <div css={style.inputs}>\r\n        <label htmlFor='title' css={style.input}>\r\n          <span>제목</span>\r\n          <input\r\n            type='text'\r\n            id='title'\r\n            placeholder='제목'\r\n            value={title}\r\n            onChange={onChangeTitle}\r\n          />\r\n        </label>\r\n        <label htmlFor='sub-title' css={style.input}>\r\n          <span>부제</span>\r\n          <input\r\n            type='text'\r\n            id='sub-title'\r\n            placeholder='부제'\r\n            value={subTitle}\r\n            onChange={onChangeSubTitle}\r\n          />\r\n        </label>\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n텍스트를 설정하는 부분도 크게 달라진 건 없지만 `useState` 함수를 이용해서 스테이트를 변경하는 부분에서 리덕스를 사용해서 스테이트를 변경하는 부분으로 바뀌었습니다. 리덕스에서 스테이트를 변경하기 위해서는 `dispatch` 를 사용해야합니다. `dispatch` 함수 안에서 액션을 사용하는 것입니다.\r\n\r\n<CodeBlock title=''>\r\n```tsx\r\nconst [ title, setTitle, ] = useState('제목을 입력하세요.');\r\nconst [ subTitle, setSubTitle, ] = useState('부제');\r\n\r\nconst onChangeTitle = useCallback(\r\n  (event: ChangeEvent<HTMLInputElement>) => {\r\n    setTitle(event.target.value);\r\n  },\r\n  []\r\n);\r\n\r\nconst onChangeSubTitle = useCallback(\r\n  (event: ChangeEvent<HTMLInputElement>) => {\r\n    setSubTitle(event.target.value);\r\n  },\r\n  []\r\n);\r\n```\r\n</CodeBlock>\r\n\r\n이게 기존의 방법이었습니다. 스테이트를 컴포넌트에서 만들고, 그걸 변경하는 것이었죠. 하지만 리덕스를 도입한 후에는 아래처럼 바뀝니다.\r\n\r\n<CodeBlock title=''>\r\n```tsx\r\nconst { title, subTitle, } = useAppSelector(\r\n  (state) => state.app\r\n);\r\n\r\nconst dispatch = useAppDispatch();\r\n\r\nconst onChangeTitle = useCallback(\r\n  (event: ChangeEvent<HTMLInputElement>) => {\r\n    dispatch(setTitle({\r\n      value: event.target.value,\r\n    }));\r\n  },\r\n  []\r\n);\r\n\r\nconst onChangeSubTitle = useCallback(\r\n  (event: ChangeEvent<HTMLInputElement>) => {\r\n    dispatch(setSubTitle({\r\n      value: event.target.value,\r\n    }));\r\n  },\r\n  []\r\n);\r\n```\r\n</CodeBlock>\r\n\r\n중앙 저장소에서 스테이트를 가져온 후에, `dispatch` 를 통해서 액션을 실행시킵니다. 여기서 실행되는 액션은 두가지죠. `setTitle` 과 `setSubTitle` 입니다.\r\n\r\n## 배경 설정 부분 분리하기 => BackgroundConfig\r\n\r\n<CodeBlock title='BackgroundConfig.tsx'>\r\n```tsx\r\nimport React from 'react';\r\nimport tw, { css } from 'twin.macro';\r\n\r\nexport function BackgroundConfig() {\r\n  const style = {\r\n    colors: tw` flex mt-10 `,\r\n    colorTab: css([\r\n      tw` [&[data-selected=\"true\"]]:( p-3 flex-1 shrink-0 border border-black-300 border-b-0 bg-white text-black-base text-center ) `,\r\n      tw` [&[data-selected=\"false\"]]:( p-3 flex-1 shrink-0 border border-black-300 border-b-0 bg-black-300 text-black-600 text-center ) `,\r\n    ]),\r\n    colorTabBottom: css([\r\n      tw` border border-black-300 border-t-0 p-3 bg-white mb-10 `,\r\n    ]),\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <div css={style.colors}>\r\n        <button css={style.colorTab} data-type='color'>단색 배경</button>\r\n        <button css={style.colorTab} data-type='image'>이미지 배경</button>\r\n      </div>\r\n\r\n      <div css={style.colorTabBottom}>\r\n        <input type='range' min={0} max={255} defaultValue={50} id='hex-red' />\r\n        <input type='range' min={0} max={255} defaultValue={50} id='hex-blue' />\r\n        <input type='range' min={0} max={255} defaultValue={50} id='hex-green' />\r\n      </div>\r\n\r\n      <div css={style.colorTabBottom}>\r\n        <input type='text' id='image-src' placeholder='이미지 주소를 입력하세요' />\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n배경을 설정하는 부분은 아직 작업을 한 게 없어서 딱히 달라진 건 없습니다. 이제 다음글에서는 여기를 건드리게 되겠죠. 이제 마지막으로 분리한 후의 `index.tsx` 를 보면서 마치도록 하겠습니다.\r\n\r\n<CodeBlock title='index.tsx'>\r\n```tsx\r\nimport React from 'react';\r\nimport tw, { css } from 'twin.macro';\r\nimport { BackgroundConfig, TextConfig, Thumbnail } from '@/components';\r\n\r\nexport default function IndexPage() {\r\n  const style = {\r\n    default: css([\r\n      tw` w-[1280px] mx-auto `,\r\n    ]),\r\n    buttons: css([\r\n      tw` flex gap-5 `,\r\n      tw` [button]:( flex-1 shrink-0 bg-blue-400 text-white p-3 hover:( bg-blue-600 ) ) `,\r\n    ]),\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <div css={style.default}>\r\n        <Thumbnail />\r\n        <TextConfig />\r\n        <BackgroundConfig />\r\n\r\n        <div css={style.buttons}>\r\n          <button>초기화</button>\r\n          <button>이미지로 저장</button>\r\n        </div>\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n# 마치며\r\n이번 글에서는 리덕스를 도입하고 컴포넌트를 분리하는 작업을 해봤습니다. 실제로 적용하는 건 그렇게 대단한 게 아닌데 글로 작성하니까 상당히 길어진 느낌이 없지 않네요. 이제 다음 글에서는 원래 이번 글에서 진행했어야 했던 배경 설정 부분을 개발하도록 하겠습니다.\r\n"},{"id":6,"content":"\r\n# 개요\r\n이번 글에서는 썸네일 배경 설정을 구현해보도록 합시다. 배경은 이미지 배경이 있고 색상 배경이 있는데 색상 배경을 먼저 개발하도록 하겠습니다. 색상 배경의 경우에는 사용자가 RGB 컬러를 선택하면 적용되는 방향으로 생각하고 있습니다. 저번 글에서 컴포넌트를 분리한 후 배경 설정 컴포넌트는 아무것도 건드리지 않았었는데 차근 차근 진행해보도록 합시다.\r\n\r\n글의 분량이 괜찮다 싶으면 이미지 배경 설정 구현까지 진행해보도록 하겠습니다. 그럼 이제 시작해봅시다.\r\n\r\n# 배경 설정 시작하기\r\n시작하기 전에 현재 상태의 배경 설정 컴포넌트를 살펴보고 넘어가도록 합시다.\r\n\r\n<CodeBlock title='BackgroundConfig.tsx' fold>\r\n```tsx\r\nimport React from 'react';\r\nimport tw, { css } from 'twin.macro';\r\n\r\nexport function BackgroundConfig() {\r\n  const style = {\r\n    colors: tw`  `,\r\n    colorTab: css([\r\n      tw`  `,\r\n    ]),\r\n    colorTabBottom: css([\r\n      tw`  `,\r\n    ]),\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <div css={style.colors}>\r\n        <button css={style.colorTab} data-type='color'>단색 배경</button>\r\n        <button css={style.colorTab} data-type='image'>이미지 배경</button>\r\n      </div>\r\n\r\n      <div css={style.colorTabBottom}>\r\n        <input type='range' min={0} max={255} defaultValue={50} id='hex-red' />\r\n        <input type='range' min={0} max={255} defaultValue={50} id='hex-blue' />\r\n        <input type='range' min={0} max={255} defaultValue={50} id='hex-green' />\r\n      </div>\r\n\r\n      <div css={style.colorTabBottom}>\r\n        <input type='text' id='image-src' placeholder='이미지 주소를 입력하세요' />\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n배경 설정은 두가지가 있고 하나는 색상, 하나는 이미지입니다. 색상과 이미지는 탭으로 구분을 하기 때문에 둘 중 하나를 클릭하면 해당되는 내용이 활성화되도록 해야합니다. 또한 색상 설정의 경우 색상 슬라이더를 직접 만들어서 구현할 생각입니다. 대충 어떻게 할 지 감은 잡았으니 시작해보도록 합시다.\r\n\r\n## 배경 종류 탭 구현하기\r\n배경 종류를 설정하는 탭부터 구현을 해봅시다. 탭은 두개가 있고 클릭 할 때마다 해당 설정 화면이 보여야합니다. 새로고침을 했을 때에도 탭이 유지가 되게끔 만들기 위해서 이 부분에 리덕스를 적용할 생각입니다.\r\n\r\n<CodeBlock title='BackgroundConfig.tsx'>\r\n```tsx\r\nexport default function BackgroundConfig() {\r\n  const bgType = useAppSelector((state) => state.app.bgType);\r\n  const dispatch = useAppDispatch();\r\n\r\n  const onClickColor = useCallback(\r\n    () => {\r\n      dispatch(setBgType({\r\n        value: 'color',\r\n      }));\r\n    },\r\n    []\r\n  );\r\n\r\n  const onClickImage = useCallback(\r\n    () => {\r\n      dispatch(setBgType({\r\n        value: 'image',\r\n      }));\r\n    },\r\n    []\r\n  );\r\n\r\n  const style = {\r\n    colors: tw` flex mt-10 border border-b-0 border-black-200 divide-x divide-black-200 `,\r\n    bgTypeTab: (type: string) => {\r\n      return css([\r\n        tw` p-3 flex-1 shrink-0 `,\r\n        bgType === type\r\n          ? tw` bg-white text-black-base `\r\n          : tw` bg-black-200 text-black-400 `,\r\n      ]);\r\n    },\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <div css={style.colors}>\r\n        <button css={style.bgTypeTab('color')} onClick={onClickColor}>단색 배경</button>\r\n        <button css={style.bgTypeTab('image')} onClick={onClickImage}>이미지 배경</button>\r\n      </div>\r\n\r\n      {/* ... */}\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n먼저 이렇게 중앙 저장소에서 `bgType` 스테이트를 가져온 후에 `onClickColor` 함수와 `onClickImage` 함수를 만들어서 각각 `setBgType` 액션에 다른 값을 전달하는 식으로 구현해둔 상태입니다. 스타일에서는 함수로 매개변수를 받아서 `bgType` 과 `type` 을 비교하는 조건을 걸어서 참일 때와 거짓일 때에 따라서 탭의 색상이 달라지게끔 만들었습니다.\r\n\r\n<Image src='https://drive.google.com/file/d/1FWp6pPS9AWT-6U1eevuYAivtQZw8nYU2/view?usp=drive_link' alt='탭 클릭 구현' drive />\r\n\r\n이렇게만 해주면 자연스럽게 탭의 내용도 바뀌게 만들 수 있겠죠. 이 부분에 리덕스를 사용한 이유는 간단합니다. 위에서도 언급했지만 저는 이 설정 상태가 창을 껐다가 켜도 유지되었으면 좋겠거든요.\r\n\r\n<CodeBlock title='BackgroundConfig.tsx'>\r\n```tsx\r\n<>\r\n  {bgType === 'color' && (\r\n    <div css={style.tabBottom}>\r\n      색상 슬라이더\r\n    </div>\r\n  )}\r\n\r\n  {bgType === 'image' && (\r\n    <div css={style.tabBottom}>\r\n      이미지 주소 input\r\n    </div>\r\n  )}\r\n</>\r\n```\r\n</CodeBlock>\r\n\r\n<Image src='https://drive.google.com/file/d/1x0WX59twzsK-UVIeILbkYwagLObU2jQ2/view?usp=drive_link' alt='색상 배경 선택' drive />\r\n\r\n<Image src='https://drive.google.com/file/d/1PuADu4t3cTi9owS4wvJgl1NkxLjzdMZg/view?usp=drive_link' alt='이미지 배경 선택' drive />\r\n\r\n이런식으로 `bgType` 이 **color** 혹은 **image** 일 때 렌더링되는 부분이 달라지게끔 이렇게 만들 수 있을 것입니다. 그럼 이제 색상 슬라이더를 만들어볼 시간입니다. 색상 슬라이더는 `input` 태그의 `range` 타입을 이용해서 만들겁니다. **0부터 255까지의 값**을 설정할 수 있어야하기 때문이죠.\r\n\r\n## 색상 슬라이더 만들기\r\n색상 슬라이더를 만들기 전에 `BackgroundConfig.tsx` 컴포넌트에서 작업을 하면 코드가 길어지고 지저분해질 것이기 때문에 컴포넌트를 새로 만들어서 작업을 하는 것이 좋겠습니다. `ColorSlider.tsx` 컴포넌트를 만들었습니다.\r\n\r\n<CodeBlock title='ColorSlider.tsx'>\r\n```tsx\r\nexport default function ColorSlider() {\r\n  return (\r\n    <div>\r\n      <input type='range' min='0' max='255' />\r\n      <input type='range' min='0' max='255' />\r\n      <input type='range' min='0' max='255' />\r\n    </div>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n<CodeBlock title='BackgroundConfig.tsx'>\r\n```tsx\r\n<>\r\n  {bgType === 'color' && (\r\n    <div css={style.tabBottom}>\r\n      <ColorSlider />\r\n    </div>\r\n  )}\r\n</>\r\n```\r\n</CodeBlock>\r\n\r\n0에서 255까지의 숫자를 선택할 수 있는 `range` 타입의 `input` 세개를 만듭니다. 이녀석들이 **R, G, B**가 될 것입니다. 이녀석들에게서 값을 얻어내려면 스테이트가 필요합니다. 이 컴포넌트 내에서는 중앙 저장소의 스테이트 하나와 지역 스테이트 세개를 사용할 겁니다.\r\n\r\n`useState` 를 이용해서 스테이트 세개를 만들어줍니다.\r\n\r\n<CodeBlock title='ColorSlider.tsx'>\r\n```tsx\r\nexport default function ColorSlider() {\r\n  const [ red, setRed, ] = useState(50);\r\n  const [ green, setGreen, ] = useState(50);\r\n  const [ blue, setBlue, ] = useState(50);\r\n\r\n  return (\r\n    <div>\r\n      <input type='range' min='0' max='255' />\r\n      <input type='range' min='0' max='255' />\r\n      <input type='range' min='0' max='255' />\r\n    </div>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n기본값은 50으로 설정해두겠습니다. 스테이트를 만들었지만 아직 연결은 되지 않았습니다. 연결을 하고 `onChange` 핸들러까지 만들어주도록 합니다.\r\n\r\n<CodeBlock title='ColorSlider.tsx'>\r\n```tsx\r\nexport default function ColorSlider() {\r\n  const [ red, setRed, ] = useState(50);\r\n  const [ green, setGreen, ] = useState(50);\r\n  const [ blue, setBlue, ] = useState(50);\r\n\r\n  const onChangeRed = useCallback(\r\n    (event: ChangeEvent<HTMLInputElement>) => {\r\n      setRed(+event.target.value);\r\n    },\r\n    [ green, blue, ]\r\n  );\r\n\r\n  const onChangeGreen = useCallback(\r\n    (event: ChangeEvent<HTMLInputElement>) => {\r\n      setGreen(+event.target.value);\r\n    },\r\n    [ red, blue, ]\r\n  );\r\n\r\n  const onChangeBlue = useCallback(\r\n    (event: ChangeEvent<HTMLInputElement>) => {\r\n      setBlue(+event.target.value);\r\n    },\r\n    [ red, green, ]\r\n  );\r\n\r\n  return (\r\n    <div>\r\n      <div>\r\n        <input type='range' min='0' max='255' value={red} onChange={onChangeRed} />\r\n        <span>{red}</span>\r\n      </div>\r\n      <div>\r\n        <input type='range' min='0' max='255' value={green} onChange={onChangeGreen} />\r\n        <span>{green}</span>\r\n      </div>\r\n      <div>\r\n        <input type='range' min='0' max='255' value={blue} onChange={onChangeBlue} />\r\n        <span>{blue}</span>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n<Image src='https://drive.google.com/file/d/151ewzccGZ3puGWAiafkd9am_kCW_JpHu/view?usp=drive_link' alt='숫자가 잘 뽑히는 모습' drive />\r\n\r\n슬라이더가 올바르게 작동하는지 각각의 값도 같이 출력해보았습니다. 수치는 잘 뽑아내고 있는 것 같습니다. 그러면 이제 이걸 색상으로 표현해야합니다. 이 숫자들을 HEX 코드로 바꾸는 작업을 해봅시다.\r\n\r\n<CodeBlock title='BackgroundConfig.tsx'>\r\n```tsx\r\nfunction convertHex(number: number) {\r\n  const hex = number.toString(16).toUpperCase();\r\n\r\n  return hex.length > 1\r\n    ? hex\r\n    : `0${hex}`;\r\n}\r\n\r\nconst hexCode = useMemo(() => {\r\n  const hex = [ red, green, blue, ]\r\n    .map((color) => convertHex(color));\r\n\r\n  return `#${hex.join('')}`;\r\n}, [ red, green, blue, ]);\r\n```\r\n</CodeBlock>\r\n\r\n컴포넌트 내부에 두개의 함수를 만들어줍니다. `convertHex` 함수는 10진수를 16진수로 만들어주는 역할을 합니다. `hexCode` 함수는 `red`, `green`, `blue` 스테이트를 **HEX 코드로 변경**하여 최종적으로 **색상코드를 반환**합니다.\r\n\r\n그리고 이렇게 나온 HEX 코드를 배경에다가 뿌려주면 색이 나타날 겁니다. 하지만 지금은 썸네일에 바로 뿌려주는 것이 아니라 미리보기 색상 용도로 뿌려줘야 합니다.\r\n\r\n<CodeBlock title='ColorSlider.tsx'>\r\n```tsx\r\nexport default function ColorSlider() {\r\n  // ...\r\n\r\n  const hexCode = useMemo(() => {\r\n    const hex = [ red, green, blue, ]\r\n      .map((color) => convertHex(color));\r\n\r\n    return `#${hex.join('')}`;\r\n  }, [ red, green, blue, ]);\r\n\r\n  const style = {\r\n    colorView: css([\r\n      (css`\r\n        background-color: ${hexCode};\r\n      `),\r\n      tw` w-[150px] aspect-square border-2 border-[black] `,\r\n    ]),\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      <div>\r\n        <div>\r\n          <input type='range' min='0' max='255' value={red} onChange={onChangeRed} />\r\n          <span>{red}</span>\r\n        </div>\r\n        <div>\r\n          <input type='range' min='0' max='255' value={green} onChange={onChangeGreen} />\r\n          <span>{green}</span>\r\n        </div>\r\n        <div>\r\n          <input type='range' min='0' max='255' value={blue} onChange={onChangeBlue} />\r\n          <span>{blue}</span>\r\n        </div>\r\n      </div>\r\n      <div css={style.colorView} />\r\n    </div>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n<Image src='https://drive.google.com/file/d/1s7jfIpnPyCk5uyjlHFs-VIJxqULQcyZi/view?usp=drive_link' alt='배경색으로 잘 들어가는 모습' drive />\r\n\r\n잘 적용되는 것을 볼 수 있습니다. 이제 이걸 이용해서 디자인을 조금 개선하고 조금 더 효율적으로 이용할 수 있도록 개선하려고 합니다. 최종적..까지는 아니더라도 개선된 모습은 아래와 같습니다.\r\n\r\n<CodeBlock title='colorSliders.tsx'>\r\n```tsx\r\nimport React, {\r\n  ChangeEvent, useCallback, useMemo, useState\r\n} from 'react';\r\nimport tw, { css } from 'twin.macro';\r\nimport { useAppDispatch } from '@/hooks/rtk';\r\nimport { setBgColor, setTextColor } from '@/redux';\r\n\r\ninterface Props {\r\n  align?: ('horizontal' | 'vertical');\r\n  type?: ('text' | 'background');\r\n}\r\n\r\nexport function ColorSlider({ align = 'vertical', type = 'background', }: Props) {\r\n  const [ red, setRed, ] = useState(50);\r\n  const [ green, setGreen, ] = useState(50);\r\n  const [ blue, setBlue, ] = useState(50);\r\n\r\n  const dispatch = useAppDispatch();\r\n\r\n  const onChangeRed = useCallback(\r\n    (event: ChangeEvent<HTMLInputElement>) => {\r\n      setRed(+event.target.value);\r\n      setColor([ +event.target.value, green, blue, ]);\r\n    },\r\n    [ green, blue, ]\r\n  );\r\n\r\n  const onChangeGreen = useCallback(\r\n    (event: ChangeEvent<HTMLInputElement>) => {\r\n      setGreen(+event.target.value);\r\n      setColor([ red, +event.target.value, blue, ]);\r\n    },\r\n    [ red, blue, ]\r\n  );\r\n\r\n  const onChangeBlue = useCallback(\r\n    (event: ChangeEvent<HTMLInputElement>) => {\r\n      setBlue(+event.target.value);\r\n      setColor([ red, green, +event.target.value, ]);\r\n    },\r\n    [ red, green, ]\r\n  );\r\n\r\n  function convertHex(number: number) {\r\n    const hex = number.toString(16).toUpperCase();\r\n\r\n    return hex.length > 1\r\n      ? hex\r\n      : `0${hex}`;\r\n  }\r\n\r\n  function setColor(colors: number[]) {\r\n    const hex = colors.map((color) => convertHex(color));\r\n\r\n    if (type === 'background') {\r\n      dispatch(setBgColor({\r\n        value: `#${hex.join('')}`,\r\n      }));\r\n    } else {\r\n      dispatch(setTextColor({\r\n        value: `#${hex.join('')}`,\r\n      }));\r\n    }\r\n  }\r\n\r\n  const hexCode = useMemo(() => {\r\n    const hex = [ red, green, blue, ]\r\n      .map((color) => convertHex(color));\r\n\r\n    return `#${hex.join('')}`;\r\n  }, [ red, green, blue, ]);\r\n\r\n  const style = {\r\n    container: css([\r\n      align === 'vertical' && tw` flex w-full `,\r\n      align === 'horizontal' && tw` flex flex-col gap-2 w-full `,\r\n    ]),\r\n    colorSliders: css([\r\n      align === 'vertical' && tw` flex flex-col justify-between flex-1 shrink-0 `,\r\n      align === 'horizontal' && tw` order-2 flex flex-row `,\r\n      tw` [>div]:( flex flex-row items-center flex-1 shrink-0 ) `,\r\n      tw` [span]:( shrink-0 basis-[100px] text-center font-black text-black-base text-big ) `,\r\n    ]),\r\n    slider: css([\r\n      tw` appearance-none bg-black-100 outline-none h-10 flex-1 shrink-0 overflow-hidden `,\r\n      tw` [&::-webkit-slider-thumb]:( appearance-none w-10 aspect-square bg-blue-500 cursor-pointer shadow-[-520px_0_0_500px] shadow-blue-300 ) `,\r\n    ]),\r\n    colorView: css([\r\n      (css`\r\n        background-color: ${hexCode};\r\n      `),\r\n      align === 'vertical' && tw` w-[150px] aspect-square border-2 border-[black] `,\r\n      align === 'horizontal' && tw` w-full h-20 border-2 border-[black] order-1 `,\r\n    ]),\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <div css={style.container}>\r\n        <div css={style.colorSliders}>\r\n          <div>\r\n            <input\r\n              type='range'\r\n              min={0}\r\n              max={255}\r\n              value={red}\r\n              onChange={onChangeRed}\r\n              css={style.slider}\r\n            />\r\n            <span>{red}</span>\r\n          </div>\r\n          <div>\r\n            <input\r\n              type='range'\r\n              min={0}\r\n              max={255}\r\n              value={green}\r\n              onChange={onChangeGreen}\r\n              css={style.slider}\r\n            />\r\n            <span>{green}</span>\r\n          </div>\r\n          <div>\r\n            <input\r\n              type='range'\r\n              min={0}\r\n              max={255}\r\n              value={blue}\r\n              onChange={onChangeBlue}\r\n              css={style.slider}\r\n            />\r\n            <span>{blue}</span>\r\n          </div>\r\n        </div>\r\n        <div css={style.colorView} />\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n`colorSliders.tsx` 컴포넌트에서는 색상이 선택될 때마다 리덕스를 통해 저장하는 방식으로 구현되었습니다. 아직 썸네일에 연결하지는 않았는데 연결하는 방법은 사실 간단합니다. 나중에 해보도록 하고 이 컴포넌트는 아래와 같이 사용하면 됩니다.\r\n\r\n<CodeBlock title='BackgroundConfig.tsx'>\r\n```tsx\r\nimport React, { useCallback } from 'react';\r\nimport tw, { css } from 'twin.macro';\r\nimport { useAppDispatch, useAppSelector } from '@/hooks/rtk';\r\nimport { setBgType } from '@/redux';\r\nimport { ColorSlider } from '.';\r\n\r\nexport function BackgroundConfig() {\r\n  const bgType = useAppSelector(\r\n    (state) => state.app.bgType\r\n  );\r\n  const dispatch = useAppDispatch();\r\n\r\n  const onClickColor = useCallback(\r\n    () => {\r\n      dispatch(setBgType({\r\n        value: 'color',\r\n      }));\r\n    },\r\n    []\r\n  );\r\n\r\n  const onClickImage = useCallback(\r\n    () => {\r\n      dispatch(setBgType({\r\n        value: 'image',\r\n      }));\r\n    },\r\n    []\r\n  );\r\n\r\n  const style = {\r\n    colors: tw` flex mt-10 border border-b-0 border-black-200 divide-x divide-black-200 `,\r\n    bgTypeTab: (type: string) => {\r\n      return css([\r\n        tw` p-3 flex-1 shrink-0 `,\r\n        bgType === type\r\n          ? tw` bg-white text-black-base `\r\n          : tw` bg-black-200 text-black-400 `,\r\n      ]);\r\n    },\r\n    tabBottom: css([\r\n      tw` flex flex-row border border-black-200 border-t-0 p-5 bg-white mb-10 `,\r\n    ]),\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <div css={style.colors}>\r\n        <button css={style.bgTypeTab('color')} onClick={onClickColor}>단색 배경</button>\r\n        <button css={style.bgTypeTab('image')} onClick={onClickImage}>이미지 배경</button>\r\n      </div>\r\n\r\n      {bgType === 'color' && (\r\n        <div css={[ style.tabBottom, tw` flex-col gap-5 `, ]}>\r\n          <ColorSlider type='background' align='vertical' />\r\n          <ColorSlider type='background' align='horizontal' />\r\n        </div>\r\n      )}\r\n\r\n      {bgType === 'image' && (\r\n        <div css={style.tabBottom}>\r\n          {/* <input type='text' id='image-src' placeholder='이미지 주소를 입력하세요' /> */}\r\n        </div>\r\n      )}\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n<Image src='https://drive.google.com/file/d/11pv1RpIKBrw7GLTcdLpOmnf5nGgXzOp_/view?usp=drive_link' alt='경우에 따라서 다르게 사용되는 모습' drive />\r\n\r\n`type` 프롭과 `align` 프롭을 받으면 아래처럼 모양이 바뀌기도 하고 저장되는 중앙 스테이트가 달라지기도 합니다. 색상은 텍스트와 배경 둘 다 사용될 것이기 때문에 이렇게 만들어두었습니다. 이 컴포넌트의 경우에는 기능이 조금 더 개선될 수도 있지만 아직까지는 이정도면 충분한 것 같습니다.\r\n\r\n# 마치며\r\n글이 너무 길어지는 것 같아서 이번 글은 이 쯤에서 마무리 하는 것으로 하고 다음 글에서부터 이어서 진행하도록 하겠습니다. 다음 글에서는 색상 배경 설정 마무리와 텍스트 색상 설정과 이미지 배경 설정을 다뤄보도록 하겠습니다.\r\n"},{"id":7,"content":"\r\n# 개요\r\n지난 글에서 배경 색상 슬라이더를 만들어서 색상을 설정하는 부분까지 진행했습니다. 이번 글에서는 세가지 부분에 대해서 목표를 설정하고 진행하려고 합니다. 바로 본론으로 넘어가서 정리를 하고 시작해보도록 합시다.\r\n\r\n# 구현 목표\r\n이번 글의 목표는 세가지입니다. 첫번째는 **텍스트 색상 설정 구현**입니다. 지금은 제목과 부제만 설정하도록 되어있는데, 텍스트의 색상도 설정할 수 있게 만들 것입니다. 두 번째는 **이미지 배경 설정 구현**입니다. 마지막은 설정한 색상 혹은 이미지를 **썸네일 부분에 적용**하는 작업입니다. 배경 설정은 이번 글에서 마무리를 하고 넘어가려면 이 내용들을 해결해야 합니다.\r\n\r\n그럼 본격적으로 시작해보도록 합시다.\r\n\r\n## 텍스트 색상 설정 구현\r\n<CodeBlock title='TextConfig.tsx'>\r\n```tsx {4, 6-7, 12, 34-37}\r\nexport function TextConfig() {\r\n  const style = {\r\n    inputs: css([\r\n      tw` space-y-2 p-5 bg-white border-2 border-t-0 border-black-600 `,\r\n    ]),\r\n    h2: tw` text-h2 text-white font-black p-3 bg-black-600 `,\r\n    span: tw` font-semibold text-normal text-black-base `,\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <h2 css={style.h2}>텍스트 설정</h2>\r\n      <div css={style.inputs}>\r\n        <label htmlFor='title' css={style.input}>\r\n          <span>제목</span>\r\n          <input\r\n            type='text'\r\n            id='title'\r\n            placeholder='제목'\r\n            value={title}\r\n            onChange={onChangeTitle}\r\n          />\r\n        </label>\r\n        <label htmlFor='sub-title' css={style.input}>\r\n          <span>부제</span>\r\n          <input\r\n            type='text'\r\n            id='sub-title'\r\n            placeholder='부제'\r\n            value={subTitle}\r\n            onChange={onChangeSubTitle}\r\n          />\r\n        </label>\r\n        <div>\r\n          <span css={style.span}>색상</span>\r\n          <ColorSlider type='text' />\r\n        </div>\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n<Image src='https://drive.google.com/file/d/1fDHJow1Sy0JpueB-lJBAGNPsnrkNQu6W/view?usp=drive_link' alt='텍스트 색상 설정까지 구현 완료' drive />\r\n\r\n텍스트 색상 설정은 미리 만들어둔 `ColorSlider` 컴포넌트를 붙여주기만 하면 됩니다. 그 작업을 하면서 디자인을 살짝 수정해봤습니다. 텍스트 설정과 배경 설정 부분이 너무 구분이 가지 않아서 구분이 갈 정도로만 이렇게 수정했습니다. **4번**과 **6-7번**으로 스타일링을 하고 **12번**에 제목을 붙이고 **34-37번**에 `ColorSlider` 컴포넌트를 붙여줬습니다.\r\n\r\n`ColorSlider` 컴포넌트에서 중요한 부분은 `type` 프롭을 `text`로 설정하는 겁니다. 그리고 `ColorSlider` 컴포넌트에서는 아래와 같이 로직을 구현해둡니다.\r\n\r\n<CodeBlock title='ColorSlider.tsx'>\r\n```tsx {2, 7, 15, 23, 36-48}\r\nexport function ColorSlider({ align = 'vertical', type = 'background', }: Props) {\r\n  const dispatch = useAppDispatch();\r\n\r\n  const onChangeRed = useCallback(\r\n    (event: ChangeEvent<HTMLInputElement>) => {\r\n      setRed(+event.target.value);\r\n      setColor([ +event.target.value, green, blue, ]);\r\n    },\r\n    [ green, blue, ]\r\n  );\r\n\r\n  const onChangeGreen = useCallback(\r\n    (event: ChangeEvent<HTMLInputElement>) => {\r\n      setGreen(+event.target.value);\r\n      setColor([ red, +event.target.value, blue, ]);\r\n    },\r\n    [ red, blue, ]\r\n  );\r\n\r\n  const onChangeBlue = useCallback(\r\n    (event: ChangeEvent<HTMLInputElement>) => {\r\n      setBlue(+event.target.value);\r\n      setColor([ red, green, +event.target.value, ]);\r\n    },\r\n    [ red, green, ]\r\n  );\r\n\r\n  function convertHex(number: number) {\r\n    const hex = number.toString(16).toUpperCase();\r\n\r\n    return hex.length > 1\r\n      ? hex\r\n      : `0${hex}`;\r\n  }\r\n\r\n  function setColor(colors: number[]) {\r\n    const hex = colors.map((color) => convertHex(color));\r\n\r\n    if (type === 'background') {\r\n      dispatch(setBgColor({\r\n        value: `#${hex.join('')}`,\r\n      }));\r\n    } else {\r\n      dispatch(setTextColor({\r\n        value: `#${hex.join('')}`,\r\n      }));\r\n    }\r\n  }\r\n\r\n  const hexCode = useMemo(() => {\r\n    const hex = [ red, green, blue, ]\r\n      .map((color) => convertHex(color));\r\n\r\n    return `#${hex.join('')}`;\r\n  }, [ red, green, blue, ]);\r\n\r\n  return (\r\n    <>\r\n      {/* 중략 */}\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n이로써 `type` 프롭이 `text`냐 아니냐에 따라서 배경 색상 설정 혹은 텍스트 색상 설정이 됩니다. 그리고 이 색상은 슬라이더를 조작할 때마다 값이 저장되면서 썸네일에 표시될 것입니다. 지금은 연결을 하지는 않았지만 값 자체는 저장하고 있는 상태입니다.\r\n\r\n**2번**에서 액션 실행을 위한 디스패치를 준비하고 **36-48번**에서 `type` 프롭에 따라 `bgColor` 혹은 `textColor`에 값을 저장하는 함수를 만들어뒀습니다. 그리고 이 함수는 **7번**, **15번**, **23번**에서 사용되고 슬라이더를 조작할 때마다 새로운 값이 갱신됩니다. 이 값을 연결만 하면 됩니다. 이건 가장 마지막에 해보도록 합시다.\r\n\r\n## 이미지 배경 설정 구현\r\n자 이제 이미지 배경 설정을 해볼 시간입니다. 이미지 배경은 두가지 경우를 생각하고 있습니다. 하나는 이미 존재하는 이미지를 웹의 어딘가에서 가져와서 적용하는 것이고 또 다른 하나는 로컬에 있는 이미지를 이용해서 적용하는 것입니다. 전자는 이미지 주소를 붙여넣으면 되고 후자는 `FileReader`를 이용해 URL을 만들어줘야 합니다.\r\n\r\n하지만 지금은 급한대로 첫번째 경우를 우선 적용해서 만들고 후에 두번째 경우도 추가적으로 구현하는 것으로 방향을 잡고 작업을 진행하려고 합니다.\r\n\r\n<CodeBlock title='BackgroundConfig.tsx'>\r\n```tsx {2, 10-18, 24-27, 31, 34-37, 56-65}\r\nexport function BackgroundConfig() {\r\n  const [ srcValue, setSrcValue, ] = useState('');\r\n\r\n  const bgType = useAppSelector(\r\n    (state) => state.app.bgType\r\n  );\r\n\r\n  const dispatch = useAppDispatch();\r\n\r\n  const onChangeSrc = useCallback(\r\n    (event: ChangeEvent<HTMLInputElement>) => {\r\n      setSrcValue(event.target.value);\r\n      dispatch(setImg({\r\n        value: event.target.value,\r\n      }));\r\n    },\r\n    []\r\n  );\r\n\r\n  const style = {\r\n    colors: tw` flex mt-10 `,\r\n    bgTypeTab: (type: string) => {\r\n      return css([\r\n        tw` p-3 flex-1 shrink-0 text-h2 font-black border-2 border-b-0 `,\r\n        bgType === type\r\n          ? tw` bg-black-600 text-white border-black-600 `\r\n          : tw` bg-black-200 text-black-400 border-black-200 `,\r\n      ]);\r\n    },\r\n    tabBottom: css([\r\n      tw` flex flex-row border-2 border-black-600 p-5 bg-white mb-10 `,\r\n    ]),\r\n    input: css([\r\n      tw` flex flex-col gap-1 w-full `,\r\n      tw` [span]:( font-semibold text-normal text-black-base ) `,\r\n      tw` [input]:( p-2 outline-none text-normal bg-black-100 text-black-base placeholder:text-black-300 border-b-[2px] border-transparent transition-colors duration-200 ) `,\r\n      tw` [input]:( focus:( border-blue-500 ) ) `,\r\n    ]),\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <div css={style.colors}>\r\n        <button css={style.bgTypeTab('color')} onClick={onClickColor}>단색 배경</button>\r\n        <button css={style.bgTypeTab('image')} onClick={onClickImage}>이미지 배경</button>\r\n      </div>\r\n\r\n      {bgType === 'color' && (\r\n        <div css={style.tabBottom}>\r\n          <ColorSlider type='background' align='vertical' />\r\n        </div>\r\n      )}\r\n\r\n      {bgType === 'image' && (\r\n        <div css={style.tabBottom}>\r\n          <label htmlFor='image-src' css={style.input}>\r\n            <span>이미지 주소</span>\r\n            <input\r\n              type='text'\r\n              id='image-src'\r\n              placeholder='이미지 주소를 입력하세요'\r\n              value={srcValue}\r\n              onChange={onChangeSrc}\r\n            />\r\n          </label>\r\n        </div>\r\n      )}\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n<Image src='https://drive.google.com/file/d/1fB3iszOetmo9nua7-i8Ff9YBPVUuWiHi/view?usp=drive_link' alt='단색 배경 탭' drive />\r\n<Image src='https://drive.google.com/file/d/1NSUFEhyqPGkeDgcb9-KJe3OcpKYVsafR/view?usp=drive_link' alt='이미지 배경 탭' drive />\r\n\r\n**56-65번**의 `input` 태그를 통해서 이미지의 주소를 입력하면 **10-18번**의 `onChangeSrc` 함수가 실행되는데, 여기서 중요한 것은 `setImg` 액션입니다. `setImg` 액션을 통해 중앙 저장소에 저장되는 구조를 갖고 있습니다. 폼 요소를 컨트롤 해야 하기 때문에 `useState` 함수로 스테이트를 만들어서 관리도 합니다. `useState` 함수를 통한 바인딩은 말 그대로 바인딩 때문에 하는 것이므로 중요도는 떨어집니다. 없으면 안되지만 말이죠.\r\n\r\n지금까지 각 컴포넌트에서 사용된 리덕스의 액션들은 컴포넌트를 넘나들면서 값을 설정하고 가장 마지막에 `Thumbnail` 컴포넌트에서 설정한 값들을 불러와 실제로 적용할 수 있게 만들어줍니다. 이제 마지막으로 썸네일에 설정을 적용하는 일만 남았습니다.\r\n\r\n## 썸네일에 색상과 이미지 적용\r\n`Thumbnail.tsx` 파일을 열어봅니다.\r\n\r\n<CodeBlock title='Thumbnail.tsx'>\r\n```tsx {3}\r\nexport function Thumbnail() {\r\n  const {\r\n    title, subTitle, bgType, imgSrc, bgColor, textColor,\r\n  } = useAppSelector(\r\n    (state) => state.app\r\n  );\r\n\r\n  // 생략\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n먼저 지금까지 설정한 내용들을 사용하기 위해 전부 불러옵니다. 제목과 부제는 연결이 되어있으니까 신경 안써도 괜찮습니다. 먼저 텍스트 색상을 처리하도록 합시다. 그 전에 사용자의 정신 건강을 위해 `ColorSlider` 컴포넌트를 살짝 수정합니다.\r\n\r\n<CodeBlock title='ColorSlider.tsx'>\r\n```tsx {2-4, 8-10}\r\nexport function ColorSlider({ align = 'vertical', type = 'background', }: Props) {\r\n  const [ red, setRed, ] = useState(type === 'text' ? 51 : 255);\r\n  const [ green, setGreen, ] = useState(type === 'text' ? 51 : 255);\r\n  const [ blue, setBlue, ] = useState(type === 'text' ? 51 : 255);\r\n\r\n  const dispatch = useAppDispatch();\r\n\r\n  useEffect(() => {\r\n    setColor([ red, green, blue, ]);\r\n  }, []);\r\n\r\n  // 생략\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n**2-4번**의 스테이트의 기본값을 `type` 프롭에 따라 설정합니다. 텍스트는 기본값이 검은색이고 배경은 기본값이 흰색입니다. 둘 다 검은색이면 귀찮으니까 이렇게 바꿔줍니다. **8-10번**은 컴포넌트가 렌더링되는 그 순간에 값을 저장하는 로직입니다.\r\n\r\n이렇게 하고 다시 `Thumbnail` 컴포넌트로 돌아갑시다.\r\n\r\n<CodeBlock title='Thumbnail.tsx'>\r\n```tsx {11-13}\r\nexport function Thumbnail() {\r\n  const {\r\n    title, subTitle, bgType, imgSrc, bgColor, textColor,\r\n  } = useAppSelector(\r\n    (state) => state.app\r\n  );\r\n\r\n  const style = {\r\n    frame: css([\r\n      tw` box-content border-2 border-black-600 aspect-video mb-10 relative `,\r\n      (css`\r\n        color: ${textColor};\r\n      `),\r\n    ]),\r\n    titles: css([\r\n      tw` absolute top-[50%] translate-y-[-50%] left-[50%] translate-x-[-50%] text-center w-full `,\r\n    ]),\r\n    title: css([\r\n      tw` text-[4rem] font-black whitespace-pre-line `,\r\n    ]),\r\n    subTitle: css([\r\n      tw` text-[3rem] font-semibold `,\r\n    ]),\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <div id='th-frame' css={style.frame}>\r\n        {/* 중략 */}\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n11-13번처럼 CSS에서 `color` 속성을 설정해주면 이제 이렇게 슬라이더를 움직이면 썸네일의 텍스트 색상도 바뀝니다.\r\n\r\n<Image src='https://drive.google.com/file/d/1l_BPmHcK3zw1fBvmNeJDSC4qC8ec-SOt/view?usp=drive_link' alt='슬라이더를 움직여봅시다' drive />\r\n<Image src='https://drive.google.com/file/d/1XRd-JlewWj7veR8659LcFJilrOSzGxIy/view?usp=drive_link' alt='썸네일에 적용된 모습' drive />\r\n\r\n이제 배경 설정을 해봅시다. 배경 설정은 `bgType` 에 따라서 `bgColor` 혹은 `imgSrc` 로 연결해서 설정해주면 됩니다.\r\n\r\n<CodeBlock title='Thumbnail.tsx'>\r\n```tsx {14-19}\r\nexport function Thumbnail() {\r\n  const {\r\n    title, subTitle, bgType, imgSrc, bgColor, textColor,\r\n  } = useAppSelector(\r\n    (state) => state.app\r\n  );\r\n\r\n  const style = {\r\n    frame: css([\r\n      tw` box-content border-2 border-black-600 aspect-video mb-10 relative `,\r\n      (css`\r\n        color: ${textColor};\r\n      `),\r\n      bgType === 'color' && (css`\r\n        background-color: ${bgColor};\r\n      `),\r\n      bgType === 'image' && (css`\r\n        background: url(${imgSrc});\r\n      `),\r\n    ]),\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <div id='th-frame' css={style.frame}>\r\n        {/* 중략 */}\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n`bgType` 이 **color**면 `background-color` 속성에 연결하고 **image**면 `background` 속성에다가 `url()` 안에 넣어주면 됩니다.\r\n\r\n# 마치며\r\n세세한 부분은 다음 글에서 처리를 하도록 하고 배경 설정의 결과물을 보여드리면서 이번 글은 마치도록 하겠습니다. 목적 달성은 했으니 다음 글은 정리를 좀 더 하고 다음 스텝으로 넘어가면 되겠습니다.\r\n\r\n<Image src='https://drive.google.com/file/d/1e8FGDoZBdGuitIdh837SfS3r1L21IgHC/view?usp=drive_link' alt='배경 설정 슬라이더를 움직여보자' drive />\r\n<Image src='https://drive.google.com/file/d/1sRz4mAkcYvtTQqqN7Vk0V6UkhfcGkS5D/view?usp=drive_link' alt='배경 색상이 적용된 모습이다' drive />\r\n\r\n슬라이더를 조작하면 잘 작동합니다.\r\n\r\n<Image src='https://drive.google.com/file/d/1RiXkiASNxRpzifG45yV_NImYeW1b3LJS/view?usp=drive_link' alt='이미지 주소를 넣어봅니다' drive />\r\n<Image src='https://drive.google.com/file/d/1GfUpN5L2cX6jR2Ojah5z93cfsFqkXjpb/view?usp=drive_link' alt='이미지가 배경에 잘 들어옵니다' drive />\r\n\r\n이미지 주소를 가져와서 넣어도 잘 동작합니다. 이제 이 부분은 애초부터 16:9인 이미지만 배경에 넣게 하거나 하는 등으로 제한을 두면 되지 않을까 싶기도 합니다. 아무튼 이번 글은 여기까지입니다!\r\n"},{"id":8,"content":"\r\n# 개요\r\n저번 글에서는 배경이미지 설정까지 진행하고 글을 마쳤었습니다. 이번 글에서는 저번에 미처 신경쓰지 못한 배경 이미지 설정의 마무리를 진행하고, 색상 슬라이더를 살짝 손 볼 생각입니다. 문제가 있었거든요. 사용자가 설정한 내용이 적용된 썸네일을 이미지로 생성하는 것까지 진행하려고 합니다.\r\n\r\n# 배경 이미지 설정 보완\r\n<CodeBlock title='Thumbnail.tsx'>\r\n```tsx\r\nconst style = {\r\n  frame: css([\r\n    tw` box-content border-2 border-black-600 aspect-video mb-10 relative `,\r\n    (css`\r\n      color: ${textColor};\r\n    `),\r\n    bgType === 'color' && (css`\r\n      background-color: ${bgColor};\r\n    `),\r\n    bgType === 'image' && (css`\r\n      background-image: url(${imgSrc});\r\n    `),\r\n  ]),\r\n};\r\n```\r\n</CodeBlock>\r\n\r\n`bgType` 이 **image** 일 때에는 `background-image` 를 설정하게끔 만들었었습니다. 하지만 문제가 있죠.\r\n\r\n<Image src='https://drive.google.com/file/d/1xQHaE0vJwRQfejc2GKnRY1qcYGjtL-CX/view?usp=drive_link' alt='현재 배경의 문제점' drive />\r\n\r\n`background-image` 로 배경을 넣으면 위의 스샷처럼 이미지가 바둑판처럼 반복되는 문제가 생깁니다. 우리가 원하는 건 이런 게 아니죠. 이 부분을 개선해야합니다. 처음부터 이미지를 규격에 맞는 것을 고르면 문제가 사라지지만 규격에 맞지 않아도 배경으로 사용하고 싶은 경우도 있습니다.\r\n\r\n## CSS 개선\r\n\r\n그래서 두가지 속성을 추가하려고 합니다. `background-size` 와 `background-position-y` 를 이용해서 원하는 부분을 배경으로 사용할 수 있게끔 할겁니다. 위의 코드를 아래와 같이 수정해봅시다.\r\n\r\n<CodeBlock title='Thumbnail.tsx'>\r\n```tsx\r\nconst style = {\r\n  frame: css([\r\n    tw` box-content border-2 border-black-600 aspect-video mb-10 relative `,\r\n    (css`\r\n      color: ${textColor};\r\n    `),\r\n    bgType === 'color' && (css`\r\n      background-color: ${bgColor};\r\n    `),\r\n    bgType === 'image' && (css`\r\n      background-image: url(${imgSrc});\r\n      background-size: cover;\r\n      background-position-y: -220px;\r\n    `),\r\n  ]),\r\n};\r\n```\r\n</CodeBlock>\r\n\r\n이렇게 하면 더이상 바둑판처럼 보이지 않고 화면을 꽉 채우기 때문에 조금 더 보기 좋아지죠. 그리고 Y 좌표를 조작해서 원하는 부분을 볼 수 있습니다. 위의 코드상으로는 **-220px** 이라고 되어있는데 220 픽셀만큼 아래로 내리겠다 라는 의미입니다.\r\n\r\n문제는 여기서 220을 우리가 원하는 값으로 바꿀 수 있어야합니다. 중앙 저장소에 스테이트를 하나 추가하고 새롭게 관리하도록 하면 되겠죠.\r\n\r\n## 리듀서에서 스테이트와 액션 추가하기\r\n\r\n<CodeBlock title='app.reducer.ts'>\r\n```ts {8, 18, 32, 34-39, 44}\r\ntype AppState = {\r\n  bgType: ('color' | 'image');\r\n  title: string;\r\n  subTitle: string;\r\n  textColor: string;\r\n  bgColor: string;\r\n  imgSrc: string;\r\n  imageY: number;\r\n}\r\n\r\nconst initialState: AppState = {\r\n  bgType: 'color',\r\n  title: '제목을 입력하세요',\r\n  subTitle: '',\r\n  textColor: '#333333',\r\n  bgColor: '#FFFFFF',\r\n  imgSrc: '',\r\n  imageY: 0,\r\n};\r\n\r\nconst appReducer = createSlice({\r\n  name: 'app',\r\n  initialState,\r\n  reducers: {\r\n    initState(state) {\r\n      state.bgType = 'color';\r\n      state.title = '제목을 입력하세요';\r\n      state.subTitle = '';\r\n      state.textColor = '#333333';\r\n      state.bgColor = '#FFFFFF';\r\n      state.imgSrc = '';\r\n      state.imageY = 0;\r\n    },\r\n    setY(\r\n      state,\r\n      { payload, }: PayloadAction<{value: number}>\r\n    ) {\r\n      state.imageY = payload.value;\r\n    },\r\n  },\r\n});\r\n\r\nexport const {\r\n  initState, setBgType, setTitle, setSubTitle, setTextColor, setBgColor, setImg, setY,\r\n} = appReducer.actions;\r\n```\r\n</CodeBlock>\r\n\r\n`AppState` 타입에 `imageY`를 추가하고 `initialState`에도 추가를 해줍니다. `initState` 액션에서 `imageY`를 초기화하는 부분을 추가하고 `setY` 액션을 만들어서 내보냅니다. 자 이제 `BackgroundConfig` 컴포넌트로 가서 추가 로직을 구현해봅시다.\r\n\r\n## 새롭게 추가한 좌표 스테이트 적용하기\r\n\r\n<CodeBlock title='BackgroundConfig.tsx'>\r\n```tsx\r\nimport { setY as setImageY } from '@/redux';\r\n\r\nexport function BackgroundConfig() {\r\n  const [ y, setY, ] = useState(0);\r\n\r\n  const onChangeY = useCallback(\r\n    (event: ChangeEvent<HTMLInputElement>) => {\r\n      setY(+event.target.value);\r\n      dispatch(setImageY({\r\n        value: +event.target.value,\r\n      }));\r\n    },\r\n    []\r\n  );\r\n\r\n  return (\r\n    <>\r\n      {/* --- */}\r\n      {bgType === 'image' && (\r\n        <div css={style.tabBottom}>\r\n          {/* --- */}\r\n\r\n          <label htmlFor='image-y' css={style.input}>\r\n            <span>Y좌표</span>\r\n            <input\r\n              type='text'\r\n              id='image-y'\r\n              placeholder='원하는 좌표를 입력하세요'\r\n              value={y}\r\n              onChange={onChangeY}\r\n            />\r\n          </label>\r\n        </div>\r\n      )}\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n<Image src='https://drive.google.com/file/d/1sN-U2AR27Zw_S9cOSeQuYrRtNRjF-ZG_/view?usp=drive_link' alt='좌표를 설정할 수 있게 개선' drive />\r\n\r\ny 좌표는 숫자를 입력하면 입력한 만큼 아래로 내리는 역할을 하게 됩니다. 기본값은 0이고 그 이후에는 원하는 값을 입력하면 되겠죠. `setY` 로는 컴포넌트 내에서 저장을 하고, `setImageY` 액션으로는 중앙 저장소에 저장을 해둡니다.\r\n\r\n자 모든 준비가 끝났습니다. 그럼 이제 마지막으로 `Thumbnail` 컴포넌트에서 적용해보도록 합시다. CSS만 살짝 건드리면 됩니다.\r\n\r\n<CodeBlock title='title'>\r\n```tsx {14}\r\nconst style = {\r\n  frame: css([\r\n    tw` box-content border-2 border-black-600 aspect-video mb-10 relative `,\r\n    (css`\r\n      color: ${textColor};\r\n    `),\r\n    bgType === 'color' && (css`\r\n      background-color: ${bgColor};\r\n    `),\r\n    bgType === 'image' && (css`\r\n      background-image: url(${imgSrc});\r\n      background-size: cover;\r\n      /* background-position-y: -220px; */\r\n      background-position-y: -${imageY}px;\r\n    `),\r\n  ]),\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n숫자 220이 들어가 있던 자리에 변수를 넣어서 대체합니다. **-** 기호를 남겨두는 이유는 매번 - 기호를 입력하는 것보다 그냥 숫자만 입력하는 게 더 사용하기에 편하기 때문입니다. 이렇게 하면 원하는 값을 입력했을 때 썸네일에도 그대로 적용되겠죠.\r\n\r\n<Image src='https://drive.google.com/file/d/1d6x6zT4DKZkfZrnzTK_ADk7LipHJyTMs/view?usp=drive_link' alt='350을 입력함' drive />\r\n<Image src='https://drive.google.com/file/d/1srcRb_oRo8tWuXKMMXtrwePPcV-KTW86/view?usp=drive_link' alt='원하는 위치를 선택할 수 있다!' drive />\r\n\r\n# 색상 슬라이더 보완하기\r\n색상 슬라이더에 문제가 있었습니다. 미리 테스트를 해봤는데 초기화 버튼을 클릭해도 슬라이더의 상태는 초기화되지 않았던 것입니다. 이건 문제가 있기 때문에 해결해야합니다. 해결을 위해 생각을 해본 결과 색상코드 자체를 저장하는 게 아니라 빨간색, 초록색, 파란색 정보를 따로 저장하는 것이 좋겠다라는 결론에 이르렀습니다.\r\n\r\n이를 위해 리듀서를 수정해야합니다.\r\n\r\n## 리듀서 수정하기\r\n<CodeBlock title='app.reducer.ts'>\r\n```ts {1-5, 11-12, 21-30}\r\ntype Color = {\r\n  red: number;\r\n  green: number;\r\n  blue: number;\r\n}\r\n\r\ntype AppState = {\r\n  bgType: ('color' | 'image');\r\n  title: string;\r\n  subTitle: string;\r\n  textColor: Color;\r\n  bgColor: Color;\r\n  imgSrc: string;\r\n  imageY: number;\r\n}\r\n\r\nconst initialState: AppState = {\r\n  bgType: 'color',\r\n  title: '제목을 입력하세요',\r\n  subTitle: '',\r\n  textColor: {\r\n    red: 51,\r\n    green: 51,\r\n    blue: 51,\r\n  },\r\n  bgColor: {\r\n    red: 255,\r\n    green: 255,\r\n    blue: 255,\r\n  },\r\n  imgSrc: '',\r\n  imageY: 0,\r\n};\r\n```\r\n</CodeBlock>\r\n\r\n이런식으로 숫자값 자체를 저장하게 만들어뒀습니다. 이렇게 하지 않으면 값을 인식 못하는 것 같더군요. 그럼 이제 액션도 수정을 해야합니다. 액션도 뭐 간단합니다.\r\n\r\n<CodeBlock title='app.reducer.ts'>\r\n```ts {9-18, 24, 26, 30, 32}\r\nconst appReducer = createSlice({\r\n  name: 'app',\r\n  initialState,\r\n  reducers: {\r\n    initState(state) {\r\n      state.bgType = 'color';\r\n      state.title = '제목을 입력하세요';\r\n      state.subTitle = '';\r\n      state.textColor = {\r\n        red: 51,\r\n        green: 51,\r\n        blue: 51,\r\n      };\r\n      state.bgColor = {\r\n        red: 255,\r\n        green: 255,\r\n        blue: 255,\r\n      };\r\n      state.imgSrc = '';\r\n      state.imageY = 0;\r\n    },\r\n    setTextColor(\r\n      state,\r\n      { payload, }: PayloadAction<{value: Color}>\r\n    ) {\r\n      state.textColor = payload.value;\r\n    },\r\n    setBgColor(\r\n      state,\r\n      { payload, }: PayloadAction<{value: Color}>\r\n    ) {\r\n      state.bgColor = payload.value;\r\n    },\r\n  },\r\n});\r\n```\r\n</CodeBlock>\r\n\r\n이런식으로 기존의 문자열이 아니라 객체를 받게끔 만들어줬습니다. 이렇게 하면 값을 하나 하나 받기 때문에 뿌릴 때에도 하나 하나 뿌려줄 수가 있을 겁니다.\r\n\r\n## ColorSlider 컴포넌트 수정하기\r\n<CodeBlock title='ColorSlider.tsx'>\r\n```tsx\r\nexport default function ColorSlider() {\r\n  const [ red, setRed, ] = useState(type === 'text' ? 51 : 255);\r\n  const [ green, setGreen, ] = useState(type === 'text' ? 51 : 255);\r\n  const [ blue, setBlue, ] = useState(type === 'text' ? 51 : 255);\r\n\r\n  const dispatch = useAppDispatch();\r\n\r\n  useEffect(() => {\r\n    setColor([ red, green, blue, ]);\r\n  }, []);\r\n\r\n  const onChangeRed = useCallback(\r\n    (event: ChangeEvent<HTMLInputElement>) => {\r\n      setRed(+event.target.value);\r\n      setColor([ +event.target.value, green, blue, ]);\r\n    },\r\n    [ green, blue, ]\r\n  );\r\n\r\n  const onChangeGreen = useCallback(\r\n    (event: ChangeEvent<HTMLInputElement>) => {\r\n      setGreen(+event.target.value);\r\n      setColor([ red, +event.target.value, blue, ]);\r\n    },\r\n    [ red, blue, ]\r\n  );\r\n\r\n  const onChangeBlue = useCallback(\r\n    (event: ChangeEvent<HTMLInputElement>) => {\r\n      setBlue(+event.target.value);\r\n      setColor([ red, green, +event.target.value, ]);\r\n    },\r\n    [ red, green, ]\r\n  );\r\n\r\n  function convertHex(number: number) {\r\n    const hex = number.toString(16).toUpperCase();\r\n\r\n    return hex.length > 1\r\n      ? hex\r\n      : `0${hex}`;\r\n  }\r\n\r\n  function setColor(colors: number[]) {\r\n    const hex = colors.map((color) => convertHex(color));\r\n\r\n    if (type === 'background') {\r\n      dispatch(setBgColor({\r\n        value: `#${hex.join('')}`,\r\n      }));\r\n    } else {\r\n      dispatch(setTextColor({\r\n        value: `#${hex.join('')}`,\r\n      }));\r\n    }\r\n  }\r\n\r\n  const hexCode = useMemo(() => {\r\n    const hex = [ red, green, blue, ]\r\n      .map((color) => convertHex(color));\r\n\r\n    return `#${hex.join('')}`;\r\n  }, [ red, green, blue, ]);\r\n\r\n  return (\r\n    // 생략\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n이 코드는 기존의 상태 관리를 하던 로직인데 이제 기존의 스테이트는 필요가 없습니다. 과감하게 지워버리고 다시 작성해봅시다. hex로 변환하는 과정도 이제는 필요가 없죠. 따라서 이 함수들도 지워버려도 됩니다.\r\n\r\n<CodeBlock title='ColorSlider.tsx'>\r\n```tsx\r\n// 변경전\r\nconst [ red, setRed, ] = useState(type === 'text' ? 51 : 255);\r\nconst [ green, setGreen, ] = useState(type === 'text' ? 51 : 255);\r\nconst [ blue, setBlue, ] = useState(type === 'text' ? 51 : 255);\r\n\r\n// 변경후\r\nconst { textColor, bgColor, } = useAppSelector(\r\n  (state) => state.app\r\n);\r\n\r\nconst color = useMemo(() => {\r\n  return type === 'text'\r\n    ? textColor\r\n    : bgColor;\r\n}, [ textColor, bgColor, ]);\r\n```\r\n</CodeBlock>\r\n\r\n스테이트 부분은 이렇게 처리를 했습니다. 여전히 `type` 프롭에 따라서 결정되긴 하지만 중앙 저장소에서 직접 가져오게끔 설정해줬습니다.\r\n\r\n<CodeBlock title='ColorSlider.tsx'>\r\n```tsx\r\n// 변경전\r\nuseEffect(() => {\r\n  setColor([ red, green, blue, ]);\r\n}, []);\r\n\r\n// 변경후\r\nuseEffect(() => {\r\n  setColor([ color.red, color.green, color.blue, ]);\r\n}, []);\r\n```\r\n</CodeBlock>\r\n\r\n`useEffect` 훅 부분은 그냥 변수 호출만 바꿔주면 되죠.\r\n\r\n<CodeBlock title='ColorSlider.tsx'>\r\n```tsx\r\n// 변경전\r\nconst onChangeRed = useCallback(\r\n  (event: ChangeEvent<HTMLInputElement>) => {\r\n    setRed(+event.target.value);\r\n    setColor([ +event.target.value, green, blue, ]);\r\n  },\r\n  [ green, blue, ]\r\n);\r\n\r\nconst onChangeGreen = useCallback(\r\n  (event: ChangeEvent<HTMLInputElement>) => {\r\n    setGreen(+event.target.value);\r\n    setColor([ red, +event.target.value, blue, ]);\r\n  },\r\n  [ red, blue, ]\r\n);\r\n\r\nconst onChangeBlue = useCallback(\r\n  (event: ChangeEvent<HTMLInputElement>) => {\r\n    setBlue(+event.target.value);\r\n    setColor([ red, green, +event.target.value, ]);\r\n  },\r\n  [ red, green, ]\r\n);\r\n\r\nfunction convertHex(number: number) {\r\n  const hex = number.toString(16).toUpperCase();\r\n\r\n  return hex.length > 1\r\n    ? hex\r\n    : `0${hex}`;\r\n}\r\n\r\nfunction setColor(colors: number[]) {\r\n  const hex = colors.map((color) => convertHex(color));\r\n\r\n  if (type === 'background') {\r\n    dispatch(setBgColor({\r\n      value: `#${hex.join('')}`,\r\n    }));\r\n  } else {\r\n    dispatch(setTextColor({\r\n      value: `#${hex.join('')}`,\r\n    }));\r\n  }\r\n}\r\n\r\nconst hexCode = useMemo(() => {\r\n  const hex = [ red, green, blue, ]\r\n    .map((color) => convertHex(color));\r\n\r\n  return `#${hex.join('')}`;\r\n}, [ red, green, blue, ]);\r\n\r\n// 변경후\r\nconst onChangeRed = useCallback(\r\n  (event: ChangeEvent<HTMLInputElement>) => {\r\n    setColor([ +event.target.value, color.green, color.blue, ]);\r\n  },\r\n  [ color.green, color.blue, ]\r\n);\r\n\r\nconst onChangeGreen = useCallback(\r\n  (event: ChangeEvent<HTMLInputElement>) => {\r\n    setColor([ color.red, +event.target.value, color.blue, ]);\r\n  },\r\n  [ color.red, color.blue, ]\r\n);\r\n\r\nconst onChangeBlue = useCallback(\r\n  (event: ChangeEvent<HTMLInputElement>) => {\r\n    setColor([ color.red, color.green, +event.target.value, ]);\r\n  },\r\n  [ color.red, color.green, ]\r\n);\r\n\r\nfunction setColor(colors: number[]) {\r\n  if (type === 'background') {\r\n    dispatch(setBgColor({\r\n      value: {\r\n        red: colors[0],\r\n        green: colors[1],\r\n        blue: colors[2],\r\n      },\r\n    }));\r\n  } else {\r\n    dispatch(setTextColor({\r\n      value: {\r\n        red: colors[0],\r\n        green: colors[1],\r\n        blue: colors[2],\r\n      },\r\n    }));\r\n  }\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n이런식으로 세팅을 바꿔줬더니 기능동작이 잘 되는 것을 볼 수 있었습니다. 초기화가 안되는 문제로 며칠동안 고민했었는데 이제야 해결이 되어 참 다행입니다. 며칠 더 머리아플 뻔 했습니다. 이제 수정의 마무리로 `Thumbnail` 컴포넌트의 일부를 수정하면 됩니다.\r\n\r\n## Thumbnail 컴포넌트 수정하기\r\n<CodeBlock title='Thumbnail.tsx'>\r\n```tsx\r\n// 변경전\r\nconst style = {\r\n  frame: css([\r\n    (css`\r\n      color: ${textColor};\r\n    `),\r\n    bgType === 'color' && (css`\r\n      background-color: ${bgColor};\r\n    `),\r\n  ]),\r\n};\r\n\r\n// 변경후\r\nconst style = {\r\n  frame: css([\r\n    (css`\r\n      color: rgb(${textColor.red}, ${textColor.green}, ${textColor.blue});\r\n    `),\r\n    bgType === 'color' && (css`\r\n      background-color: rgb(${bgColor.red}, ${bgColor.green}, ${bgColor.blue});\r\n    `),\r\n  ]),\r\n};\r\n```\r\n</CodeBlock>\r\n\r\n이제 슬라이더 관련해서는 더 이상 수정할 것이 없습니다. 다음 스텝으로 넘어가봅시다.\r\n\r\n# 이미지 생성하기\r\n아직 많은 부분을 추가하고 보완해야겠지만 원하는 기능은 전부 존재합니다. 텍스트를 입력하고, 배경을 설정할 수 있죠. 이제 마지막, 이미지를 생성하는 일만 남았습니다. 라이브러리를 이용해서 HTML을 CANVAS로 만드는 방법도 있는 것 같고 여러가지 방법있는 것 같은데, 역시 목적 달성을 위해 라이브러리를 사용하도록 합시다.\r\n\r\n<CodeBlock title=''>\r\n```bash\r\nyarn add html2canvas\r\n```\r\n</CodeBlock>\r\n\r\n라이브러리를 설치합니다. 설치할 라이브러리의 이름은 **html2canvas** 입니다. 간단하게 HTML 요소를 캡처해서 파일로 저장할 수 있다고 합니다. 한 번 사용해봅시다. 일단 이렇게 설치를 합니다. 그리고 `index.tsx` 에서 불러와서 사용 해봅시다.\r\n\r\n설정을 한 후에 이미지로 저장 버튼을 클릭하면 이미지로 저장이 되어야합니다. 이걸 건드리면 되겠죠. 초기화 버튼은 이후에 처리하도록 하겠습니다. 일단 이미지부터 만들어봅시다. 아, 생각을 해보니까 버튼의 위치가 애매한 거 같아요. `Thumbnail` 컴포넌트 안으로 옮기도록 하겠습니다.\r\n\r\n<Image src='https://drive.google.com/file/d/1JcwRkJ__MRdK0lPxqIHpKZeINwNHawlO/view?usp=drive_link' alt='기존의 구조' drive />\r\n\r\n원래는 이런 모습이었습니다. 그런데 아래처럼 바꿨습니다. 그러면 `index.tsx` 가 아니라 `Thumbnail` 컴포넌트에서 작업을 하면 되겠죠. 하지만 뭐 코드는 뻔하니까 생략하도록 하고 아래처럼 바꿨습니다.\r\n\r\n<Image src='https://drive.google.com/file/d/1AuVjt5H_IHGBsFXPFGbmvaG4-ip79KGh/view?usp=drive_link' alt='버튼 위치 바꾸기' drive />\r\n\r\n자 아무튼 버튼의 위치를 바꿨으니까 이제 본격적으로 버튼에 기능을 붙여보도록 하겠습니다. 두개의 버튼이 있어요. 초기화 버튼과 이미지로 저장 버튼이 있죠. 이 중에서 이미지로 저장 버튼을 먼저 건드려봅시다.\r\n\r\n<CodeBlock title='Thumbnail.tsx'>\r\n```tsx\r\nexport function Thumbnail() {\r\n  const [ isClick, setIsClick, ] = useState(false);\r\n  const thRef = useRef<HTMLDivElement>(null);\r\n  const imageRef = useRef<HTMLDivElement>(null);\r\n\r\n  const onClickDownload = useCallback(\r\n    () => {\r\n      html2canvas(thRef.current, { allowTaint: true, useCORS: true, }).then((canvas) => {\r\n        const img = document.createElement('img');\r\n        img.src = canvas.toDataURL('image/png');\r\n\r\n        imageRef.current.innerHTML = '';\r\n        imageRef.current.appendChild(img);\r\n      });\r\n\r\n      setIsClick(true);\r\n    },\r\n    [ thRef, imageRef, ]\r\n  );\r\n\r\n  return (\r\n    <>\r\n      {isClick && (\r\n        <div css={style.image} ref={imageRef} onClick={onClickClose} />\r\n      )}\r\n      <div css={style.buttons}>\r\n        <button onClick={onClickDownload}>이미지로 저장</button>\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n가장 먼저 `useState` 훅으로 스테이트를 하나 만듭니다. 여기서만 쓰일 것이기 때문에 중앙 저장소에 만들 필요는 없습니다. 클릭했을 때 이미지가 보이는가 아닌가에 대한 여부를 결정하는 스테이트입니다.\r\n\r\n그 후에 `html2canvas` 함수를 임포트하고 첫번째 인수에 이미지화 하려는 타겟을 넣어줍니다. `thRef.current` 를 넣어줬습니다. 두번째 인수에는 옵션이 들어갑니다. 이미지 관련해서 적용될 수 있도록 세팅을 해줬습니다. `html2canvas`는 비동기이기 때문에 `then` 을 이용해서 성공했을 때의 처리를 해줍니다.\r\n\r\n매개변수 `canvas` 에는 html이 canvas로 변환된 요소가 들어있습니다. 이 요소를 이용해서 이미지를 다운받거나 이미지를 보이게 할 수 있습니다. 저는 이미지 다운로드 쪽으로 가려고 했지만 다운로드는 직접 우클릭해서 하게 하는 게 나을 것 같아서 변환된 이미지를 보여주는 것으로 진행했습니다. 클릭하면 이미지가 나타나게 설계되어 있습니다. 그리고 이미지가 생성 되었어도 취소하고 수정을 할 수 있도록 이미지를 닫을 수 있는 기능도 마련되어 있습니다.\r\n\r\n<Image src='https://drive.google.com/file/d/1UigJi-RmIsnGW29d3tRHr-Pd38XZrEeE/view?usp=drive_link' alt='이미지 생성 성공!' drive />\r\n\r\n이제 초기화 버튼의 기능을 추가해봅시다. 여긴 간단합니다. 이전에 만들어놓은 액션 중에는 스테이트들을 초기화하는 액션도 있었습니다. 그 액션을 사용하면 됩니다.\r\n\r\n<CodeBlock title='Thumbnail.tsx'>\r\n```tsx\r\nexport function Thumbnail() {\r\n  const dispatch = useAppDispatch();\r\n\r\n  const onClickReset = useCallback(\r\n    () => {\r\n      dispatch(initState());\r\n    },\r\n    []\r\n  );\r\n\r\n  return (\r\n    <>\r\n      {isClick && (\r\n        <div css={style.image} ref={imageRef} onClick={onClickClose} />\r\n      )}\r\n      <div css={style.buttons}>\r\n      <button onClick={onClickReset}>초기화</button>\r\n        <button onClick={onClickDownload}>이미지로 저장</button>\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n초기화 버튼을 클릭함으로써 `onClickReset` 함수가 실행되면 `initState` 액션을 통해서 각 스테이트들을 초기화합니다. 그러면 색상이나 텍스트들이 초기화되겠죠.\r\n\r\n아래는 최종 결과물입니다.\r\n\r\n<CodeBlock title='Thumbnail.tsx'>\r\n```tsx\r\nimport React, {\r\n  useCallback, useEffect, useRef, useState\r\n} from 'react';\r\nimport tw, { css } from 'twin.macro';\r\nimport html2canvas from 'html2canvas';\r\nimport { useAppDispatch, useAppSelector } from '@/hooks/rtk';\r\nimport { initState } from '@/redux';\r\n\r\nexport function Thumbnail() {\r\n  const [ isClick, setIsClick, ] = useState(false);\r\n\r\n  const thRef = useRef<HTMLDivElement>(null);\r\n  const imageRef = useRef<HTMLDivElement>(null);\r\n  const dispatch = useAppDispatch();\r\n\r\n  const {\r\n    title, subTitle, bgType, imgSrc, bgColor, textColor, imageY,\r\n  } = useAppSelector(\r\n    (state) => state.app\r\n  );\r\n\r\n  useEffect(() => {\r\n    dispatch(initState());\r\n  }, []);\r\n\r\n  const onClickReset = useCallback(\r\n    () => {\r\n      dispatch(initState());\r\n    },\r\n    []\r\n  );\r\n\r\n  const onClickDownload = useCallback(\r\n    () => {\r\n      html2canvas(thRef.current, { allowTaint: true, useCORS: true, }).then((canvas) => {\r\n        const img = document.createElement('img');\r\n        img.src = canvas.toDataURL('image/png');\r\n\r\n        imageRef.current.innerHTML = '';\r\n        imageRef.current.appendChild(img);\r\n      });\r\n\r\n      setIsClick(true);\r\n    },\r\n    [ thRef, imageRef, ]\r\n  );\r\n\r\n  const onClickClose = useCallback(\r\n    () => {\r\n      setIsClick(false);\r\n    },\r\n    []\r\n  );\r\n\r\n  // 스타일 중략\r\n\r\n  return (\r\n    <>\r\n      {isClick && (\r\n        <div css={style.image} ref={imageRef} onClick={onClickClose} />\r\n      )}\r\n\r\n      <div id='th-container' css={style.container} ref={thRef}>\r\n        <div id='th-frame' css={style.frame}>\r\n          <div id='th-titles' css={style.titles}>\r\n            <h1 id='th-title' css={style.title}>\r\n              {title.split('\\\\n').map((item, index) => (\r\n              // eslint-disable-next-line react/no-array-index-key\r\n                <React.Fragment key={`${item}-${index}`}>{item}<br /></React.Fragment>\r\n              ))}\r\n            </h1>\r\n            <h2 id='th-sub-title' css={style.subTitle}>{subTitle}</h2>\r\n          </div>\r\n        </div>\r\n      </div>\r\n\r\n      <div css={style.buttons}>\r\n        <button onClick={onClickReset}>초기화</button>\r\n        <button onClick={onClickDownload}>이미지로 저장</button>\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n이렇게 해서 이미지 생성과 초기화까지 마쳤습니다. 사실 이제야 기본적인 기능이 갖춰진 것입니다. 앞으로 보완하면서 다듬고 추가적인 기능을 붙이면 될 것 같습니다. 이미지가 생성되었을 때 닫을 수 있다는 것을 의미하는 UI도 만들어야 하겠죠. 예를 들어 X 표시를 만들어둔다던가 해서 이 모달창은 닫을 수 있습니다 라는 메시지를 텍스트 없이도 전달할 수 있겠죠.\r\n\r\n앞으로 해야할 것은 이미지를 생성했을 때 설정 정보가 저장된 json을 자신의 구글 드라이브에 저장할 수 있는 기능과 불러올 수 있는 기능입니다. 이 구글 드라이브 연동 기능도 선택에 따라서 할 수 있게끔 만들 예정입니다. 단발적으로만 사용하고 싶을 경우에는 그냥 구글 드라이브 연동 없이 이미지 생성하면 그만이고\r\n\r\n이 이미지들을 계속해서 관리하고 싶다면 json 데이터를 만들어서 구글 드라이브에 저장하면 이 저장된 데이터를 이용해서 파일들을 불러올 수 있도록 하는 것이죠. 이 프로그램 자체에 회원 관리 시스템이 없더라도 할 수 있게끔 만들어볼 생각입니다.\r\n\r\n이제 슬슬 일정 관리 프로그램도 만들기 시작해야겠습니다. 다음 글이 일정 관리 시작이 될 지 썸네일 생성기 보완이 될 지는 저도 모르겠습니다. 아무튼 이번 목표는 마쳤으니 이만 글을 줄이도록 해야겠습니다.\r\n"},{"id":9,"content":"\r\n# 개요\r\n구글 드라이브와 연동하는 것을 제외하면 기본적인 기능은 완성되었습니다. 하지만 자잘한 문제가 하나 있었습니다. 이번 글에서는 이 문제를 해결하고 다음 스텝으로 나아갈 준비를 하려고 합니다.\r\n\r\n# 문제점 파악\r\n자 그럼 어떤 문제가 있었는지 정리해보도록 합시다. 총 두가지의 문제가 있었습니다. 둘 다 이미지 생성과 관련된 문제였습니다. 하나는 텍스트가 아래로 쏠리는 문제였고, 다른 하나는 이미지가 생성됐을 때 정상적으로 생성되지 않는 문제였습니다. 대강 문제에 대해 살펴보고 어떻게 해결했는지 남기려고 합니다.\r\n\r\n## 이미지 생성시 텍스트가 아래로 쏠리는 문제\r\n이 문제는 텍스트를 입력할 때에는 인지를 못하다가 이미지 생성 테스트를 여러번 해보면서 발견한 문제였습니다.\r\n\r\n<Image src='https://drive.google.com/file/d/15fZdM2rXBS7SBEx8fGlXtMs2YfirQtLW/view?usp=drive_link' alt='썸네일 미리보기에는 문제가 없다' drive />\r\n\r\n위 이미지처럼 썸네일 미리보기에는 텍스트가 올바른 위치에 있는데..\r\n\r\n<Image src='https://drive.google.com/file/d/1g0x9xkrSgT1sJdeTI2qtF_U1AxkKFpQT/view?usp=drive_link' alt='생성된 썸네일에 문제가 있다' drive />\r\n\r\n썸네일 이미지가 생성된 결과물은 그렇지가 않았던 것이죠. 잘 보면 텍스트가 미리보기랑 다르게 아래로 내려가 있던 겁니다. 의도한 모습이 아니니까 이대로 넘어갈 수가 없죠. 그래서 이것이 대체 어떤 일인가 하고 계속 검색을 해봤는데 <A href='https://github.com/niklasvh/html2canvas/issues/2775' external>깃허브 이슈</A>에서 단서를 얻었습니다.\r\n\r\n### 해결\r\n\r\n<CodeBlock>\r\n```tsx {8}\r\nconst onClickDownload = useCallback(\r\n  () => {\r\n    window.scrollTo(0, 0);\r\n\r\n    html2canvas(thRef.current, {\r\n      allowTaint: true,\r\n      useCORS: true,\r\n      foreignObjectRendering: true, // 이 부분 추가\r\n    }).then((canvas) => {\r\n      const img = document.createElement('img');\r\n      img.src = canvas.toDataURL('image/png');\r\n\r\n      imageRef.current.innerHTML = '';\r\n      imageRef.current.appendChild(img);\r\n    });\r\n\r\n    setIsClick(true);\r\n  },\r\n  [ thRef, imageRef, ]\r\n);\r\n```\r\n</CodeBlock>\r\n\r\n이 코드는 이미지 생성 버튼을 눌렀을 때 실행되는 함수입니다. 이 코드에서 표시된 부분을 추가했더니 문제가 사라졌습니다. 설정 관련된 문제였던 것 같아요. 사실 구글링하다가 얻어 걸린 느낌도 있긴한데 아무튼 찾았으니 다행이었습니다. 이 프로젝트가 끝나면 구글링하면서 사용방법을 상세히 알아봐야겠습니다.\r\n\r\n## 브라우저 창의 너비에 따라 이미지가 정상적으로 생성되지 않는 문제\r\n설정을 하나 추가해서 텍스트 문제는 해결을 했는데 이렇게 추가를 하니까 문제점이 또 발생했습니다. 색상을 변경하거나 텍스트 값들이 초기값일 때에 이미지가 정상적으로 생성되지 않는 문제였..다고 생각했으나 알고보니 브라우저 창의 너비 때문이었습니다.\r\n\r\n<Image src='https://drive.google.com/file/d/1vJ-IY7ZfkbqrQhDYZiT9hWSXYUbtihJb/view?usp=drive_link' alt='새로운 문제...' drive />\r\n\r\n도저히 무엇이 문제인지 모르겠어서 구글링만 겁나게 했지만 그렇다할 자료는 찾지 못했는데, html2canvas에서 지원하는 로깅 기능을 켜봤습니다.\r\n\r\n<CodeBlock title=''>\r\n```tsx {5}\r\nhtml2canvas(thRef.current, {\r\n  allowTaint: true,\r\n  useCORS: true,\r\n  foreignObjectRendering: true,\r\n  logging: true,\r\n}).then((canvas) => {\r\n  const img = document.createElement('img');\r\n  img.src = canvas.toDataURL('image/png');\r\n  img.style.display = 'block';\r\n\r\n  imageRef.current.innerHTML = '';\r\n  imageRef.current.appendChild(img);\r\n});\r\n```\r\n</CodeBlock>\r\n\r\n이렇게 하면 자동으로 로깅이 되는데 이미지가 생성 될 때마다 로그가 쌓이게 됩니다. 그럼 이제 이미지를 생성해봅시다.\r\n\r\n<Image src='https://drive.google.com/file/d/1oSZdRiz-VeQM7jsyCs0VVAQN5Kf3Vh9T/view?usp=drive_link' alt='문제는 너비였다.' drive />\r\n\r\n이미지를 보면 어떤 상태인지 알 수 있는데, 빨간 사각형으로 표시된 부분에 중요한 정보가 있었습니다. **(1280x720 at 297,0)** 이미지의 해상도가 나타나고, 297과 0은 포지션을 의미하는 것 같습니다. 이 297이 뭘 의미하는 것인가를 알 수가 없어서 몇번을 더 테스트해봤는데 바로 요소의 양 옆 `margin` 값이었습니다.\r\n\r\n`margin` 값이었다는 것을 알게 되었으니 이걸 해결하려면 `margin` 값을 알아내야합니다.\r\n\r\n### 해결\r\nmargin 값을 알아내기 위해서는 일단 페이지의 전체 너비 값을 알아야하고 그 다음에 요소의 너비 값을 알아야 했습니다. 이 부분은 뭐 어렵지 않죠.\r\n\r\n<CodeBlock title=''>\r\n```tsx {3-10, 18}\r\nconst onClickDownload = useCallback(\r\n  () => {\r\n    const bodyWidth = document.documentElement.clientWidth;\r\n    const thRefWidth = thRef.current.clientWidth;\r\n\r\n    let formula: number;\r\n\r\n    if (thRefWidth < bodyWidth) {\r\n      formula = (bodyWidth - thRefWidth) / 2;\r\n    }\r\n\r\n    window.scrollTo(0, 0);\r\n\r\n    html2canvas(thRef.current, {\r\n      allowTaint: true,\r\n      useCORS: true,\r\n      foreignObjectRendering: true,\r\n      x: thRefWidth < bodyWidth ? -formula : 0,\r\n      logging: true,\r\n    }).then((canvas) => {\r\n      const img = document.createElement('img');\r\n      img.src = canvas.toDataURL('image/png');\r\n      img.style.display = 'block';\r\n\r\n      imageRef.current.innerHTML = '';\r\n      imageRef.current.appendChild(img);\r\n    });\r\n\r\n    setIsClick(true);\r\n  },\r\n  [ thRef, imageRef, bgColor, ]\r\n);\r\n```\r\n</CodeBlock>\r\n\r\n3번은 전체 너비입니다. 4번은 요소의 너비입니다. 8-10번은 요소의 너비보다 전체 너비가 클 때에만 전체 너비에서 요소의 너비를 뺀 수의 절반을 가져오는 것이죠. 이게 바로 `margin` 값입니다. 이 `margin` 값을 저장해두고 설정을 하나 더 추가해야합니다.\r\n\r\n18번에 이렇게 설정을 추가한 후에 조건 하에 값을 넣어줍니다. 이렇게 한 후에 다시 이미지를 생성해보면\r\n\r\n<Image src='https://drive.google.com/file/d/15piHmtP_6sU75UHyDw4kSgljtyD5CLZJ/view?usp=drive_link' alt='문제 해결! 이제 다음 스텝으로!' drive />\r\n\r\n매우 잘 생성되는 것을 볼 수 있었습니다. 근데 보시면 아직 자잘한 문제가 하나 더 있는데 생성된 이미지에 하얀 줄이 있는 걸 볼 수 있죠. 이걸 해결하기 위해서 설정을 하나 더 추가해줬습니다. 18번 아래에 다음의 프로퍼티를 넣었습니다.\r\n\r\n<CodeBlock title=''>\r\n```tsx\r\n{\r\n  backgroundColor: `rgb(${bgColor.red}, ${bgColor.green}, ${bgColor.blue})`,\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n# 마치며\r\n금방 끝날 줄 알았던 프로젝트가 자잘한 문제들 때문에 조금 지연되었습니다. 이제 문제는 해결 했으니까 다음 스텝으로 넘어가도 될 것 같습니다. 물론 다음 스텝으로 넘어가기 위해서는 조금의 공사가 필요하겠지만요. 이제 임시로 기능은 완성이 되었으니까 밀려있던 썸네일을 뽑아서 적용하는 일만 남았네요.\r\n\r\n다음은 구글 드라이브와 연동하는 과정인데 역시 천천히 진행해보도록 하겠습니다.\r\n"}]