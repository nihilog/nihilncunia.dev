[{"id":1,"content":"몇년 전에 블로그를 만들어서 포스트를 연재했던 시절이 있었습니다. 개발 블로그였는데 바빠지면서 건드리지 않게 되었죠. 그렇다고 해도 블로그는 결국 필요한 것이었습니다. 그래서 새롭게 시작하기 위해 새로 블로그를 만들었습니다. 이번에도 **NextJS**를 이용해서 만든 블로그인데 저번에 만들었던 블로그보다는 좀 더 블로그다운 기능에 치중하고자 했습니다.\r\n\r\n이전 블로그에서 작성했던 글들을 다 옮겨올까 생각도 했지만 수도 많고 바꿔야 할 것들도 많아서 그것은 포기하고 그냥 새롭게 시작하기로 했으니 처음부터 글을 작성해보려고 합니다. 이 블로그의 존재의의는 간단합니다. 코딩 초보 입장에서 코딩 초보들에게 지금까지 배운 지식을 공유하는 것과 앞으로 알게 될 것들을 기록하는 것입니다. 그리고 간간히 진행할 수도 있는 토이 프로젝트 등의 과정을 기록하는 것도 가능할 듯합니다.\r\n\r\n새로 시작하는 시점에서 가장 먼저 해야 할 것은 간단하게 썸네일을 생성하는 프로그램과 제가 할 일을 기록할 수 있는 투두리스트를 손수 구현하고자 합니다. 심심하니까요. 아무튼 이 블로그를 찾는 몇몇 분들에게 적지 않은 도움이 되었으면 합니다.\r\n"},{"id":2,"content":"\r\n# 개요\r\n첫 번째 글에서 예고했던 대로 썸네일 생성기를 만들어 보려고 합니다. 솔직히 이미 답은 정해져 있는 것 같지만 어떤 스택을 활용할 것인지 생각해 본 후에 개발을 위한 구상 작업을 하려고 합니다. 이번 글에서는 기능에 대해 구상하고 활용 기술 스택에 대해서 구상을 해보는 시간을 가져봅니다.\r\n\r\n완성까지 얼마나 걸릴지, 그리고 몇편의 글이 작성되어야 완성할 수 있을지 모르겠지만 일단 시작해보도록 합시다!\r\n\r\n# 기술 스택\r\n\r\n- NextJS(리액트, 라우팅)\r\n- TailwindCSS & Emotion\r\n- Googleapis\r\n\r\n## NextJS(리액트, 라우팅)\r\n기술 스택은 사실 전부 정해져 있습니다. HTML, CSS, JS가 기본적으로 사용되기 때문에 리액트를 사용하지 않을 수가 없죠. 이번 토이 프로젝트는 **NextJS**를 이용해서 만들려고 합니다. 단일 페이지라면 굳이 **NextJS**가 필요 없겠지만 단일 페이지로 만들지는 않을 것이기 때문에 **NextJS**를 사용하려고 합니다.\r\n\r\n## TailwindCSS & Emotion\r\n이 두가지는 스타일링을 위한 라이브러리입니다. <A href='https://emotion.sh/docs/introduction' external>Emotion</A>은 <A href='https://styled-components.com/' external>StyledComponents</A>처럼 리액트 내에서 스타일이 적용된 컴포넌트를 만들 수도 있고 CSS 규칙을 컴포넌트에 적용하는 방법도 사용할 수 있는 편리한 라이브러리입니다.\r\n\r\n<A href='https://tailwindcss.com/' external>TailwindCSS</A> 또한 유명하죠. 부트스트랩처럼 클래스이름을 입력하면 스타일이 적용되는 아주 편리한 스타일시트 프레임워크입니다. 저는 이 두가지를 합쳐서 사용합니다. 설정은 다소 필요하지만 그 설정만 하면 좀 더 편리하게 두가지 라이브러리를 사용할 수 있습니다.\r\n\r\nTailwindCSS의 경우에는 클래스 이름으로 스타일링을 하기 때문에 복잡한 스타일의 경우에는 클래스가 길어지는 안타까운 현상이 존재합니다. 하지만 이 두가지를 합치게 되면 그 문제가 많이 해소됩니다. 두가지 라이브러리를 합치는 방법은 <A href='https://github.com/ben-rogerson/twin.macro' external>twin.macro</A>를 사용하는 것입니다.\r\n\r\n## Googleapis\r\n이미지를 생성하면 구글 드라이브에 업로드를 하고, 그 주소를 가져와서 관리할 수 있는 시스템을 구현하려고 합니다. 그래서 필요한 것은 구글 API를 사용하는 것입니다. 최근 회사에서 구글 API를 이용해서 업무를 진행한 적이 있는데 그때는 리액트로 한 것이 아니었고 이번에는 리액트로 진쟁해보고 싶었습니다.\r\n\r\n어차피 포스트도 작성해야하니까 구글 클라우드 콘솔에서 클라이언트 키를 받는 것부터 라이브러리를 활용해 토큰을 받아 활용하는 것까지 전부 포스트에 담아낼 예정입니다.\r\n\r\n# 기능 구상\r\n일단 다른 것보다도 제가 썸네일을 만들기 위해서 진행하는 부분도 있기 때문에 제가 편해야합니다. 그 다음에 다른 기능들도 추가하는 것이 좋을 듯합니다. 기본적으로 해상도는 1280\\*720으로 생각하고 있습니다.\r\n\r\n- 제목과 부제 입력하기\r\n- 단색 배경, 이미지 배경 지원\r\n- 사용자 구글 드라이브 연동\r\n\r\n## 제목과 부제 입력하기\r\n썸네일에 텍스트는 반드시 필요합니다. 썸네일이라고 해서 단순히 이미지만 있어서는 이게 어떤 글인지 전혀 알 수가 없기 때문입니다. 때문에 텍스트는 입력할 수 있어야합니다. 이 때 간편하게 폼 요소를 컨트롤 할 수 있도록 <A href='https://www.react-hook-form.com/' external>react-form-hook</A>을 사용하려고 합니다.\r\n\r\n## 단색 배경, 이미지 배경 지원\r\n단색 배경은 기본으로 제공하고 이미지 배경을 원할 시에는 이미지를 가져와서 설정할 수 있도록 개발할 생각입니다. 이미지가 들어가면 제목이나 다른 텍스트들이 잘 안보일 수 있기 때문에 잘 보일 수 있게끔 추가적으로 처리하는 것도 생각해봐야합니다.\r\n\r\n단색의 경우에는 사용자가 원하는 색상을 선택할 수 있도록 RGB 값을 입력하게 할 예정입니다.\r\n\r\n## 사용자 구글 드라이브와의 연동\r\n위에서 언급했듯이 구글 드라이브에 이미지를 업로드 할 수 있는 기능까지 제공할 예정입니다. 구글 드라이브인 이유는 제가 이미지 호스팅을 구글 드라이브에 하고 있기 때문이죠 하하. 이미 저장한 이미지를 관리한다고 해서 수정할 수 있는 것은 아닙니다. 아마도요..?\r\n\r\n이미지를 업로드 할 때에는 사용자가 폴더를 선택하는 것이 아니라 업로드 할 때부터 썸네일 생성기가 지정한 폴더에 업로드 되게 할 것입니다. 이런 부분도 나중에 살펴보도록 합시다.\r\n\r\n# 간략한 화면에 대한 구상\r\n자 그럼 마지막으로 화면에 대한 구상을 해보도록 해야겠습니다. 아주 간단하게 어떤 블럭들이 위치할지 레이아웃을 잡아보려고 합니다. 이미지 관리 페이지는 나중으로 미뤄두고 일단은 썸네일을 생성하는 메인 페이지부터 생각해봐야합니다.\r\n\r\n<Image src='https://drive.google.com/file/d/1xjTBjwOhyFgE0xxgOlie_gF_E4oLPvUL/view?usp=drive_link' alt='화면 와이어 프레임' drive />\r\n\r\n간단하게 Low-Fi 와이어 프레임을 만들어봤습니다. 상단의 제일 큰 부분은 이미지가 될 부분이고 그 아래에는 제목과 부제가 들어갈 텍스트입니다. 텍스트의 아래에는 이제 탭이 들어올 자리인데 단색 배경이냐 이미지 배경이냐에 따라서 다르게 보일 부분입니다. 대략적으로 이런 그림.. 일 것 같은데 또 하다가 바뀔 수도 있을 듯합니다.\r\n\r\n자 이제 대략적인 구상은 끝났으니까 본격적으로 작업을 하는 것은 다음 글부터인 것으로 결정하고 이번 글은 여기서 마무리 하겠습니다.\r\n"},{"id":3,"content":"\r\n# 개요\r\n저번 시간에는 썸네일 생성기에 대한 기본적인 구상을 해봤습니다. 사용할 기술 스택도 정해졌고 아주 대략이지만 어떤 화면을 구성해볼지도 간단하게 정해봤습니다. 이번 글에서는 개발을 위한 환경을 구성하고 구상한 화면을 만들어보도록 하겠습니다.\r\n\r\n저는 제가 프로젝트를 할 때마다 사용하는 템플릿이 따로 있는데 이번에는 그걸 사용하기보다는 처음부터 환경을 만들어보려고 합니다. 그럼 시작해봅시다.\r\n\r\n# `create-next-app`을 통한 개발환경 구축\r\n<CodeBlock title=''>\r\n```bash\r\nyarn create next-app thumbnail-generator\r\n```\r\n</CodeBlock>\r\n\r\n가장 먼저 `create-next-app`을 이용해서 **NextJS** 프로젝트를 만들어줍니다. 저같은 경우는 이 도구를 사용하지 않고 하나 하나 만들었었는데 요즘에는 그냥 이런 도구를 사용하는 것이 더 효율적이라서 사용하자라고 생각하는 중입니다.\r\n\r\n<Image src='https://drive.google.com/file/d/1qJZXr-e8JH9cyc6gcZcy_-NtfqTwtORS/view?usp=drive_link' alt='create-next-app 설정 화면' drive />\r\n\r\n필요한 것을 알아서 설정을 해주면 됩니다. 저는 여기 설정을 전부 사용하기 때문에 전부 Yes로 설정했습니다. 사실 이런 도구를 사용하면 바로 사용할 수 있습니다. **TailwindCSS**와 **Emotion**을 연동하기만 하면 말이죠. 그 외에도 자잘한 설정을 좀 해야합니다. 여기서부터 그냥 진행하고 싶다면 `yarn run dev` 혹은 `npm run dev` 를 실행해서 NextJS 서버를 실행해도 됩니다.\r\n\r\nNextJS는 pages 라우트와 app 라우트가 있는데 저는 항상 pages 라우트를 사용하기 때문에 이번에도 pages 라우트로 가도록 하겠습니다. 이 두가지가 어떤 차이가 있는지는 NextJS에 대한 포스트를 작성할 때 제대로 해보도록 하고 지금은 설정을 마저 진행하도록 하겠습니다.\r\n\r\n# Emotion 설정하기\r\nTailwindCSS는 설치가 되어있지만 Emotion은 직접 설치를 해야합니다. twin.macro도 같이 설치해주도록 합시다.\r\n\r\n<CodeBlock title=''>\r\n```bash\r\nyarn add @emotion/react @emotion/styled @emotion/serialize\r\nyarn add -D twin.macro babel-loader @emotion/babel-plugin babel-plugin-macros @babel/plugin-syntax-typescript @babel/preset-react @svgr/webpack\r\nyarn add -D @babel/core babel-plugin-macros @emotion/babel-plugin @emotion/babel-preset-css-prop\r\n```\r\n</CodeBlock>\r\n\r\nEmotion과 관련된 패키지들입니다. 전부 설치를 한 후에 설정을 진행해봅시다. 먼저 루트 폴더에 `.babelrc.js` 파일을 만들어서 바벨 관련된 설정을 하면서 twin.macro 설정을 해줄 겁니다.\r\n\r\n<CodeBlock title='.babelrc.js'>\r\n```js\r\nmodule.exports = {\r\n  presets: [\r\n    [\r\n      'next/babel',\r\n      {\r\n        'preset-react': {\r\n          runtime: 'automatic',\r\n          importSource: '@emotion/react',\r\n        },\r\n      },\r\n    ],\r\n  ],\r\n  plugins: [\r\n    '@emotion/babel-plugin',\r\n    'babel-plugin-macros',\r\n    [\r\n      '@babel/plugin-syntax-typescript',\r\n      { isTSX: true },\r\n    ],\r\n  ],\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n이렇게 해주면 NextJS가 실행될 때 알아서 바벨 설정을 이 내용으로 덮어씌워줍니다.\r\n\r\n# 타입스크립트 관련 설정하기\r\n루트폴더에 `twin.d.ts` 파일을 만들거나 `src/types` 폴더를 만들어서 그 안에 이 파일을 만들거나 원하는대로 진행하시면 되는데 `twin.d.ts`의 내용물은 아래와 같아야 합니다.\r\n\r\n<CodeBlock title='twin.d.ts'>\r\n```ts\r\nimport 'twin.macro';\r\nimport { css as cssImport } from '@emotion/react';\r\nimport { CSSInterpolation } from '@emotion/serialize';\r\nimport styledImport from '@emotion/styled';\r\n\r\ndeclare module 'twin.macro' {\r\n  // The styled and css imports\r\n  // eslint-disable-next-line no-unused-vars\r\n  const styled: typeof styledImport;\r\n  // eslint-disable-next-line no-unused-vars\r\n  const css: typeof cssImport;\r\n}\r\n\r\ndeclare module 'react' {\r\n  // The css prop\r\n  // eslint-disable-next-line no-unused-vars\r\n  interface HTMLAttributes<T> extends DOMAttributes<T> {\r\n    css?: CSSInterpolation\r\n  }\r\n  // The inline svg css prop\r\n  // eslint-disable-next-line no-unused-vars\r\n  interface SVGProps<T> extends SVGProps<SVGSVGElement> {\r\n    css?: CSSInterpolation\r\n  }\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n`SVGProps` 부분은 없어도 됩니다. 저는 `svg` 파일도 즐겨쓰다보니 넣어둔 것이므로 무시하셔도 무방합니다. 이렇게 만든 파일을 적용해야하는데 루트 폴더 안에 있는 `tsconfig.json` 파일에서 아래의 내용들을 추가해주면 됩니다.\r\n\r\n<CodeBlock title='tsconfig.json'>\r\n```json {11, 36}\r\n{\r\n  \"compilerOptions\": {\r\n    \"target\": \"es5\",\r\n    \"lib\": [\r\n      \"dom\",\r\n      \"dom.iterable\",\r\n      \"esnext\"\r\n    ],\r\n    \"allowJs\": true,\r\n    \"skipLibCheck\": true,\r\n    \"strict\": false,\r\n    \"noEmit\": true,\r\n    \"esModuleInterop\": true,\r\n    \"module\": \"esnext\",\r\n    \"moduleResolution\": \"bundler\",\r\n    \"resolveJsonModule\": true,\r\n    \"isolatedModules\": true,\r\n    \"jsx\": \"preserve\",\r\n    \"incremental\": true,\r\n    \"plugins\": [\r\n      {\r\n        \"name\": \"next\"\r\n      }\r\n    ],\r\n    \"paths\": {\r\n      \"@/*\": [\r\n        \"./src/*\"\r\n      ]\r\n    }\r\n  },\r\n  \"include\": [\r\n    \"next-env.d.ts\",\r\n    \"**/*.ts\",\r\n    \"**/*.tsx\",\r\n    \".next/types/**/*.ts\",\r\n    \"**/*.d.ts\"\r\n  ],\r\n  \"exclude\": [\r\n    \"node_modules\"\r\n  ]\r\n}\r\n```\r\n</CodeBlock>\r\n\r\nEmotion과 TailwindCSS를 아주 유연하게 사용할 수 있게 됩니다.\r\n\r\n# next.config.js 설정하기\r\n<CodeBlock title='next.config.js'>\r\n```js\r\n/** @type {import('next').NextConfig} */\r\nconst config = {\r\n  swcMinify: false,\r\n  eslint: {\r\n    dirs: [],\r\n  },\r\n  typescript: {\r\n    ignoreBuildErrors: true,\r\n  },\r\n  images: {\r\n    domains: [ '여기에 도메인', ],\r\n  },\r\n  experimental: {\r\n    largePageDataBytes: 128 * 100000,\r\n  },\r\n  webpack(config) {\r\n    config.module.rules.push({\r\n      test: /\\.svg$/,\r\n      use: [ '@svgr/webpack', ],\r\n    });\r\n    return config;\r\n  },\r\n};\r\n\r\nmodule.exports = config;\r\n```\r\n</CodeBlock>\r\n\r\n`swcMinify`는 true로 해두면 가끔 에러를 만나서 그냥 false로 설정해서 꺼두는 편인데 자유롭게 하시면 됩니다. 사실 저 설정들은 그냥 여러분이 원하는대로 설정하면 됩니다. 이 설정은 저에게 최적화된 설정들입니다.\r\n\r\n# ESLint 설정\r\nESLint는 개발을 하는데에 있어서 빠질 수 없는 요소중 하나입니다. 코드의 규칙을 설정할 수 있고 그 규칙에 맞지 않는 코드가 있으면 빨간색으로 에러 표시를 띄워줍니다. 타입스크립트랑 같이 사용하면 더할나위 없이 좋습니다.\r\n\r\n설정을 하기에 앞서 설치해야 하는 패키지들이 있습니다.\r\n\r\n<CodeBlock title=''>\r\n```bash\r\nyarn add -D eslint eslint-config-airbnb eslint-plugin-html eslint-plugin-react eslint-plugin-import eslint-plugin-react-hooks eslint-plugin-jsx-a11y @typescript-eslint/eslint-plugin @typescript-eslint/parser\r\n```\r\n</CodeBlock>\r\n\r\n설치를 한 다음에 `.eslintrc.js` 파일을 수정해주면 됩니다.\r\n\r\n<CodeBlock title='.eslintrc.js'>\r\n```js\r\nmodule.exports = {\r\n  root: true,\r\n  env: {\r\n    browser: true,\r\n    commonjs: true,\r\n    node: true,\r\n    es2021: true,\r\n  },\r\n  parser: '@typescript-eslint/parser',\r\n  extends: [\r\n    'airbnb',\r\n    'airbnb/hooks',\r\n    'plugin:import/errors',\r\n    'plugin:import/warnings',\r\n    'eslint:recommended',\r\n    'plugin:react/recommended',\r\n    'plugin:@typescript-eslint/recommended',\r\n  ],\r\n  parserOptions: {\r\n    ecmaVersion: 2021,\r\n    sourceType: 'module',\r\n    ecmaFeatures: {\r\n      jsx: true,\r\n    },\r\n  },\r\n  plugins: [ '@typescript-eslint', 'import', 'react', 'react-hooks', 'html', ],\r\n  rules: {\r\n    // 일반 규칙 ...\r\n    // 임포트 규칙 ...\r\n    // 타입스크립트 규칙 ...\r\n    // 리액트 규칙 ...\r\n    // 리액트 훅스 규칙 ...\r\n    // jsx 규칙 ...\r\n  },\r\n};\r\n```\r\n</CodeBlock>\r\n\r\n제가 리액트를 사용할 때면 항상 사용하는 규칙입니다. 코드 설정 때문에 글이 길어지는 것처럼 보이지만 사실은 정말 별거 아닌 내용인게 참 재밌는 것 같네요.\r\n\r\n# Tailwind 설정하기\r\n\r\n아무튼 이제 마지막입니다. TailwindCSS 설정을 해야됩니다.\r\n\r\n기본적인 것은 이미 되어있는 상태입니다. 루트 폴더 아래에 있는 `tailwind.config.js` 파일을 내키는대로 꾸며주면 됩니다! 저같은 경우는 다른 건 그렇다 치고 의사 클래스 부분과 미디어 쿼리를 편하게 사용하기 위해서 아래처럼 설정해두었습니다.\r\n\r\n<CodeBlock title='tailwind.config.js'>\r\n```js\r\nconst plugin = require('tailwindcss/plugin');\r\n\r\n/** @type {import('tailwindcss').Config} */\r\nmodule.exports = {\r\n  darkMode: 'class',\r\n  content: [\r\n    './src/components/**/*.{js,ts,jsx,tsx}',\r\n    './src/layouts/**/*.{js,ts,jsx,tsx}',\r\n    './src/pages/**/*.{js,ts,jsx,tsx}',\r\n  ],\r\n  theme: {\r\n    extend: {\r\n      // ...\r\n      screens: {\r\n        'mf-sm': { min: '480px', },\r\n        'mf-md': { min: '768px', },\r\n        'mf-lg': { min: '1024px', },\r\n      },\r\n      // ...\r\n    },\r\n  },\r\n  plugins: [\r\n    require('@tailwindcss/typography'),\r\n    plugin(({ addVariant, }) => {\r\n      addVariant('first', [ '&:first-of-type', ]);\r\n      addVariant('last', [ '&:last-of-type', ]);\r\n      addVariant('not-first', [ '&:not(:first-of-type)', ]);\r\n      addVariant('not-last', [ '&:not(:last-of-type)', ]);\r\n      addVariant('hocus', [ '&:hover', '&:focus', ]);\r\n      addVariant('nth-1', '&:nth-of-type(1)');\r\n      addVariant('nth-2', '&:nth-of-type(2)');\r\n      addVariant('nth-3', '&:nth-of-type(3)');\r\n      addVariant('nth-4', '&:nth-of-type(4)');\r\n      addVariant('nth-5', '&:nth-of-type(5)');\r\n      addVariant('nth-last-1', '&:nth-last-of-type(1)');\r\n      addVariant('nth-last-2', '&:nth-last-of-type(2)');\r\n      addVariant('nth-last-3', '&:nth-last-of-type(3)');\r\n      addVariant('nth-last-4', '&:nth-last-of-type(4)');\r\n      addVariant('nth-last-5', '&:nth-last-of-type(5)');\r\n    }),\r\n  ],\r\n};\r\n```\r\n</CodeBlock>\r\n\r\n저는 반응형을 만들때 모바일 퍼스트를 주로 사용하기 때문에 저런 순서로 설정을 했고 플러그인 같은 경우에는 의사 클래스를 추가해줄 수 있습니다. 자주 사용할 것 같은 것들만 모아다가 이렇게 설정을 해둔 상태입니다.\r\n\r\n그리고 TailwindCSS의 기본 css 파일도 조금 수정하겠습니다.\r\n\r\n<CodeBlock title='global.css'>\r\n```css {7}\r\n@import url(https://fonts.googleapis.com/earlyaccess/notosanskr.css);\r\n@import url(https://fonts.cdnfonts.com/css/cascadia-code);\r\n\r\n@tailwind base;\r\n@tailwind components;\r\n@tailwind utilities;\r\n@tailwind variants;\r\n```\r\n</CodeBlock>\r\n\r\n7번..이 맞았을겁니다. 아무튼 저 네가지가 다 있으면 됩니다. 이렇게 하면 정말로 모든 설정이 끝난겁니다. 설정이 잘 적용되었는지 이제 `next dev`를 통해서 서버를 한 번 실행시켜봅시다.\r\n\r\n# 첫 실행\r\n\r\n<CodeBlock title=''>\r\n```bash\r\nyarn run dev\r\n```\r\n</CodeBlock>\r\n\r\n<Image src='https://drive.google.com/file/d/1tW2IOONEvuq29exxKPrrwqt8Ped23Wj9/view?usp=drive_link' alt='vscode 상에서의 index.tsx 파일 화면' drive />\r\n\r\n<Image src='https://drive.google.com/file/d/1lKVbUAAqab18mn5y8glIsaxWNrzH0pFa/view?usp=drive_link' alt='홈페이지' drive />\r\n\r\nNextJS는 app 라우트 혹은 pages 라우트를 사용하고 여기서는 pages 라우트를 사용하니까 pages 라우트의 관점에서 보도록 하겠습니다. `pages` 폴더 안의 파일들이 하나 하나의 페이지라고 생각하면 됩니다. `index.tsx` 파일은 NextJS로 만들 사이트의 홈 페이지가 되는 것입니다.\r\n\r\n즉 `index.tsx`의 내용이 `localhost:3000` 페이지에 띄워지는 것이죠. 파일을 보면 아시겠지만 className에 덕지 덕지 붙어있는 게 바로 TailwindCSS의 스타일링 방식 입니다. 이런식으로 스타일링을 하면 편하기야 하겠지만 정말 보기에 안좋죠. 이걸 해소할 수 있는 게 바로 twin.macro인 것입니다.\r\n\r\n# twin.macro 사용해보기\r\ntwin.macro를 사용한다는 것은 사실 별 거 없습니다. 그냥 Emotion이랑 TailwindCSS를 같이 사용하는 것이니까요. 테스트를 위해서 `index.tsx`의 태그들을 전부 밀어버리고 다시 작성해보겠습니다.\r\n\r\n<CodeBlock title='index.tsx'>\r\n```tsx\r\nimport React from 'react';\r\n\r\nexport default function index() {\r\n  return (\r\n    <>\r\n      <div>Hello World!!</div>\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n<Image src='https://drive.google.com/file/d/1l_PnkA-8mcnGgSbZxNfkyo3f-aNLL0qW/view?usp=drive_link' alt='아무런 스타일이 없는 모습' drive />\r\n\r\n이제 새로운 방식으로 스타일링을 진행할 겁니다. **StyledComponents**나 **Emotion**을 사용한 분이라면 아래처럼 스타일링을 하실겁니다. 스타일드 컴포넌트를 만들던가 css 프로퍼티에 스타일을 전달하던가 하는 식으로 말이죠. 이게 바로 **CSS in JS**의 편리한 점이었죠.\r\n\r\n<CodeBlock title='index.tsx'>\r\n```tsx\r\nimport React from 'react';\r\nimport { css, styled } from 'twin.macro';\r\n\r\nconst StyledDiv = styled.div`\r\n  font-family: 'Noto Sans KR', sans-serif;\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  font-size: 2rem;\r\n  color: white;\r\n  background-color: #333333;\r\n  padding: 12px;\r\n`;\r\n\r\nexport default function index() {\r\n  const style = (css`\r\n    font-family: 'Noto Sans KR', sans-serif;\r\n    display: flex;\r\n    align-items: center;\r\n    justify-content: center;\r\n    font-size: 2rem;\r\n    color: white;\r\n    background-color: #333333;\r\n    padding: 12px;\r\n  `);\r\n\r\n  return (\r\n    <>\r\n      <div css={style}>Hello World!!</div>\r\n      <br />\r\n      <StyledDiv>Hello World!!</StyledDiv>\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n<Image src='https://drive.google.com/file/d/1jpwecuQgDKpI_nW9vhbs9m4dERUkkYsY/view?usp=drive_link' alt='emotion의 스타일링 방식' drive />\r\n\r\n좀 더 편리하게 스타일링을 할 수 있습니다. 바로 TailwindCSS를 섞어서 말이죠. twin.macro에는 `tw`라는 함수가 제공되는데 Emotion의 css처럼 사용할 수 있습니다. 여기에는 TailwindCSS의 클래스명들이 들어갑니다. 위와 똑같은 스타일을 만들어봅시다.\r\n\r\n<CodeBlock title='index.tsx'>\r\n```tsx\r\nimport React from 'react';\r\nimport tw from 'twin.macro';\r\n\r\nexport default function index() {\r\n  const style = tw` font-sans flex items-center justify-center text-[2rem] text-white bg-black-base p-3 `;\r\n\r\n  return (\r\n    <>\r\n      <div css={style}>Hello World!!</div>\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n<Image src='https://drive.google.com/file/d/1oEzfWJnYGf1VOA_AqQkUrvxoJw9gwy6M/view?usp=drive_link' alt='twin.macro를 사용하면 지저분한 클래스들을 안봐도 된다' drive />\r\n\r\n이런식으로 사용할 수가 있습니다. 저는 이걸 응용해서 객체 형식으로 스타일을 만듭니다. 그럼 이제 기본적인 기능에 대해서는 알아봤으니까 썸네일 생성기라는 주제에 맞는 개발을 시작해봅시다.\r\n\r\n# 썸네일 생성기 레이아웃 잡기\r\n저번에 만들어놓은 와이어 프레임을 어느정도 참고해서 거창한 스타일은 입히지 않은 상태의 레이아웃만 대충 잡아보도록 합시다. 기능적인 부분은 차차 잡아가기로 하고 일단은 있을 수 있는 부분만 만들어보겠습니다.\r\n\r\n<CodeBlock title='index.tsx'>\r\n```tsx\r\nimport React from 'react';\r\n\r\nexport default function index() {\r\n  return (\r\n    <>\r\n      <div>\r\n        <div />\r\n        <input type='text' id='title' placeholder='제목' />\r\n        <input type='text' id='sub-title' placeholder='부제' />\r\n\r\n        <div>\r\n          <div>단색 배경</div>\r\n          <div>이미지 배경</div>\r\n        </div>\r\n\r\n        <div>\r\n          <input type='range' min={0} max={255} defaultValue={50} id='hex-red' />\r\n          <input type='range' min={0} max={255} defaultValue={50} id='hex-blue' />\r\n          <input type='range' min={0} max={255} defaultValue={50} id='hex-green' />\r\n        </div>\r\n\r\n        <div>\r\n          <input type='text' id='image-src' placeholder='이미지 주소를 입력하세요' />\r\n        </div>\r\n\r\n        <div>\r\n          <button>초기화</button>\r\n          <button>이미지로 저장</button>\r\n        </div>\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n<Image src='https://drive.google.com/file/d/10Z6j06_tjhjeZqyEae0rmuIbL_uJHL2U/view?usp=drive_link' alt='스타일링하기 전의 레이아웃' drive />\r\n\r\n이미지로 변환할 부분과 제목, 부제 입력란들. 배경 설정 등등의 기능을 수행할 수 있는 레이아웃입니다. TailwindCSS 특성상 초기화가 심할 정도로 되어있어서 초기 디자인들이 존재하지 않습니다. 간단하게 디자인을 입혀보도록 합시다.\r\n\r\n<CodeBlock title='index.tsx'>\r\n```tsx\r\nimport React from 'react';\r\nimport tw, { css } from 'twin.macro';\r\n\r\nexport default function index() {\r\n  const style = {\r\n    default: css([\r\n      tw` w-[1280px] mx-auto `,\r\n    ]),\r\n    frame: css([\r\n      tw` box-content border border-black-base aspect-video mb-10 `,\r\n    ]),\r\n    input: css([\r\n      tw` p-2 text-normal text-blue-600 placeholder:text-blue-400 block bg-blue-50 w-full border border-blue-500 `,\r\n    ]),\r\n    colors: tw` flex mt-10 `,\r\n    colorTab: css([\r\n      tw` [&[data-selected=\"true\"]]:( p-3 flex-1 shrink-0 border border-black-300 border-b-0 bg-white text-black-base text-center ) `,\r\n      tw` [&[data-selected=\"false\"]]:( p-3 flex-1 shrink-0 border border-black-300 border-b-0 bg-black-300 text-black-600 text-center ) `,\r\n    ]),\r\n    colorTabBottom: css([\r\n      tw` border border-black-300 border-t-0 p-3 bg-white mb-10 `,\r\n    ]),\r\n    buttons: css([\r\n      tw` flex gap-5 `,\r\n      tw` [button]:( flex-1 shrink-0 bg-blue-400 text-white p-3 hover:( bg-blue-600 ) ) `,\r\n    ]),\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <div css={style.default}>\r\n        <div css={style.frame} />\r\n        <input type='text' id='title' placeholder='제목' css={style.input} />\r\n        <input type='text' id='sub-title' placeholder='부제' css={style.input} />\r\n\r\n        <div css={style.colors}>\r\n          <button css={style.colorTab} data-selected='true'>단색 배경</button>\r\n          <button css={style.colorTab} data-selected='false'>이미지 배경</button>\r\n        </div>\r\n\r\n        <div css={style.colorTabBottom}>\r\n          <input type='range' min={0} max={255} defaultValue={50} id='hex-red' />\r\n          <input type='range' min={0} max={255} defaultValue={50} id='hex-blue' />\r\n          <input type='range' min={0} max={255} defaultValue={50} id='hex-green' />\r\n        </div>\r\n\r\n        <div css={style.colorTabBottom}>\r\n          <input type='text' id='image-src' placeholder='이미지 주소를 입력하세요' css={style.input} />\r\n        </div>\r\n\r\n        <div css={style.buttons}>\r\n          <button>초기화</button>\r\n          <button>이미지로 저장</button>\r\n        </div>\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n<Image src='https://drive.google.com/file/d/1nd5It5wng6RPBqBhtOgqzFLYHL78IQgs/view?usp=drive_link' alt='대충 스타일링한 상태의 레이아웃' drive />\r\n\r\n대충 꾸민 것이지만 이제부터 디테일을 높이고 기능을 채워가면 됩니다. 이제 이 화면을 점점 발전시켜나갈 겁니다. 코드 설명을 하고 이것 저것 하느라 글이 많이 길어졌네요 여기서 끊고 다음 글부터 계속 이어서 진행하도록 하겠습니다.\r\n"},{"id":4,"content":"\r\n# 개요\r\n이번 글에서는 썸네일에 들어갈 텍스트를 구현할겁니다. 사용자가 제목과 부제를 입력하면 혹은 제목만 입력을 하면 입력한 내용이 썸네일에 적용되게끔 만드는 것이죠.\r\n\r\n그럼 바로 시작해보도록 합시다.\r\n\r\n# 텍스트 입력 구현\r\n그 전에 지금까지 진행한 부분에 대해서 간략하게 넘어가도록 하겠습니다. 코드는 길기때문에 접어두도록 하겠습니다. 보고 싶으면 펼쳐서 보시면 됩니다.\r\n\r\n<CodeBlock title='index.tsx' fold>\r\n```jsx\r\nimport React from 'react';\r\nimport tw, { css } from 'twin.macro';\r\n\r\nexport default function index() {\r\n  const style = {\r\n    default: css([\r\n      tw` w-[1280px] mx-auto `,\r\n    ]),\r\n    frame: css([\r\n      tw` box-content border border-black-base aspect-video mb-10 `,\r\n    ]),\r\n    input: css([\r\n      tw` p-2 text-normal text-blue-600 placeholder:text-blue-400 block bg-blue-50 w-full border border-blue-500 `,\r\n    ]),\r\n    colors: tw` flex mt-10 `,\r\n    colorTab: css([\r\n      tw` [&[data-selected=\"true\"]]:( p-3 flex-1 shrink-0 border border-black-300 border-b-0 bg-white text-black-base text-center ) `,\r\n      tw` [&[data-selected=\"false\"]]:( p-3 flex-1 shrink-0 border border-black-300 border-b-0 bg-black-300 text-black-600 text-center ) `,\r\n    ]),\r\n    colorTabBottom: css([\r\n      tw` border border-black-300 border-t-0 p-3 bg-white mb-10 `,\r\n    ]),\r\n    buttons: css([\r\n      tw` flex gap-5 `,\r\n      tw` [button]:( flex-1 shrink-0 bg-blue-400 text-white p-3 hover:( bg-blue-600 ) ) `,\r\n    ]),\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <div css={style.default}>\r\n        <div css={style.frame} />\r\n        <input type='text' id='title' placeholder='제목' css={style.input} />\r\n        <input type='text' id='sub-title' placeholder='부제' css={style.input} />\r\n\r\n        <div css={style.colors}>\r\n          <button css={style.colorTab} data-selected='true'>단색 배경</button>\r\n          <button css={style.colorTab} data-selected='false'>이미지 배경</button>\r\n        </div>\r\n\r\n        <div css={style.colorTabBottom}>\r\n          <input type='range' min={0} max={255} defaultValue={50} id='hex-red' />\r\n          <input type='range' min={0} max={255} defaultValue={50} id='hex-blue' />\r\n          <input type='range' min={0} max={255} defaultValue={50} id='hex-green' />\r\n        </div>\r\n\r\n        <div css={style.colorTabBottom}>\r\n          <input type='text' id='image-src' placeholder='이미지 주소를 입력하세요' css={style.input} />\r\n        </div>\r\n\r\n        <div css={style.buttons}>\r\n          <button>초기화</button>\r\n          <button>이미지로 저장</button>\r\n        </div>\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n<Image src='https://drive.google.com/file/d/1nd5It5wng6RPBqBhtOgqzFLYHL78IQgs/view?usp=drive_link' alt='대충 스타일링한 상태의 레이아웃' drive />\r\n\r\n각 부분을 대충 만들어두고 마쳤었는데요. 이번 글부터 보완을 하면서 진행할겁니다. 디자인도 조금씩 개선을 하고 기능을 붙여 나갈거에요. 일단 첫번째 파트에서 우리가 주목할 부분은 썸네일이 위치할 `div`와 두개의 텍스트입니다. 그럼 진행해보도록 합시다.\r\n\r\n## `input` 컨트롤하기\r\n저는 `input`을 컨트롤 하기 위해서 **react-form-hook**을 사용할까 생각도 했었는데 그냥 순수하게 구현을 해보려고 합니다. `input`을 컨트롤 하는 이유는 `input`의 `value`를 **state**로 관리를 해야하기 때문입니다. 리액트에서는 그런식으로  관리를 해야합니다.\r\n\r\n<CodeBlock title='index.tsx'>\r\n```tsx {1-17, 29-30, 37-38}\r\nexport default function IndexPage() {\r\n  const [ title, setTitle, ] = useState('제목을 입력하세요.');\r\n  const [ subTitle, setSubTitle, ] = useState('부제');\r\n\r\n  const onChangeTitle = useCallback(\r\n    (event: ChangeEvent<HTMLInputElement>) => {\r\n      setTitle(event.target.value);\r\n    },\r\n    []\r\n  );\r\n\r\n  const onChangeSubTitle = useCallback(\r\n    (event: ChangeEvent<HTMLInputElement>) => {\r\n      setSubTitle(event.target.value);\r\n    },\r\n    []\r\n  );\r\n\r\n  // ...\r\n\r\n  return (\r\n    <>\r\n      <div css={style.default}>\r\n        {/* ... */}\r\n        <input\r\n          type='text'\r\n          id='title'\r\n          placeholder='제목'\r\n          value={title}\r\n          onChange={onChangeTitle}\r\n          css={style.input}\r\n        />\r\n        <input\r\n          type='text'\r\n          id='sub-title'\r\n          placeholder='부제'\r\n          value={subTitle}\r\n          onChange={onChangeSubTitle}\r\n          css={style.input}\r\n        />\r\n        {/* ... */}\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n<Image src='https://drive.google.com/file/d/1FBcryAEwNd5Cc398JRsWX908JjKwFCkP/view?usp=drive_link' alt='데이터 바인딩이 완료된 상태' drive />\r\n\r\n리액트에서 `input.value`의 변경은 `onChange` 이벤트로 진행합니다. `input`이 두개니까 `useState`를 두개 사용해서 각각 제목과 부제를 저장하도록 세팅해두었습니다. 기본값도 부여한 상태입니다. 아무래도 텍스트가 비어있으면 테스트를 할 때 매번 입력하는 게 귀찮을테니까요.\r\n\r\n위에서 설정을 한 다음에는 `input` 태그에 연결을 해줘야합니다. 29번 30번에는 `title` 값을 저장합니다. 37번 38번은 `subTitle` 값을 저장합니다. 이렇게 하면 텍스트가 입력될 때 값도 함께 저장이 됩니다. 이 저장된 값을 이용해서 썸네일 부분에 출력 해보도록 합시다. 아주 간단합니다.\r\n\r\n<CodeBlock title='index.tsx'>\r\n```tsx {6-11}\r\nexport default function IndexPage() {\r\n  // ...\r\n  return (\r\n    <>\r\n      <div css={style.default}>\r\n        <div css={style.frame}>\r\n          <div>\r\n            <h1>{title}</h1>\r\n            <h2>{subTitle}</h2>\r\n          </div>\r\n        </div>\r\n\r\n        {/* ... */}\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n<Image src='https://drive.google.com/file/d/19pT6P5q_KAAJUeRaUP4e_zZoh_0_jDfa/view?usp=drive_link' alt='썸네일 부분에 바인딩이 된 모습' drive />\r\n\r\n이렇게만 해주면 알아서 바인딩이 된 상태로 출력이 되겠죠. 이제 이 텍스트들의 위치를 조정할 필요가 있습니다. 일단 스타일만 주었기 때문에 이름을 좀 붙여보겠습니다.\r\n\r\n## 썸네일의 텍스트 스타일 설정하기\r\n\r\n<CodeBlock title='index.tsx'>\r\n```tsx {6-8, 14-19}\r\nexport default function IndexPage() {\r\n  // ...\r\n\r\n  const style = {\r\n    // ...\r\n    frame: css([\r\n      tw` box-content border border-black-base aspect-video mb-10 relative `,\r\n    ]),\r\n    // ...\r\n  };\r\n  return (\r\n    <>\r\n      <div css={style.default}>\r\n        <div id='th-frame' css={style.frame}>\r\n          <div id='th-titles'>\r\n            <h1 id='th-title'>{title}</h1>\r\n            <h2 id='th-sub-title'>{subTitle}</h2>\r\n          </div>\r\n        </div>\r\n\r\n        {/* ... */}\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n썸네일 전체가 될 부분을 `th-frame` 라고 부르겠습니다. 제목은 보이는대로 `th-title`, 부제는 `th-sub-title` 가 되겠죠. `th-titles` 는 제목과 부제 두 요소의 위치를 잡기 위한 컨테이너입니다.\r\n\r\n7번을 보면 `th-frame` 에 포지션 스타일을 추가로 지정했습니다. 이녀석의 자식 노드들은 원하는대로 배치될 수 있어야 하기 때문이죠. 이제 각 노드에 스타일을 입히면 됩니다. 먼저 `th-titles` 에다가 스타일을 입혀서 썸네일의 가운데로 몰아보도록 합시다.\r\n\r\n<CodeBlock title='index.tsx'>\r\n```tsx {9-11, 17-22}\r\nexport default function IndexPage() {\r\n  // ...\r\n\r\n  const style = {\r\n    // ...\r\n    frame: css([\r\n      tw` box-content border border-black-base aspect-video mb-10 relative `,\r\n    ]),\r\n    titles: css([\r\n      tw` absolute top-[50%] translate-y-[-50%] left-[50%] translate-x-[-50%] text-center w-full `,\r\n    ]),\r\n    // ...\r\n  };\r\n  return (\r\n    <>\r\n      <div css={style.default}>\r\n        <div id='th-frame' css={style.frame}>\r\n          <div id='th-titles' css={style.titles}>\r\n            <h1 id='th-title'>{title}</h1>\r\n            <h2 id='th-sub-title'>{subTitle}</h2>\r\n          </div>\r\n        </div>\r\n\r\n        {/* ... */}\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n<Image src='https://drive.google.com/file/d/1HGm7zLCfuSdwOpp2e0fNeCDw72LyVLNQ/view?usp=drive_link' alt='텍스트가 가운데로 몰려진 모습' drive />\r\n\r\n텍스트는 이제 대략적인 준비는 끝났습니다. 나머지 스타일링을 하고 제목에 줄바꿈 처리도 한 번 해보도록 합시다. 줄바꿈을 하려면 사용자가 입력한 **\\\\n** 를 감지해서 줄을 바꿔주면 됩니다.\r\n\r\n<CodeBlock title='index.tsx'>\r\n```tsx {6-11, 17-26}\r\nexport default function IndexPage() {\r\n  // ...\r\n\r\n  const style = {\r\n    // ...\r\n    title: css([\r\n      tw` text-[4rem] font-black whitespace-pre-line `,\r\n    ]),\r\n    subTitle: css([\r\n      tw` text-[3rem] font-semibold `,\r\n    ]),\r\n    // ...\r\n  };\r\n  return (\r\n    <>\r\n      <div css={style.default}>\r\n        <div id='th-frame' css={style.frame}>\r\n          <div id='th-titles' css={style.titles}>\r\n            <h1 id='th-title' css={style.title}>\r\n              {title.split('\\\\n').map((item) => (\r\n                <>{item}<br /></>\r\n              ))}\r\n            </h1>\r\n            <h2 id='th-sub-title' css={style.subTitle}>{subTitle}</h2>\r\n          </div>\r\n        </div>\r\n\r\n        {/* ... */}\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n제목을 입력하는 `input` 태그에서 `title` 이라는 `state` 에 값을 저장한 상태에서 출력을 하는 것 까지는 좋은데 제목이 길어지거나 그럴 때를 대비해서 줄바꿈 기능을 넣었습니다. 20번 ~ 22번 라인입니다. `title` 을 **\\\\n**을 기준으로 쪼개서 `br` 태그를 넣어 줄바꿈이 되도록 만들었습니다.\r\n\r\n이 결과가 바로 이것입니다. 사용자는 그저 제목에 **\\\\n**을 넣어서 입력하기만 하면 됩니다.\r\n\r\n<Image src='https://drive.google.com/file/d/1VnThwzG2OO1IiYA27g9Tf5l4c2mA1Mem/view?usp=drive_link' alt='텍스트 줄바꿈 적용한 모습' drive />\r\n\r\n## 텍스트 입력 스타일 재정비하기\r\n\r\n이제 텍스트 입력하는 부분을 좀 더 다듬어야겠습니다. 입력란에 라벨도 만들어주고 개선을 해봅시다. 디자인에 조예가 있는 편은 아니라서 그냥 그럴듯하게만 만든 결과는 아래와 같습니다.\r\n\r\n<CodeBlock title='index.tsx'>\r\n```tsx\r\nexport default function IndexPage() {\r\n  // ...\r\n\r\n  return (\r\n    <>\r\n      <div css={style.default}>\r\n        <div id='th-frame' css={style.frame}>\r\n          {/* ... */}\r\n        </div>\r\n\r\n        <div css={style.inputs}>\r\n          <label htmlFor='title' css={style.input}>\r\n            <span>제목</span>\r\n            <input\r\n              type='text'\r\n              id='title'\r\n              placeholder='제목'\r\n              value={title}\r\n              onChange={onChangeTitle}\r\n            />\r\n          </label>\r\n          <label htmlFor='sub-title' css={style.input}>\r\n            <span>부제</span>\r\n            <input\r\n              type='text'\r\n              id='sub-title'\r\n              placeholder='부제'\r\n              value={subTitle}\r\n              onChange={onChangeSubTitle}\r\n            />\r\n          </label>\r\n        </div>\r\n\r\n        {/* ... */}\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n<Image src='https://drive.google.com/file/d/1wjAWlfqIy0gm3ybSQNqH24U4mWcjoxrb/view?usp=drive_link' alt='스타일 디자인 개선 결과' drive />\r\n\r\n입력란의 스타일을 확 바꿔서 포커싱이 되면 파란색 테두리가 아래에 나타나게끔 개선했습니다. 나중에 텍스트 쪽에도 배티할 요소가 많아지거나 하면 텍스트와 배경 부분을 따로 펼치고 접을 수 있게끔 만들어야겠다는 생각이 들었습니다.\r\n\r\n# 마치며\r\n\r\n이렇게 해서 이번 글의 목표를 마쳤습니다. 사실 내용은 별 게 아닌데 글이 너무 길어지는 것 같아서 쪼개는 중입니다. 다음 글에서는 배경을 적용해볼 겁니다. 색상을 선택하게 해서 설정을 하면 그대로 적용이 되게 만들 것인데 이 과정에서 필요하다면 텍스트 색상도 바꿀 수 있게끔 개선을 해보려고 합니다.\r\n\r\n작은 토이 프로젝트지만 할 게 많은 것 같은 느낌입니다. 역시 천천히 진행해서 그런 것이겠죠. 언제 완성할 수 있을지조차 가늠이 안가네요. 그럼 다음 글로 찾아오도록 하겠습니다.\r\n"},{"id":5,"content":"\r\n# 개요\r\n배경 관련 작업을 하려고 조금씩 살펴보다가 문득 떠오른 게 있었습니다. 이제 슬슬 컴포넌트들을 쪼개서 관리를 해야하는데 이럴 경우에 스테이트도 그에 맞게 관리를 해야한다는 것이었죠. 하지만 제가 정한 이 프로젝트의 컴포넌트 분할 계획은 두개의 컴포넌트에서 만들어지는 스테이트를 하나의 컴포넌트에서 활용하는 구조였습니다.\r\n\r\n컴포넌트와 컴포넌트가 부모 형제 사이가 아니기 때문에 스테이트를 전달할 방법이 없었다는 것이죠. 그래서 결론은 리덕스의 도입이었습니다. 리덕스 툴킷을 이용해서 중앙 저장소를 만들고 컴포넌트를 분할하는 것을 이 글에서 다루려고 합니다. 그럼 시작해봅시다.\r\n\r\n# 리덕스 환경 설정\r\n먼저 리덕스 환경을 구성하는 것부터 진행해보도록 합시다. 관련 패키지를 설치하고, 리듀서를 구성하고, 중앙 저장소인 스토어까지 만드는 과정을 간략하게 보여드리려고 합니다. 일단 리덕스가 필요한 이유는 위에서도 짧게 언급했는데, 컴포넌트가 분산되어 있어서 프롭스를 통해서 스테이트를 전달받을 수가 없습니다.\r\n\r\n리액트에서는 부모에서 자식에게 자산을 물려주는 식으로 프롭스를 전달하는데 이 프로젝트는 같은 계층의 컴포넌트끼리 스테이트를 사용해야하기 때문에 프롭스를 이용하는 것은 불가능하기 때문에 리덕스를 사용하는 것입니다. 리덕스는 중앙 저장소를 통해서 데이터를 관리하고 프롭스로의 스테이트 전달이 아닌 곧바로 중앙 저장소에서 호출하는 시스템이기 때문에 현재 프로젝트의 구조와 알맞습니다.\r\n\r\n<Image src='https://i.ibb.co/xCpxrC4/image.png' alt='리덕스를 사용하는 이유' />\r\n\r\n리덕스가 무엇인지 자체에 대해 설명하는 것은 여기서 다룰 내용은 아닌 것 같으니 이미지로 설명을 대체하고 이제 리덕스 사용 환경을 구축해보도록 합시다.\r\n\r\n## 리덕스 관련 패키지 설치\r\n\r\n<CodeBlock title=''>\r\n```bash\r\nyarn add @reduxjs/toolkit react-redux redux redux-persist\r\n```\r\n</CodeBlock>\r\n\r\n우선 관련 패키지를 설치해야합니다. 이 글에서는 리덕스 툴킷을 사용할 것이기 때문에 툴킷은 필수적으로 설치를 해줍니다. **redux-persist** 같은 경우에는 리덕스를 사용하면 스테이트의 값을 로컬스토리지에 저장해주는 기능을 합니다. 새로고침을 해도 그 데이터가 남아있는 것이죠.\r\n\r\n데이터를 저장은 해야 하는데 데이터베이스에 저장하기엔 뭐한 데이터의 경우에는 이걸 사용하는 편입니다. 설치를 진행하고나서 이제 리듀서를 만들어야합니다.\r\n\r\n<Image src='https://drive.google.com/file/d/1j_Tze5nEXReXvBQzR1SPGCRBLlULGw82/view?usp=drive_link' alt='리덕스 폴더 구조' drive />\r\n\r\n폴더 구조를 이렇게 해두었습니다. `src` 폴더 안에 `redux` 폴더를 만들고 그 안에 스토어와 리듀서를 둘 겁니다.\r\n\r\n## 리듀서 생성\r\n리듀서는 각각의 스테이트를 갖습니다. 그래서 기능에 따라 여러개의 리듀서를 만들고 리듀서별로 스테이트를 저장하고 관리할 수 있는 게 리덕스의 큰 특징입니다. 하지만 이 프로젝트는 큰 편은 아니고 하나의 리듀서만 있으면 될 것 같아서 하나의 리듀서만 만들어볼 것입니다.\r\n\r\n`app.reducer.ts` 파일을 열고 작성을 시작합니다.\r\n\r\n<CodeBlock title='app.reducer.ts'>\r\n```ts\r\nimport { PayloadAction, createSlice } from '@reduxjs/toolkit';\r\n\r\ntype AppState = {\r\n  bgType: ('color' | 'image');\r\n  title: string;\r\n  subTitle: string;\r\n  textColor: string;\r\n  bgColor: string;\r\n  imgSrc: string;\r\n}\r\n\r\nconst initialState: AppState = {\r\n  bgType: 'color',\r\n  title: '제목을 입력하세요',\r\n  subTitle: '',\r\n  textColor: '#ffffff',\r\n  bgColor: '#333333',\r\n  imgSrc: '',\r\n};\r\n\r\nconst appReducer = createSlice({\r\n  name: 'app',\r\n  initialState,\r\n  reducers: {\r\n    initState(state) {\r\n      state.bgType = 'color';\r\n      state.title = '제목을 입력하세요';\r\n      state.subTitle = '';\r\n      state.textColor = '#ffffff';\r\n      state.bgColor = '#333333';\r\n      state.imgSrc = '';\r\n    },\r\n    setBgType(\r\n      state,\r\n      { payload, }: PayloadAction<{value: ('color' | 'image')}>\r\n    ) {\r\n      state.bgType = payload.value;\r\n    },\r\n    setTitle(\r\n      state,\r\n      { payload, }: PayloadAction<{value: string}>\r\n    ) {\r\n      state.title = payload.value;\r\n    },\r\n    setSubTitle(\r\n      state,\r\n      { payload, }: PayloadAction<{value: string}>\r\n    ) {\r\n      state.subTitle = payload.value;\r\n    },\r\n    setTextColor(\r\n      state,\r\n      { payload, }: PayloadAction<{value: string}>\r\n    ) {\r\n      state.textColor = payload.value;\r\n    },\r\n    setBgColor(\r\n      state,\r\n      { payload, }: PayloadAction<{value: string}>\r\n    ) {\r\n      state.bgColor = payload.value;\r\n    },\r\n    setImg(\r\n      state,\r\n      { payload, }: PayloadAction<{value: string}>\r\n    ) {\r\n      state.imgSrc = payload.value;\r\n    },\r\n  },\r\n});\r\n\r\nexport const {\r\n  initState, setBgType, setTitle, setSubTitle, setTextColor, setBgColor, setImg,\r\n} = appReducer.actions;\r\nexport default appReducer.reducer;\r\n```\r\n</CodeBlock>\r\n\r\n리듀서는 이름, 스테이트 기본값, 액션으로 이루어져 있습니다. 리덕스 툴킷에서는 `createSlice` 함수를 이용해서 리듀서를 만듭니다. `initialState` 에는 여섯개의 스테이트를 만들어놨습니다. 제목과 부제, 배경 타입, 배경 색상, 이미지 주소, 텍스트 색상입니다. 나중에 더 늘어날 수도 있는데 일단은 이렇게만 만들어놨습니다.\r\n\r\n액션은 기본 스테이트로 돌려주는 액션 하나와 각 스테이트에 대응하는 액션 하나씩 해서 총 7개의 액션이 있습니다. 역시나 더 늘어날 수도 있습니다. 지금 당장에는 이렇게만 있으면 될 것 같네요.\r\n\r\n이렇게 만들어준 다음에는 `appReducer.actions` 에서 액션들을 분리시켜서 `export` 시켜주고 `appReducer.reducer` 도 `export` 시켜주면 됩니다.\r\n\r\n## 중앙 저장소 생성\r\n그 다음에는 **store**를 만들어야 합니다. 이 store에 **redux-persist**도 적용 할 겁니다. `store.ts` 파일을 열어서 작업을 시작합니다.\r\n\r\n<CodeBlock title='store.ts'>\r\n```ts\r\nimport { combineReducers, configureStore } from '@reduxjs/toolkit';\r\nimport { persistReducer } from 'redux-persist';\r\nimport createWebStorage from 'redux-persist/lib/storage/createWebStorage';\r\nimport appReducer from './app.reducer';\r\n\r\nconst createNoopStorage = () => {\r\n  return {\r\n    // eslint-disable-next-line no-unused-vars\r\n    getItem(_key: any) {\r\n      return Promise.resolve(null);\r\n    },\r\n    setItem(_key: any, value: any) {\r\n      return Promise.resolve(value);\r\n    },\r\n    // eslint-disable-next-line no-unused-vars\r\n    removeItem(_key: any) {\r\n      return Promise.resolve();\r\n    },\r\n  };\r\n};\r\n\r\nconst storage = typeof window === 'undefined'\r\n  ? createNoopStorage()\r\n  : createWebStorage('local');\r\n\r\nconst reducers = combineReducers({\r\n  app: appReducer,\r\n});\r\n\r\nconst persistedReducer = persistReducer({\r\n  key: 'root',\r\n  storage,\r\n  whitelist: [ 'app', ],\r\n}, reducers);\r\n\r\nexport const store = configureStore({\r\n  reducer: persistedReducer,\r\n  middleware: [],\r\n});\r\n\r\nexport type RootState = ReturnType<typeof store.getState>;\r\nexport type AppDispatch = typeof store.dispatch;\r\n```\r\n</CodeBlock>\r\n\r\n스토어는 이렇게 만들면 되는데 간단하게 코드를 살펴보도록 하겠습니다.\r\n\r\n<CodeBlock title=''>\r\n```ts\r\nconst reducers = combineReducers({\r\n  app: appReducer,\r\n});\r\n```\r\n</CodeBlock>\r\n\r\n먼저 `combineReducers` 함수를 이용해서 리듀서들을 하나로 합쳐주는 작업을 진행합니다. 리듀서가 여러개일 때에 사용하는 방법인데 굳이 하나임에도 이렇게 하는 이유는 리듀서가 추가될 수도 있기 때문입니다. 만일을 대비해서 미리 이렇게 만들어둔 것이죠.\r\n\r\n이렇게 만들어진 `reducers` 를 아래에서 사용합니다.\r\n\r\n<CodeBlock title=''>\r\n```ts\r\nconst storage = typeof window === 'undefined'\r\n  ? createNoopStorage()\r\n  : createWebStorage('local');\r\n\r\nconst persistedReducer = persistReducer({\r\n  key: 'root',\r\n  storage,\r\n  whitelist: [ 'app', ],\r\n}, reducers);\r\n\r\nexport const store = configureStore({\r\n  reducer: persistedReducer,\r\n  middleware: [],\r\n});\r\n```\r\n</CodeBlock>\r\n\r\n`persistReducer` 함수는 어떤 리듀서를 로컬스토리지에 저장해서 관리할 것인가를 포함하는 데이터를 명시하는 역할을 합니다. 이런식으로 작성을 하면 되고 `configureStore` 함수를 통해서 스토어를 생성합니다.\r\n\r\n`createNoopStorage` 함수의 경우에는 **redux-persist** 가 제역할을 못하는 경우가 있어서 구글링을 통해서 발견한 해결책으로 나온 함수입니다.\r\n\r\n<CodeBlock title=''>\r\n```ts\r\nconst createNoopStorage = () => {\r\n  return {\r\n    // eslint-disable-next-line no-unused-vars\r\n    getItem(_key: any) {\r\n      return Promise.resolve(null);\r\n    },\r\n    setItem(_key: any, value: any) {\r\n      return Promise.resolve(value);\r\n    },\r\n    // eslint-disable-next-line no-unused-vars\r\n    removeItem(_key: any) {\r\n      return Promise.resolve();\r\n    },\r\n  };\r\n};\r\n```\r\n</CodeBlock>\r\n\r\n이렇게까지 하면 이제 만들어진 스토어와 함께 타입을 내보내기만 하면 됩니다.\r\n\r\n<CodeBlock title=''>\r\n```ts\r\nexport type RootState = ReturnType<typeof store.getState>;\r\nexport type AppDispatch = typeof store.dispatch;\r\n```\r\n</CodeBlock>\r\n\r\n리듀서에서 만든 액션들을 사용(dispatch)하기 위해서 필요한 `AppDispatch` 타입과 중앙 저장소에서 데이터를 가져올 때 필요한 `RootState` 타입을 내보내줍니다. 이제 마지막으로 커스텀 훅을 만들어서 스테이트와 액션을 편하게 사용할 수 있도록 준비해두는 일만 남았습니다.\r\n\r\n## 커스텀 훅 만들기\r\n\r\n<Image src='https://drive.google.com/file/d/1lxjgmOo2mCcQmHnIaF00qVbPEsT-0PKB/view?usp=drive_link' alt='커스텀 훅 폴더 구성' drive />\r\n\r\n먼저 폴더와 파일을 이렇게 만들어줍니다.\r\n\r\n`rtk.ts` 파일을 열고 아래의 내용을 작성합니다.\r\n\r\n<CodeBlock title='rtk.ts'>\r\n```ts\r\nimport { useDispatch, useSelector } from 'react-redux';\r\nimport type { TypedUseSelectorHook } from 'react-redux';\r\nimport { AppDispatch, RootState } from '@/redux';\r\n\r\nexport const useAppDispatch: () => AppDispatch = useDispatch;\r\nexport const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;\r\n```\r\n</CodeBlock>\r\n\r\n이제는 액션을 사용할 때 `useAppDispatch` 훅으로 사용하면 되고 스테이트를 가져올 때에는 `useAppSelector` 훅으로 가져오면 됩니다.\r\n\r\n## 마지막, Provider 설정하기\r\n\r\n마지막 작업을 위해서는 `pages` 폴더의 `_app.tsx` 파일을 열어서 수정 해야합니다.\r\n\r\n<CodeBlock title='_app.tsx'>\r\n```tsx\r\nimport React from 'react';\r\nimport Head from 'next/head';\r\nimport { AppProps } from 'next/app';\r\nimport { Provider } from 'react-redux';\r\nimport { PersistGate } from 'redux-persist/integration/react';\r\nimport { persistStore } from 'redux-persist';\r\nimport { store } from '@/redux';\r\nimport '@/styles/global.css';\r\n\r\nexport const persistor = persistStore(store);\r\n\r\nconst App = ({ Component, pageProps, }: AppProps) => (\r\n  <Provider store={store}>\r\n    <PersistGate loading={null} persistor={persistor}>\r\n      <Head>\r\n        <meta charSet='UTF-8' />\r\n        <meta httpEquiv='X-UA-Compatible' content='ie=edge' />\r\n        <meta\r\n          name='viewport'\r\n          content='width=device-width, initial-scale=1.0'\r\n        />\r\n      </Head>\r\n      <Component {...pageProps} />\r\n    </PersistGate>\r\n  </Provider>\r\n);\r\n\r\nexport default App;\r\n```\r\n</CodeBlock>\r\n\r\n`Provider` 로 기존의 내용물을 감싸주고, `store` 를 전달해줍니다. 그 안에서는 `persistStore` 함수에 인자로 `store` 를 넘겨주고 얻은 `persistor` 를 `PersistGate` 에 전달해주면 됩니다. 코드상에서 보이는대로 설정하면 모든 준비는 끝난겁니다. 이제 컴포넌트 분할하러 가봅시다.\r\n\r\n# 컴포넌트 분할의 이유\r\n컴포넌트를 분할하는 이유는 하나의 컴포넌트에서 여러가지의 일을 처리하면 혼선이 올 수도 있고 보기에도 좋지 않기 때문도 있고 가장 큰 건 재사용성이지만 굳이 재사용성이 아니더라도 컴포넌트를 분리하는 것을 통해서 그 부분만 신경쓰고 관리할 수 있기 때문에 가독성도 좋아지고 편의성이 향상되기 때문인 듯합니다.\r\n\r\n그래서 이 프로젝트는 세개의 컴포넌트를 추가로 만들어서 그 안에 각각의 내용을 채워넣도록 할 겁니다. 썸네일이 될 화면을 분리하고, 텍스트 설정 부분을 분리하고, 배경 설정 부분을 분리하면 될 것 같습니다.\r\n\r\n시작하기 전에 기존의 `index.tsx` 를 보고 시작하도록 하겠습니다. 코드는 접힌 상태이므로 버튼을 클릭해서 펼쳐서 보시면 됩니다.\r\n\r\n<CodeBlock title='index.tsx' fold>\r\n```tsx\r\nimport React, {\r\n  ChangeEvent, useCallback, useState\r\n} from 'react';\r\nimport tw, { css } from 'twin.macro';\r\n\r\nexport default function IndexPage() {\r\n  const [ title, setTitle, ] = useState('제목을 입력하세요.');\r\n  const [ subTitle, setSubTitle, ] = useState('부제');\r\n\r\n  const onChangeTitle = useCallback(\r\n    (event: ChangeEvent<HTMLInputElement>) => {\r\n      setTitle(event.target.value);\r\n    },\r\n    []\r\n  );\r\n\r\n  const onChangeSubTitle = useCallback(\r\n    (event: ChangeEvent<HTMLInputElement>) => {\r\n      setSubTitle(event.target.value);\r\n    },\r\n    []\r\n  );\r\n\r\n  const style = {\r\n    default: css([\r\n      tw` w-[1280px] mx-auto `,\r\n    ]),\r\n    frame: css([\r\n      tw` box-content border border-black-base aspect-video mb-10 relative `,\r\n    ]),\r\n    inputs: css([\r\n      tw` space-y-2 `,\r\n    ]),\r\n    input: css([\r\n      tw` flex flex-col gap-1 `,\r\n      tw` [span]:( font-semibold text-normal text-black-base ) `,\r\n      tw` [input]:( p-2 outline-none text-normal bg-black-100 text-black-base placeholder:text-black-300 border-b-[2px] border-transparent transition-colors duration-200 ) `,\r\n      tw` [input]:( focus:( border-blue-500 ) ) `,\r\n    ]),\r\n    colors: tw` flex mt-10 `,\r\n    colorTab: css([\r\n      tw` [&[data-selected=\"true\"]]:( p-3 flex-1 shrink-0 border border-black-300 border-b-0 bg-white text-black-base text-center ) `,\r\n      tw` [&[data-selected=\"false\"]]:( p-3 flex-1 shrink-0 border border-black-300 border-b-0 bg-black-300 text-black-600 text-center ) `,\r\n    ]),\r\n    colorTabBottom: css([\r\n      tw` border border-black-300 border-t-0 p-3 bg-white mb-10 `,\r\n    ]),\r\n    buttons: css([\r\n      tw` flex gap-5 `,\r\n      tw` [button]:( flex-1 shrink-0 bg-blue-400 text-white p-3 hover:( bg-blue-600 ) ) `,\r\n    ]),\r\n    titles: css([\r\n      tw` absolute top-[50%] translate-y-[-50%] left-[50%] translate-x-[-50%] text-center w-full `,\r\n    ]),\r\n    title: css([\r\n      tw` text-[4rem] font-black whitespace-pre-line `,\r\n    ]),\r\n    subTitle: css([\r\n      tw` text-[3rem] font-semibold `,\r\n    ]),\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <div css={style.default}>\r\n        <div id='th-frame' css={style.frame}>\r\n          <div id='th-titles' css={style.titles}>\r\n            <h1 id='th-title' css={style.title}>\r\n              {title.split('\\\\n').map((item, index) => (\r\n                // eslint-disable-next-line react/no-array-index-key\r\n                <React.Fragment key={`${item}-${index}`}>{item}<br /></React.Fragment>\r\n              ))}\r\n            </h1>\r\n            <h2 id='th-sub-title' css={style.subTitle}>{subTitle}</h2>\r\n          </div>\r\n        </div>\r\n\r\n        <div css={style.inputs}>\r\n          <label htmlFor='title' css={style.input}>\r\n            <span>제목</span>\r\n            <input\r\n              type='text'\r\n              id='title'\r\n              placeholder='제목'\r\n              value={title}\r\n              onChange={onChangeTitle}\r\n            />\r\n          </label>\r\n          <label htmlFor='sub-title' css={style.input}>\r\n            <span>부제</span>\r\n            <input\r\n              type='text'\r\n              id='sub-title'\r\n              placeholder='부제'\r\n              value={subTitle}\r\n              onChange={onChangeSubTitle}\r\n            />\r\n          </label>\r\n        </div>\r\n\r\n        <div css={style.colors}>\r\n          <button css={style.colorTab} data-type='color'>단색 배경</button>\r\n          <button css={style.colorTab} data-type='image'>이미지 배경</button>\r\n        </div>\r\n\r\n        <div css={style.colorTabBottom}>\r\n          <input type='range' min={0} max={255} defaultValue={50} id='hex-red' />\r\n          <input type='range' min={0} max={255} defaultValue={50} id='hex-blue' />\r\n          <input type='range' min={0} max={255} defaultValue={50} id='hex-green' />\r\n        </div>\r\n\r\n        <div css={style.colorTabBottom}>\r\n          <input type='text' id='image-src' placeholder='이미지 주소를 입력하세요' css={style.input} />\r\n        </div>\r\n\r\n        <div css={style.buttons}>\r\n          <button>초기화</button>\r\n          <button>이미지로 저장</button>\r\n        </div>\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n## 썸네일 부분 분리하기 => Thumbnail\r\n\r\n<Image src='https://drive.google.com/file/d/14bTfA-2J5hpuZgSA7xbM4g3UB9xN21vH/view?usp=drive_link' alt='컴포넌트 폴더 구조' drive />\r\n\r\n`components` 폴더를 만들고 그 안에 세개의 파일을 만들겁니다. `Thumbnail.tsx`, `TextConfig.tsx`, `BackgroundConfig.tsx` 입니다. 이 세가지의 파일이 각각 썸네일, 텍스트 설정, 배경 설정 부분이 될 겁니다.\r\n\r\n<CodeBlock title='Thumbnail.tsx'>\r\n```tsx\r\nimport React from 'react';\r\nimport tw, { css } from 'twin.macro';\r\nimport { useAppSelector } from '@/hooks/rtk';\r\n\r\nexport function Thumbnail() {\r\n  const { title, subTitle, } = useAppSelector((state) => state.app);\r\n\r\n  const style = {\r\n    frame: css([\r\n      tw` box-content border border-black-base aspect-video mb-10 relative `,\r\n    ]),\r\n    titles: css([\r\n      tw` absolute top-[50%] translate-y-[-50%] left-[50%] translate-x-[-50%] text-center w-full `,\r\n    ]),\r\n    title: css([\r\n      tw` text-[4rem] font-black whitespace-pre-line `,\r\n    ]),\r\n    subTitle: css([\r\n      tw` text-[3rem] font-semibold `,\r\n    ]),\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <div id='th-frame' css={style.frame}>\r\n        <div id='th-titles' css={style.titles}>\r\n          <h1 id='th-title' css={style.title}>\r\n            {title.split('\\\\n').map((item, index) => (\r\n              // eslint-disable-next-line react/no-array-index-key\r\n              <React.Fragment key={`${item}-${index}`}>{item}<br /></React.Fragment>\r\n            ))}\r\n          </h1>\r\n          <h2 id='th-sub-title' css={style.subTitle}>{subTitle}</h2>\r\n        </div>\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n썸네일 부분을 그대로 옮겨왔는데, 중요한 것은 `useAppSelector` 함수를 통해서 중앙 저장소에 저장되어있는 `title`, `subTitle` 스테이트를 가져오는 점이 달라졌다는 것입니다. 이런 식으로 편리하고 간단하게 스테이트를 끌어다가 사용할 수 있습니다.\r\n\r\n## 텍스트 설정 부분 분리하기 => TextConfig\r\n<CodeBlock title='TextConfig.tsx'>\r\n```tsx\r\nimport React, { ChangeEvent, useCallback } from 'react';\r\nimport tw, { css } from 'twin.macro';\r\nimport { useAppDispatch, useAppSelector } from '@/hooks/rtk';\r\nimport { setSubTitle, setTitle } from '@/redux';\r\n\r\nexport function TextConfig() {\r\n  const { title, subTitle, } = useAppSelector(\r\n    (state) => state.app\r\n  );\r\n\r\n  const dispatch = useAppDispatch();\r\n\r\n  const onChangeTitle = useCallback(\r\n    (event: ChangeEvent<HTMLInputElement>) => {\r\n      dispatch(setTitle({\r\n        value: event.target.value,\r\n      }));\r\n    },\r\n    []\r\n  );\r\n\r\n  const onChangeSubTitle = useCallback(\r\n    (event: ChangeEvent<HTMLInputElement>) => {\r\n      dispatch(setSubTitle({\r\n        value: event.target.value,\r\n      }));\r\n    },\r\n    []\r\n  );\r\n\r\n  const style = {\r\n    inputs: css([\r\n      tw` space-y-2 `,\r\n    ]),\r\n    input: css([\r\n      tw` flex flex-col gap-1 `,\r\n      tw` [span]:( font-semibold text-normal text-black-base ) `,\r\n      tw` [input]:( p-2 outline-none text-normal bg-black-100 text-black-base placeholder:text-black-300 border-b-[2px] border-transparent transition-colors duration-200 ) `,\r\n      tw` [input]:( focus:( border-blue-500 ) ) `,\r\n    ]),\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <div css={style.inputs}>\r\n        <label htmlFor='title' css={style.input}>\r\n          <span>제목</span>\r\n          <input\r\n            type='text'\r\n            id='title'\r\n            placeholder='제목'\r\n            value={title}\r\n            onChange={onChangeTitle}\r\n          />\r\n        </label>\r\n        <label htmlFor='sub-title' css={style.input}>\r\n          <span>부제</span>\r\n          <input\r\n            type='text'\r\n            id='sub-title'\r\n            placeholder='부제'\r\n            value={subTitle}\r\n            onChange={onChangeSubTitle}\r\n          />\r\n        </label>\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n텍스트를 설정하는 부분도 크게 달라진 건 없지만 `useState` 함수를 이용해서 스테이트를 변경하는 부분에서 리덕스를 사용해서 스테이트를 변경하는 부분으로 바뀌었습니다. 리덕스에서 스테이트를 변경하기 위해서는 `dispatch` 를 사용해야합니다. `dispatch` 함수 안에서 액션을 사용하는 것입니다.\r\n\r\n<CodeBlock title=''>\r\n```tsx\r\nconst [ title, setTitle, ] = useState('제목을 입력하세요.');\r\nconst [ subTitle, setSubTitle, ] = useState('부제');\r\n\r\nconst onChangeTitle = useCallback(\r\n  (event: ChangeEvent<HTMLInputElement>) => {\r\n    setTitle(event.target.value);\r\n  },\r\n  []\r\n);\r\n\r\nconst onChangeSubTitle = useCallback(\r\n  (event: ChangeEvent<HTMLInputElement>) => {\r\n    setSubTitle(event.target.value);\r\n  },\r\n  []\r\n);\r\n```\r\n</CodeBlock>\r\n\r\n이게 기존의 방법이었습니다. 스테이트를 컴포넌트에서 만들고, 그걸 변경하는 것이었죠. 하지만 리덕스를 도입한 후에는 아래처럼 바뀝니다.\r\n\r\n<CodeBlock title=''>\r\n```tsx\r\nconst { title, subTitle, } = useAppSelector(\r\n  (state) => state.app\r\n);\r\n\r\nconst dispatch = useAppDispatch();\r\n\r\nconst onChangeTitle = useCallback(\r\n  (event: ChangeEvent<HTMLInputElement>) => {\r\n    dispatch(setTitle({\r\n      value: event.target.value,\r\n    }));\r\n  },\r\n  []\r\n);\r\n\r\nconst onChangeSubTitle = useCallback(\r\n  (event: ChangeEvent<HTMLInputElement>) => {\r\n    dispatch(setSubTitle({\r\n      value: event.target.value,\r\n    }));\r\n  },\r\n  []\r\n);\r\n```\r\n</CodeBlock>\r\n\r\n중앙 저장소에서 스테이트를 가져온 후에, `dispatch` 를 통해서 액션을 실행시킵니다. 여기서 실행되는 액션은 두가지죠. `setTitle` 과 `setSubTitle` 입니다.\r\n\r\n## 배경 설정 부분 분리하기 => BackgroundConfig\r\n\r\n<CodeBlock title='BackgroundConfig.tsx'>\r\n```tsx\r\nimport React from 'react';\r\nimport tw, { css } from 'twin.macro';\r\n\r\nexport function BackgroundConfig() {\r\n  const style = {\r\n    colors: tw` flex mt-10 `,\r\n    colorTab: css([\r\n      tw` [&[data-selected=\"true\"]]:( p-3 flex-1 shrink-0 border border-black-300 border-b-0 bg-white text-black-base text-center ) `,\r\n      tw` [&[data-selected=\"false\"]]:( p-3 flex-1 shrink-0 border border-black-300 border-b-0 bg-black-300 text-black-600 text-center ) `,\r\n    ]),\r\n    colorTabBottom: css([\r\n      tw` border border-black-300 border-t-0 p-3 bg-white mb-10 `,\r\n    ]),\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <div css={style.colors}>\r\n        <button css={style.colorTab} data-type='color'>단색 배경</button>\r\n        <button css={style.colorTab} data-type='image'>이미지 배경</button>\r\n      </div>\r\n\r\n      <div css={style.colorTabBottom}>\r\n        <input type='range' min={0} max={255} defaultValue={50} id='hex-red' />\r\n        <input type='range' min={0} max={255} defaultValue={50} id='hex-blue' />\r\n        <input type='range' min={0} max={255} defaultValue={50} id='hex-green' />\r\n      </div>\r\n\r\n      <div css={style.colorTabBottom}>\r\n        <input type='text' id='image-src' placeholder='이미지 주소를 입력하세요' />\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n배경을 설정하는 부분은 아직 작업을 한 게 없어서 딱히 달라진 건 없습니다. 이제 다음글에서는 여기를 건드리게 되겠죠. 이제 마지막으로 분리한 후의 `index.tsx` 를 보면서 마치도록 하겠습니다.\r\n\r\n<CodeBlock title='index.tsx'>\r\n```tsx\r\nimport React from 'react';\r\nimport tw, { css } from 'twin.macro';\r\nimport { BackgroundConfig, TextConfig, Thumbnail } from '@/components';\r\n\r\nexport default function IndexPage() {\r\n  const style = {\r\n    default: css([\r\n      tw` w-[1280px] mx-auto `,\r\n    ]),\r\n    buttons: css([\r\n      tw` flex gap-5 `,\r\n      tw` [button]:( flex-1 shrink-0 bg-blue-400 text-white p-3 hover:( bg-blue-600 ) ) `,\r\n    ]),\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <div css={style.default}>\r\n        <Thumbnail />\r\n        <TextConfig />\r\n        <BackgroundConfig />\r\n\r\n        <div css={style.buttons}>\r\n          <button>초기화</button>\r\n          <button>이미지로 저장</button>\r\n        </div>\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n# 마치며\r\n이번 글에서는 리덕스를 도입하고 컴포넌트를 분리하는 작업을 해봤습니다. 실제로 적용하는 건 그렇게 대단한 게 아닌데 글로 작성하니까 상당히 길어진 느낌이 없지 않네요. 이제 다음 글에서는 원래 이번 글에서 진행했어야 했던 배경 설정 부분을 개발하도록 하겠습니다.\r\n"},{"id":6,"content":"\r\n# 개요\r\n이번 글에서는 썸네일 배경 설정을 구현해보도록 합시다. 배경은 이미지 배경이 있고 색상 배경이 있는데 색상 배경을 먼저 개발하도록 하겠습니다. 색상 배경의 경우에는 사용자가 RGB 컬러를 선택하면 적용되는 방향으로 생각하고 있습니다. 저번 글에서 컴포넌트를 분리한 후 배경 설정 컴포넌트는 아무것도 건드리지 않았었는데 차근 차근 진행해보도록 합시다.\r\n\r\n글의 분량이 괜찮다 싶으면 이미지 배경 설정 구현까지 진행해보도록 하겠습니다. 그럼 이제 시작해봅시다.\r\n\r\n# 배경 설정 시작하기\r\n시작하기 전에 현재 상태의 배경 설정 컴포넌트를 살펴보고 넘어가도록 합시다.\r\n\r\n<CodeBlock title='BackgroundConfig.tsx' fold>\r\n```tsx\r\nimport React from 'react';\r\nimport tw, { css } from 'twin.macro';\r\n\r\nexport function BackgroundConfig() {\r\n  const style = {\r\n    colors: tw`  `,\r\n    colorTab: css([\r\n      tw`  `,\r\n    ]),\r\n    colorTabBottom: css([\r\n      tw`  `,\r\n    ]),\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <div css={style.colors}>\r\n        <button css={style.colorTab} data-type='color'>단색 배경</button>\r\n        <button css={style.colorTab} data-type='image'>이미지 배경</button>\r\n      </div>\r\n\r\n      <div css={style.colorTabBottom}>\r\n        <input type='range' min={0} max={255} defaultValue={50} id='hex-red' />\r\n        <input type='range' min={0} max={255} defaultValue={50} id='hex-blue' />\r\n        <input type='range' min={0} max={255} defaultValue={50} id='hex-green' />\r\n      </div>\r\n\r\n      <div css={style.colorTabBottom}>\r\n        <input type='text' id='image-src' placeholder='이미지 주소를 입력하세요' />\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n배경 설정은 두가지가 있고 하나는 색상, 하나는 이미지입니다. 색상과 이미지는 탭으로 구분을 하기 때문에 둘 중 하나를 클릭하면 해당되는 내용이 활성화되도록 해야합니다. 또한 색상 설정의 경우 색상 슬라이더를 직접 만들어서 구현할 생각입니다. 대충 어떻게 할 지 감은 잡았으니 시작해보도록 합시다.\r\n\r\n## 배경 종류 탭 구현하기\r\n배경 종류를 설정하는 탭부터 구현을 해봅시다. 탭은 두개가 있고 클릭 할 때마다 해당 설정 화면이 보여야합니다. 새로고침을 했을 때에도 탭이 유지가 되게끔 만들기 위해서 이 부분에 리덕스를 적용할 생각입니다.\r\n\r\n<CodeBlock title='BackgroundConfig.tsx'>\r\n```tsx\r\nexport default function BackgroundConfig() {\r\n  const bgType = useAppSelector((state) => state.app.bgType);\r\n  const dispatch = useAppDispatch();\r\n\r\n  const onClickColor = useCallback(\r\n    () => {\r\n      dispatch(setBgType({\r\n        value: 'color',\r\n      }));\r\n    },\r\n    []\r\n  );\r\n\r\n  const onClickImage = useCallback(\r\n    () => {\r\n      dispatch(setBgType({\r\n        value: 'image',\r\n      }));\r\n    },\r\n    []\r\n  );\r\n\r\n  const style = {\r\n    colors: tw` flex mt-10 border border-b-0 border-black-200 divide-x divide-black-200 `,\r\n    bgTypeTab: (type: string) => {\r\n      return css([\r\n        tw` p-3 flex-1 shrink-0 `,\r\n        bgType === type\r\n          ? tw` bg-white text-black-base `\r\n          : tw` bg-black-200 text-black-400 `,\r\n      ]);\r\n    },\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <div css={style.colors}>\r\n        <button css={style.bgTypeTab('color')} onClick={onClickColor}>단색 배경</button>\r\n        <button css={style.bgTypeTab('image')} onClick={onClickImage}>이미지 배경</button>\r\n      </div>\r\n\r\n      {/* ... */}\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n먼저 이렇게 중앙 저장소에서 `bgType` 스테이트를 가져온 후에 `onClickColor` 함수와 `onClickImage` 함수를 만들어서 각각 `setBgType` 액션에 다른 값을 전달하는 식으로 구현해둔 상태입니다. 스타일에서는 함수로 매개변수를 받아서 `bgType` 과 `type` 을 비교하는 조건을 걸어서 참일 때와 거짓일 때에 따라서 탭의 색상이 달라지게끔 만들었습니다.\r\n\r\n<Image src='https://drive.google.com/file/d/1FWp6pPS9AWT-6U1eevuYAivtQZw8nYU2/view?usp=drive_link' alt='탭 클릭 구현' drive />\r\n\r\n이렇게만 해주면 자연스럽게 탭의 내용도 바뀌게 만들 수 있겠죠. 이 부분에 리덕스를 사용한 이유는 간단합니다. 위에서도 언급했지만 저는 이 설정 상태가 창을 껐다가 켜도 유지되었으면 좋겠거든요.\r\n\r\n<CodeBlock title='BackgroundConfig.tsx'>\r\n```tsx\r\n<>\r\n  {bgType === 'color' && (\r\n    <div css={style.tabBottom}>\r\n      색상 슬라이더\r\n    </div>\r\n  )}\r\n\r\n  {bgType === 'image' && (\r\n    <div css={style.tabBottom}>\r\n      이미지 주소 input\r\n    </div>\r\n  )}\r\n</>\r\n```\r\n</CodeBlock>\r\n\r\n<Image src='https://drive.google.com/file/d/1x0WX59twzsK-UVIeILbkYwagLObU2jQ2/view?usp=drive_link' alt='색상 배경 선택' drive />\r\n\r\n<Image src='https://drive.google.com/file/d/1PuADu4t3cTi9owS4wvJgl1NkxLjzdMZg/view?usp=drive_link' alt='이미지 배경 선택' drive />\r\n\r\n이런식으로 `bgType` 이 **color** 혹은 **image** 일 때 렌더링되는 부분이 달라지게끔 이렇게 만들 수 있을 것입니다. 그럼 이제 색상 슬라이더를 만들어볼 시간입니다. 색상 슬라이더는 `input` 태그의 `range` 타입을 이용해서 만들겁니다. **0부터 255까지의 값**을 설정할 수 있어야하기 때문이죠.\r\n\r\n## 색상 슬라이더 만들기\r\n색상 슬라이더를 만들기 전에 `BackgroundConfig.tsx` 컴포넌트에서 작업을 하면 코드가 길어지고 지저분해질 것이기 때문에 컴포넌트를 새로 만들어서 작업을 하는 것이 좋겠습니다. `ColorSlider.tsx` 컴포넌트를 만들었습니다.\r\n\r\n<CodeBlock title='ColorSlider.tsx'>\r\n```tsx\r\nexport default function ColorSlider() {\r\n  return (\r\n    <div>\r\n      <input type='range' min='0' max='255' />\r\n      <input type='range' min='0' max='255' />\r\n      <input type='range' min='0' max='255' />\r\n    </div>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n<CodeBlock title='BackgroundConfig.tsx'>\r\n```tsx\r\n<>\r\n  {bgType === 'color' && (\r\n    <div css={style.tabBottom}>\r\n      <ColorSlider />\r\n    </div>\r\n  )}\r\n</>\r\n```\r\n</CodeBlock>\r\n\r\n0에서 255까지의 숫자를 선택할 수 있는 `range` 타입의 `input` 세개를 만듭니다. 이녀석들이 **R, G, B**가 될 것입니다. 이녀석들에게서 값을 얻어내려면 스테이트가 필요합니다. 이 컴포넌트 내에서는 중앙 저장소의 스테이트 하나와 지역 스테이트 세개를 사용할 겁니다.\r\n\r\n`useState` 를 이용해서 스테이트 세개를 만들어줍니다.\r\n\r\n<CodeBlock title='ColorSlider.tsx'>\r\n```tsx\r\nexport default function ColorSlider() {\r\n  const [ red, setRed, ] = useState(50);\r\n  const [ green, setGreen, ] = useState(50);\r\n  const [ blue, setBlue, ] = useState(50);\r\n\r\n  return (\r\n    <div>\r\n      <input type='range' min='0' max='255' />\r\n      <input type='range' min='0' max='255' />\r\n      <input type='range' min='0' max='255' />\r\n    </div>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n기본값은 50으로 설정해두겠습니다. 스테이트를 만들었지만 아직 연결은 되지 않았습니다. 연결을 하고 `onChange` 핸들러까지 만들어주도록 합니다.\r\n\r\n<CodeBlock title='ColorSlider.tsx'>\r\n```tsx\r\nexport default function ColorSlider() {\r\n  const [ red, setRed, ] = useState(50);\r\n  const [ green, setGreen, ] = useState(50);\r\n  const [ blue, setBlue, ] = useState(50);\r\n\r\n  const onChangeRed = useCallback(\r\n    (event: ChangeEvent<HTMLInputElement>) => {\r\n      setRed(+event.target.value);\r\n    },\r\n    [ green, blue, ]\r\n  );\r\n\r\n  const onChangeGreen = useCallback(\r\n    (event: ChangeEvent<HTMLInputElement>) => {\r\n      setGreen(+event.target.value);\r\n    },\r\n    [ red, blue, ]\r\n  );\r\n\r\n  const onChangeBlue = useCallback(\r\n    (event: ChangeEvent<HTMLInputElement>) => {\r\n      setBlue(+event.target.value);\r\n    },\r\n    [ red, green, ]\r\n  );\r\n\r\n  return (\r\n    <div>\r\n      <div>\r\n        <input type='range' min='0' max='255' value={red} onChange={onChangeRed} />\r\n        <span>{red}</span>\r\n      </div>\r\n      <div>\r\n        <input type='range' min='0' max='255' value={green} onChange={onChangeGreen} />\r\n        <span>{green}</span>\r\n      </div>\r\n      <div>\r\n        <input type='range' min='0' max='255' value={blue} onChange={onChangeBlue} />\r\n        <span>{blue}</span>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n<Image src='https://drive.google.com/file/d/151ewzccGZ3puGWAiafkd9am_kCW_JpHu/view?usp=drive_link' alt='숫자가 잘 뽑히는 모습' drive />\r\n\r\n슬라이더가 올바르게 작동하는지 각각의 값도 같이 출력해보았습니다. 수치는 잘 뽑아내고 있는 것 같습니다. 그러면 이제 이걸 색상으로 표현해야합니다. 이 숫자들을 HEX 코드로 바꾸는 작업을 해봅시다.\r\n\r\n<CodeBlock title='BackgroundConfig.tsx'>\r\n```tsx\r\nfunction convertHex(number: number) {\r\n  const hex = number.toString(16).toUpperCase();\r\n\r\n  return hex.length > 1\r\n    ? hex\r\n    : `0${hex}`;\r\n}\r\n\r\nconst hexCode = useMemo(() => {\r\n  const hex = [ red, green, blue, ]\r\n    .map((color) => convertHex(color));\r\n\r\n  return `#${hex.join('')}`;\r\n}, [ red, green, blue, ]);\r\n```\r\n</CodeBlock>\r\n\r\n컴포넌트 내부에 두개의 함수를 만들어줍니다. `convertHex` 함수는 10진수를 16진수로 만들어주는 역할을 합니다. `hexCode` 함수는 `red`, `green`, `blue` 스테이트를 **HEX 코드로 변경**하여 최종적으로 **색상코드를 반환**합니다.\r\n\r\n그리고 이렇게 나온 HEX 코드를 배경에다가 뿌려주면 색이 나타날 겁니다. 하지만 지금은 썸네일에 바로 뿌려주는 것이 아니라 미리보기 색상 용도로 뿌려줘야 합니다.\r\n\r\n<CodeBlock title='ColorSlider.tsx'>\r\n```tsx\r\nexport default function ColorSlider() {\r\n  // ...\r\n\r\n  const hexCode = useMemo(() => {\r\n    const hex = [ red, green, blue, ]\r\n      .map((color) => convertHex(color));\r\n\r\n    return `#${hex.join('')}`;\r\n  }, [ red, green, blue, ]);\r\n\r\n  const style = {\r\n    colorView: css([\r\n      (css`\r\n        background-color: ${hexCode};\r\n      `),\r\n      tw` w-[150px] aspect-square border-2 border-[black] `,\r\n    ]),\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      <div>\r\n        <div>\r\n          <input type='range' min='0' max='255' value={red} onChange={onChangeRed} />\r\n          <span>{red}</span>\r\n        </div>\r\n        <div>\r\n          <input type='range' min='0' max='255' value={green} onChange={onChangeGreen} />\r\n          <span>{green}</span>\r\n        </div>\r\n        <div>\r\n          <input type='range' min='0' max='255' value={blue} onChange={onChangeBlue} />\r\n          <span>{blue}</span>\r\n        </div>\r\n      </div>\r\n      <div css={style.colorView} />\r\n    </div>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n<Image src='https://drive.google.com/file/d/1s7jfIpnPyCk5uyjlHFs-VIJxqULQcyZi/view?usp=drive_link' alt='배경색으로 잘 들어가는 모습' drive />\r\n\r\n잘 적용되는 것을 볼 수 있습니다. 이제 이걸 이용해서 디자인을 조금 개선하고 조금 더 효율적으로 이용할 수 있도록 개선하려고 합니다. 최종적..까지는 아니더라도 개선된 모습은 아래와 같습니다.\r\n\r\n<CodeBlock title='colorSliders.tsx'>\r\n```tsx\r\nimport React, {\r\n  ChangeEvent, useCallback, useMemo, useState\r\n} from 'react';\r\nimport tw, { css } from 'twin.macro';\r\nimport { useAppDispatch } from '@/hooks/rtk';\r\nimport { setBgColor, setTextColor } from '@/redux';\r\n\r\ninterface Props {\r\n  align?: ('horizontal' | 'vertical');\r\n  type?: ('text' | 'background');\r\n}\r\n\r\nexport function ColorSlider({ align = 'vertical', type = 'background', }: Props) {\r\n  const [ red, setRed, ] = useState(50);\r\n  const [ green, setGreen, ] = useState(50);\r\n  const [ blue, setBlue, ] = useState(50);\r\n\r\n  const dispatch = useAppDispatch();\r\n\r\n  const onChangeRed = useCallback(\r\n    (event: ChangeEvent<HTMLInputElement>) => {\r\n      setRed(+event.target.value);\r\n      setColor([ +event.target.value, green, blue, ]);\r\n    },\r\n    [ green, blue, ]\r\n  );\r\n\r\n  const onChangeGreen = useCallback(\r\n    (event: ChangeEvent<HTMLInputElement>) => {\r\n      setGreen(+event.target.value);\r\n      setColor([ red, +event.target.value, blue, ]);\r\n    },\r\n    [ red, blue, ]\r\n  );\r\n\r\n  const onChangeBlue = useCallback(\r\n    (event: ChangeEvent<HTMLInputElement>) => {\r\n      setBlue(+event.target.value);\r\n      setColor([ red, green, +event.target.value, ]);\r\n    },\r\n    [ red, green, ]\r\n  );\r\n\r\n  function convertHex(number: number) {\r\n    const hex = number.toString(16).toUpperCase();\r\n\r\n    return hex.length > 1\r\n      ? hex\r\n      : `0${hex}`;\r\n  }\r\n\r\n  function setColor(colors: number[]) {\r\n    const hex = colors.map((color) => convertHex(color));\r\n\r\n    if (type === 'background') {\r\n      dispatch(setBgColor({\r\n        value: `#${hex.join('')}`,\r\n      }));\r\n    } else {\r\n      dispatch(setTextColor({\r\n        value: `#${hex.join('')}`,\r\n      }));\r\n    }\r\n  }\r\n\r\n  const hexCode = useMemo(() => {\r\n    const hex = [ red, green, blue, ]\r\n      .map((color) => convertHex(color));\r\n\r\n    return `#${hex.join('')}`;\r\n  }, [ red, green, blue, ]);\r\n\r\n  const style = {\r\n    container: css([\r\n      align === 'vertical' && tw` flex w-full `,\r\n      align === 'horizontal' && tw` flex flex-col gap-2 w-full `,\r\n    ]),\r\n    colorSliders: css([\r\n      align === 'vertical' && tw` flex flex-col justify-between flex-1 shrink-0 `,\r\n      align === 'horizontal' && tw` order-2 flex flex-row `,\r\n      tw` [>div]:( flex flex-row items-center flex-1 shrink-0 ) `,\r\n      tw` [span]:( shrink-0 basis-[100px] text-center font-black text-black-base text-big ) `,\r\n    ]),\r\n    slider: css([\r\n      tw` appearance-none bg-black-100 outline-none h-10 flex-1 shrink-0 overflow-hidden `,\r\n      tw` [&::-webkit-slider-thumb]:( appearance-none w-10 aspect-square bg-blue-500 cursor-pointer shadow-[-520px_0_0_500px] shadow-blue-300 ) `,\r\n    ]),\r\n    colorView: css([\r\n      (css`\r\n        background-color: ${hexCode};\r\n      `),\r\n      align === 'vertical' && tw` w-[150px] aspect-square border-2 border-[black] `,\r\n      align === 'horizontal' && tw` w-full h-20 border-2 border-[black] order-1 `,\r\n    ]),\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <div css={style.container}>\r\n        <div css={style.colorSliders}>\r\n          <div>\r\n            <input\r\n              type='range'\r\n              min={0}\r\n              max={255}\r\n              value={red}\r\n              onChange={onChangeRed}\r\n              css={style.slider}\r\n            />\r\n            <span>{red}</span>\r\n          </div>\r\n          <div>\r\n            <input\r\n              type='range'\r\n              min={0}\r\n              max={255}\r\n              value={green}\r\n              onChange={onChangeGreen}\r\n              css={style.slider}\r\n            />\r\n            <span>{green}</span>\r\n          </div>\r\n          <div>\r\n            <input\r\n              type='range'\r\n              min={0}\r\n              max={255}\r\n              value={blue}\r\n              onChange={onChangeBlue}\r\n              css={style.slider}\r\n            />\r\n            <span>{blue}</span>\r\n          </div>\r\n        </div>\r\n        <div css={style.colorView} />\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n`colorSliders.tsx` 컴포넌트에서는 색상이 선택될 때마다 리덕스를 통해 저장하는 방식으로 구현되었습니다. 아직 썸네일에 연결하지는 않았는데 연결하는 방법은 사실 간단합니다. 나중에 해보도록 하고 이 컴포넌트는 아래와 같이 사용하면 됩니다.\r\n\r\n<CodeBlock title='BackgroundConfig.tsx'>\r\n```tsx\r\nimport React, { useCallback } from 'react';\r\nimport tw, { css } from 'twin.macro';\r\nimport { useAppDispatch, useAppSelector } from '@/hooks/rtk';\r\nimport { setBgType } from '@/redux';\r\nimport { ColorSlider } from '.';\r\n\r\nexport function BackgroundConfig() {\r\n  const bgType = useAppSelector(\r\n    (state) => state.app.bgType\r\n  );\r\n  const dispatch = useAppDispatch();\r\n\r\n  const onClickColor = useCallback(\r\n    () => {\r\n      dispatch(setBgType({\r\n        value: 'color',\r\n      }));\r\n    },\r\n    []\r\n  );\r\n\r\n  const onClickImage = useCallback(\r\n    () => {\r\n      dispatch(setBgType({\r\n        value: 'image',\r\n      }));\r\n    },\r\n    []\r\n  );\r\n\r\n  const style = {\r\n    colors: tw` flex mt-10 border border-b-0 border-black-200 divide-x divide-black-200 `,\r\n    bgTypeTab: (type: string) => {\r\n      return css([\r\n        tw` p-3 flex-1 shrink-0 `,\r\n        bgType === type\r\n          ? tw` bg-white text-black-base `\r\n          : tw` bg-black-200 text-black-400 `,\r\n      ]);\r\n    },\r\n    tabBottom: css([\r\n      tw` flex flex-row border border-black-200 border-t-0 p-5 bg-white mb-10 `,\r\n    ]),\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <div css={style.colors}>\r\n        <button css={style.bgTypeTab('color')} onClick={onClickColor}>단색 배경</button>\r\n        <button css={style.bgTypeTab('image')} onClick={onClickImage}>이미지 배경</button>\r\n      </div>\r\n\r\n      {bgType === 'color' && (\r\n        <div css={[ style.tabBottom, tw` flex-col gap-5 `, ]}>\r\n          <ColorSlider type='background' align='vertical' />\r\n          <ColorSlider type='background' align='horizontal' />\r\n        </div>\r\n      )}\r\n\r\n      {bgType === 'image' && (\r\n        <div css={style.tabBottom}>\r\n          {/* <input type='text' id='image-src' placeholder='이미지 주소를 입력하세요' /> */}\r\n        </div>\r\n      )}\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n<Image src='https://drive.google.com/file/d/11pv1RpIKBrw7GLTcdLpOmnf5nGgXzOp_/view?usp=drive_link' alt='경우에 따라서 다르게 사용되는 모습' drive />\r\n\r\n`type` 프롭과 `align` 프롭을 받으면 아래처럼 모양이 바뀌기도 하고 저장되는 중앙 스테이트가 달라지기도 합니다. 색상은 텍스트와 배경 둘 다 사용될 것이기 때문에 이렇게 만들어두었습니다. 이 컴포넌트의 경우에는 기능이 조금 더 개선될 수도 있지만 아직까지는 이정도면 충분한 것 같습니다.\r\n\r\n# 마치며\r\n글이 너무 길어지는 것 같아서 이번 글은 이 쯤에서 마무리 하는 것으로 하고 다음 글에서부터 이어서 진행하도록 하겠습니다. 다음 글에서는 색상 배경 설정 마무리와 텍스트 색상 설정과 이미지 배경 설정을 다뤄보도록 하겠습니다.\r\n"},{"id":7,"content":"\r\n# 개요\r\n지난 글에서 배경 색상 슬라이더를 만들어서 색상을 설정하는 부분까지 진행했습니다. 이번 글에서는 세가지 부분에 대해서 목표를 설정하고 진행하려고 합니다. 바로 본론으로 넘어가서 정리를 하고 시작해보도록 합시다.\r\n\r\n# 구현 목표\r\n이번 글의 목표는 세가지입니다. 첫번째는 **텍스트 색상 설정 구현**입니다. 지금은 제목과 부제만 설정하도록 되어있는데, 텍스트의 색상도 설정할 수 있게 만들 것입니다. 두 번째는 **이미지 배경 설정 구현**입니다. 마지막은 설정한 색상 혹은 이미지를 **썸네일 부분에 적용**하는 작업입니다. 배경 설정은 이번 글에서 마무리를 하고 넘어가려면 이 내용들을 해결해야 합니다.\r\n\r\n그럼 본격적으로 시작해보도록 합시다.\r\n\r\n## 텍스트 색상 설정 구현\r\n<CodeBlock title='TextConfig.tsx'>\r\n```tsx {4, 6-7, 12, 34-37}\r\nexport function TextConfig() {\r\n  const style = {\r\n    inputs: css([\r\n      tw` space-y-2 p-5 bg-white border-2 border-t-0 border-black-600 `,\r\n    ]),\r\n    h2: tw` text-h2 text-white font-black p-3 bg-black-600 `,\r\n    span: tw` font-semibold text-normal text-black-base `,\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <h2 css={style.h2}>텍스트 설정</h2>\r\n      <div css={style.inputs}>\r\n        <label htmlFor='title' css={style.input}>\r\n          <span>제목</span>\r\n          <input\r\n            type='text'\r\n            id='title'\r\n            placeholder='제목'\r\n            value={title}\r\n            onChange={onChangeTitle}\r\n          />\r\n        </label>\r\n        <label htmlFor='sub-title' css={style.input}>\r\n          <span>부제</span>\r\n          <input\r\n            type='text'\r\n            id='sub-title'\r\n            placeholder='부제'\r\n            value={subTitle}\r\n            onChange={onChangeSubTitle}\r\n          />\r\n        </label>\r\n        <div>\r\n          <span css={style.span}>색상</span>\r\n          <ColorSlider type='text' />\r\n        </div>\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n<Image src='https://drive.google.com/file/d/1fDHJow1Sy0JpueB-lJBAGNPsnrkNQu6W/view?usp=drive_link' alt='텍스트 색상 설정까지 구현 완료' drive />\r\n\r\n텍스트 색상 설정은 미리 만들어둔 `ColorSlider` 컴포넌트를 붙여주기만 하면 됩니다. 그 작업을 하면서 디자인을 살짝 수정해봤습니다. 텍스트 설정과 배경 설정 부분이 너무 구분이 가지 않아서 구분이 갈 정도로만 이렇게 수정했습니다. **4번**과 **6-7번**으로 스타일링을 하고 **12번**에 제목을 붙이고 **34-37번**에 `ColorSlider` 컴포넌트를 붙여줬습니다.\r\n\r\n`ColorSlider` 컴포넌트에서 중요한 부분은 `type` 프롭을 `text`로 설정하는 겁니다. 그리고 `ColorSlider` 컴포넌트에서는 아래와 같이 로직을 구현해둡니다.\r\n\r\n<CodeBlock title='ColorSlider.tsx'>\r\n```tsx {2, 7, 15, 23, 36-48}\r\nexport function ColorSlider({ align = 'vertical', type = 'background', }: Props) {\r\n  const dispatch = useAppDispatch();\r\n\r\n  const onChangeRed = useCallback(\r\n    (event: ChangeEvent<HTMLInputElement>) => {\r\n      setRed(+event.target.value);\r\n      setColor([ +event.target.value, green, blue, ]);\r\n    },\r\n    [ green, blue, ]\r\n  );\r\n\r\n  const onChangeGreen = useCallback(\r\n    (event: ChangeEvent<HTMLInputElement>) => {\r\n      setGreen(+event.target.value);\r\n      setColor([ red, +event.target.value, blue, ]);\r\n    },\r\n    [ red, blue, ]\r\n  );\r\n\r\n  const onChangeBlue = useCallback(\r\n    (event: ChangeEvent<HTMLInputElement>) => {\r\n      setBlue(+event.target.value);\r\n      setColor([ red, green, +event.target.value, ]);\r\n    },\r\n    [ red, green, ]\r\n  );\r\n\r\n  function convertHex(number: number) {\r\n    const hex = number.toString(16).toUpperCase();\r\n\r\n    return hex.length > 1\r\n      ? hex\r\n      : `0${hex}`;\r\n  }\r\n\r\n  function setColor(colors: number[]) {\r\n    const hex = colors.map((color) => convertHex(color));\r\n\r\n    if (type === 'background') {\r\n      dispatch(setBgColor({\r\n        value: `#${hex.join('')}`,\r\n      }));\r\n    } else {\r\n      dispatch(setTextColor({\r\n        value: `#${hex.join('')}`,\r\n      }));\r\n    }\r\n  }\r\n\r\n  const hexCode = useMemo(() => {\r\n    const hex = [ red, green, blue, ]\r\n      .map((color) => convertHex(color));\r\n\r\n    return `#${hex.join('')}`;\r\n  }, [ red, green, blue, ]);\r\n\r\n  return (\r\n    <>\r\n      {/* 중략 */}\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n이로써 `type` 프롭이 `text`냐 아니냐에 따라서 배경 색상 설정 혹은 텍스트 색상 설정이 됩니다. 그리고 이 색상은 슬라이더를 조작할 때마다 값이 저장되면서 썸네일에 표시될 것입니다. 지금은 연결을 하지는 않았지만 값 자체는 저장하고 있는 상태입니다.\r\n\r\n**2번**에서 액션 실행을 위한 디스패치를 준비하고 **36-48번**에서 `type` 프롭에 따라 `bgColor` 혹은 `textColor`에 값을 저장하는 함수를 만들어뒀습니다. 그리고 이 함수는 **7번**, **15번**, **23번**에서 사용되고 슬라이더를 조작할 때마다 새로운 값이 갱신됩니다. 이 값을 연결만 하면 됩니다. 이건 가장 마지막에 해보도록 합시다.\r\n\r\n## 이미지 배경 설정 구현\r\n자 이제 이미지 배경 설정을 해볼 시간입니다. 이미지 배경은 두가지 경우를 생각하고 있습니다. 하나는 이미 존재하는 이미지를 웹의 어딘가에서 가져와서 적용하는 것이고 또 다른 하나는 로컬에 있는 이미지를 이용해서 적용하는 것입니다. 전자는 이미지 주소를 붙여넣으면 되고 후자는 `FileReader`를 이용해 URL을 만들어줘야 합니다.\r\n\r\n하지만 지금은 급한대로 첫번째 경우를 우선 적용해서 만들고 후에 두번째 경우도 추가적으로 구현하는 것으로 방향을 잡고 작업을 진행하려고 합니다.\r\n\r\n<CodeBlock title='BackgroundConfig.tsx'>\r\n```tsx {2, 10-18, 24-27, 31, 34-37, 56-65}\r\nexport function BackgroundConfig() {\r\n  const [ srcValue, setSrcValue, ] = useState('');\r\n\r\n  const bgType = useAppSelector(\r\n    (state) => state.app.bgType\r\n  );\r\n\r\n  const dispatch = useAppDispatch();\r\n\r\n  const onChangeSrc = useCallback(\r\n    (event: ChangeEvent<HTMLInputElement>) => {\r\n      setSrcValue(event.target.value);\r\n      dispatch(setImg({\r\n        value: event.target.value,\r\n      }));\r\n    },\r\n    []\r\n  );\r\n\r\n  const style = {\r\n    colors: tw` flex mt-10 `,\r\n    bgTypeTab: (type: string) => {\r\n      return css([\r\n        tw` p-3 flex-1 shrink-0 text-h2 font-black border-2 border-b-0 `,\r\n        bgType === type\r\n          ? tw` bg-black-600 text-white border-black-600 `\r\n          : tw` bg-black-200 text-black-400 border-black-200 `,\r\n      ]);\r\n    },\r\n    tabBottom: css([\r\n      tw` flex flex-row border-2 border-black-600 p-5 bg-white mb-10 `,\r\n    ]),\r\n    input: css([\r\n      tw` flex flex-col gap-1 w-full `,\r\n      tw` [span]:( font-semibold text-normal text-black-base ) `,\r\n      tw` [input]:( p-2 outline-none text-normal bg-black-100 text-black-base placeholder:text-black-300 border-b-[2px] border-transparent transition-colors duration-200 ) `,\r\n      tw` [input]:( focus:( border-blue-500 ) ) `,\r\n    ]),\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <div css={style.colors}>\r\n        <button css={style.bgTypeTab('color')} onClick={onClickColor}>단색 배경</button>\r\n        <button css={style.bgTypeTab('image')} onClick={onClickImage}>이미지 배경</button>\r\n      </div>\r\n\r\n      {bgType === 'color' && (\r\n        <div css={style.tabBottom}>\r\n          <ColorSlider type='background' align='vertical' />\r\n        </div>\r\n      )}\r\n\r\n      {bgType === 'image' && (\r\n        <div css={style.tabBottom}>\r\n          <label htmlFor='image-src' css={style.input}>\r\n            <span>이미지 주소</span>\r\n            <input\r\n              type='text'\r\n              id='image-src'\r\n              placeholder='이미지 주소를 입력하세요'\r\n              value={srcValue}\r\n              onChange={onChangeSrc}\r\n            />\r\n          </label>\r\n        </div>\r\n      )}\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n<Image src='https://drive.google.com/file/d/1fB3iszOetmo9nua7-i8Ff9YBPVUuWiHi/view?usp=drive_link' alt='단색 배경 탭' drive />\r\n<Image src='https://drive.google.com/file/d/1NSUFEhyqPGkeDgcb9-KJe3OcpKYVsafR/view?usp=drive_link' alt='이미지 배경 탭' drive />\r\n\r\n**56-65번**의 `input` 태그를 통해서 이미지의 주소를 입력하면 **10-18번**의 `onChangeSrc` 함수가 실행되는데, 여기서 중요한 것은 `setImg` 액션입니다. `setImg` 액션을 통해 중앙 저장소에 저장되는 구조를 갖고 있습니다. 폼 요소를 컨트롤 해야 하기 때문에 `useState` 함수로 스테이트를 만들어서 관리도 합니다. `useState` 함수를 통한 바인딩은 말 그대로 바인딩 때문에 하는 것이므로 중요도는 떨어집니다. 없으면 안되지만 말이죠.\r\n\r\n지금까지 각 컴포넌트에서 사용된 리덕스의 액션들은 컴포넌트를 넘나들면서 값을 설정하고 가장 마지막에 `Thumbnail` 컴포넌트에서 설정한 값들을 불러와 실제로 적용할 수 있게 만들어줍니다. 이제 마지막으로 썸네일에 설정을 적용하는 일만 남았습니다.\r\n\r\n## 썸네일에 색상과 이미지 적용\r\n`Thumbnail.tsx` 파일을 열어봅니다.\r\n\r\n<CodeBlock title='Thumbnail.tsx'>\r\n```tsx {3}\r\nexport function Thumbnail() {\r\n  const {\r\n    title, subTitle, bgType, imgSrc, bgColor, textColor,\r\n  } = useAppSelector(\r\n    (state) => state.app\r\n  );\r\n\r\n  // 생략\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n먼저 지금까지 설정한 내용들을 사용하기 위해 전부 불러옵니다. 제목과 부제는 연결이 되어있으니까 신경 안써도 괜찮습니다. 먼저 텍스트 색상을 처리하도록 합시다. 그 전에 사용자의 정신 건강을 위해 `ColorSlider` 컴포넌트를 살짝 수정합니다.\r\n\r\n<CodeBlock title='ColorSlider.tsx'>\r\n```tsx {2-4, 8-10}\r\nexport function ColorSlider({ align = 'vertical', type = 'background', }: Props) {\r\n  const [ red, setRed, ] = useState(type === 'text' ? 51 : 255);\r\n  const [ green, setGreen, ] = useState(type === 'text' ? 51 : 255);\r\n  const [ blue, setBlue, ] = useState(type === 'text' ? 51 : 255);\r\n\r\n  const dispatch = useAppDispatch();\r\n\r\n  useEffect(() => {\r\n    setColor([ red, green, blue, ]);\r\n  }, []);\r\n\r\n  // 생략\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n**2-4번**의 스테이트의 기본값을 `type` 프롭에 따라 설정합니다. 텍스트는 기본값이 검은색이고 배경은 기본값이 흰색입니다. 둘 다 검은색이면 귀찮으니까 이렇게 바꿔줍니다. **8-10번**은 컴포넌트가 렌더링되는 그 순간에 값을 저장하는 로직입니다.\r\n\r\n이렇게 하고 다시 `Thumbnail` 컴포넌트로 돌아갑시다.\r\n\r\n<CodeBlock title='Thumbnail.tsx'>\r\n```tsx {11-13}\r\nexport function Thumbnail() {\r\n  const {\r\n    title, subTitle, bgType, imgSrc, bgColor, textColor,\r\n  } = useAppSelector(\r\n    (state) => state.app\r\n  );\r\n\r\n  const style = {\r\n    frame: css([\r\n      tw` box-content border-2 border-black-600 aspect-video mb-10 relative `,\r\n      (css`\r\n        color: ${textColor};\r\n      `),\r\n    ]),\r\n    titles: css([\r\n      tw` absolute top-[50%] translate-y-[-50%] left-[50%] translate-x-[-50%] text-center w-full `,\r\n    ]),\r\n    title: css([\r\n      tw` text-[4rem] font-black whitespace-pre-line `,\r\n    ]),\r\n    subTitle: css([\r\n      tw` text-[3rem] font-semibold `,\r\n    ]),\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <div id='th-frame' css={style.frame}>\r\n        {/* 중략 */}\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n11-13번처럼 CSS에서 `color` 속성을 설정해주면 이제 이렇게 슬라이더를 움직이면 썸네일의 텍스트 색상도 바뀝니다.\r\n\r\n<Image src='https://drive.google.com/file/d/1l_BPmHcK3zw1fBvmNeJDSC4qC8ec-SOt/view?usp=drive_link' alt='슬라이더를 움직여봅시다' drive />\r\n<Image src='https://drive.google.com/file/d/1XRd-JlewWj7veR8659LcFJilrOSzGxIy/view?usp=drive_link' alt='썸네일에 적용된 모습' drive />\r\n\r\n이제 배경 설정을 해봅시다. 배경 설정은 `bgType` 에 따라서 `bgColor` 혹은 `imgSrc` 로 연결해서 설정해주면 됩니다.\r\n\r\n<CodeBlock title='Thumbnail.tsx'>\r\n```tsx {14-19}\r\nexport function Thumbnail() {\r\n  const {\r\n    title, subTitle, bgType, imgSrc, bgColor, textColor,\r\n  } = useAppSelector(\r\n    (state) => state.app\r\n  );\r\n\r\n  const style = {\r\n    frame: css([\r\n      tw` box-content border-2 border-black-600 aspect-video mb-10 relative `,\r\n      (css`\r\n        color: ${textColor};\r\n      `),\r\n      bgType === 'color' && (css`\r\n        background-color: ${bgColor};\r\n      `),\r\n      bgType === 'image' && (css`\r\n        background: url(${imgSrc});\r\n      `),\r\n    ]),\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <div id='th-frame' css={style.frame}>\r\n        {/* 중략 */}\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n`bgType` 이 **color**면 `background-color` 속성에 연결하고 **image**면 `background` 속성에다가 `url()` 안에 넣어주면 됩니다.\r\n\r\n# 마치며\r\n세세한 부분은 다음 글에서 처리를 하도록 하고 배경 설정의 결과물을 보여드리면서 이번 글은 마치도록 하겠습니다. 목적 달성은 했으니 다음 글은 정리를 좀 더 하고 다음 스텝으로 넘어가면 되겠습니다.\r\n\r\n<Image src='https://drive.google.com/file/d/1e8FGDoZBdGuitIdh837SfS3r1L21IgHC/view?usp=drive_link' alt='배경 설정 슬라이더를 움직여보자' drive />\r\n<Image src='https://drive.google.com/file/d/1sRz4mAkcYvtTQqqN7Vk0V6UkhfcGkS5D/view?usp=drive_link' alt='배경 색상이 적용된 모습이다' drive />\r\n\r\n슬라이더를 조작하면 잘 작동합니다.\r\n\r\n<Image src='https://drive.google.com/file/d/1RiXkiASNxRpzifG45yV_NImYeW1b3LJS/view?usp=drive_link' alt='이미지 주소를 넣어봅니다' drive />\r\n<Image src='https://drive.google.com/file/d/1GfUpN5L2cX6jR2Ojah5z93cfsFqkXjpb/view?usp=drive_link' alt='이미지가 배경에 잘 들어옵니다' drive />\r\n\r\n이미지 주소를 가져와서 넣어도 잘 동작합니다. 이제 이 부분은 애초부터 16:9인 이미지만 배경에 넣게 하거나 하는 등으로 제한을 두면 되지 않을까 싶기도 합니다. 아무튼 이번 글은 여기까지입니다!\r\n"},{"id":8,"content":"\r\n# 개요\r\n저번 글에서는 배경이미지 설정까지 진행하고 글을 마쳤었습니다. 이번 글에서는 저번에 미처 신경쓰지 못한 배경 이미지 설정의 마무리를 진행하고, 색상 슬라이더를 살짝 손 볼 생각입니다. 문제가 있었거든요. 사용자가 설정한 내용이 적용된 썸네일을 이미지로 생성하는 것까지 진행하려고 합니다.\r\n\r\n# 배경 이미지 설정 보완\r\n<CodeBlock title='Thumbnail.tsx'>\r\n```tsx\r\nconst style = {\r\n  frame: css([\r\n    tw` box-content border-2 border-black-600 aspect-video mb-10 relative `,\r\n    (css`\r\n      color: ${textColor};\r\n    `),\r\n    bgType === 'color' && (css`\r\n      background-color: ${bgColor};\r\n    `),\r\n    bgType === 'image' && (css`\r\n      background-image: url(${imgSrc});\r\n    `),\r\n  ]),\r\n};\r\n```\r\n</CodeBlock>\r\n\r\n`bgType` 이 **image** 일 때에는 `background-image` 를 설정하게끔 만들었었습니다. 하지만 문제가 있죠.\r\n\r\n<Image src='https://drive.google.com/file/d/1xQHaE0vJwRQfejc2GKnRY1qcYGjtL-CX/view?usp=drive_link' alt='현재 배경의 문제점' drive />\r\n\r\n`background-image` 로 배경을 넣으면 위의 스샷처럼 이미지가 바둑판처럼 반복되는 문제가 생깁니다. 우리가 원하는 건 이런 게 아니죠. 이 부분을 개선해야합니다. 처음부터 이미지를 규격에 맞는 것을 고르면 문제가 사라지지만 규격에 맞지 않아도 배경으로 사용하고 싶은 경우도 있습니다.\r\n\r\n## CSS 개선\r\n\r\n그래서 두가지 속성을 추가하려고 합니다. `background-size` 와 `background-position-y` 를 이용해서 원하는 부분을 배경으로 사용할 수 있게끔 할겁니다. 위의 코드를 아래와 같이 수정해봅시다.\r\n\r\n<CodeBlock title='Thumbnail.tsx'>\r\n```tsx\r\nconst style = {\r\n  frame: css([\r\n    tw` box-content border-2 border-black-600 aspect-video mb-10 relative `,\r\n    (css`\r\n      color: ${textColor};\r\n    `),\r\n    bgType === 'color' && (css`\r\n      background-color: ${bgColor};\r\n    `),\r\n    bgType === 'image' && (css`\r\n      background-image: url(${imgSrc});\r\n      background-size: cover;\r\n      background-position-y: -220px;\r\n    `),\r\n  ]),\r\n};\r\n```\r\n</CodeBlock>\r\n\r\n이렇게 하면 더이상 바둑판처럼 보이지 않고 화면을 꽉 채우기 때문에 조금 더 보기 좋아지죠. 그리고 Y 좌표를 조작해서 원하는 부분을 볼 수 있습니다. 위의 코드상으로는 **-220px** 이라고 되어있는데 220 픽셀만큼 아래로 내리겠다 라는 의미입니다.\r\n\r\n문제는 여기서 220을 우리가 원하는 값으로 바꿀 수 있어야합니다. 중앙 저장소에 스테이트를 하나 추가하고 새롭게 관리하도록 하면 되겠죠.\r\n\r\n## 리듀서에서 스테이트와 액션 추가하기\r\n\r\n<CodeBlock title='app.reducer.ts'>\r\n```ts {8, 18, 32, 34-39, 44}\r\ntype AppState = {\r\n  bgType: ('color' | 'image');\r\n  title: string;\r\n  subTitle: string;\r\n  textColor: string;\r\n  bgColor: string;\r\n  imgSrc: string;\r\n  imageY: number;\r\n}\r\n\r\nconst initialState: AppState = {\r\n  bgType: 'color',\r\n  title: '제목을 입력하세요',\r\n  subTitle: '',\r\n  textColor: '#333333',\r\n  bgColor: '#FFFFFF',\r\n  imgSrc: '',\r\n  imageY: 0,\r\n};\r\n\r\nconst appReducer = createSlice({\r\n  name: 'app',\r\n  initialState,\r\n  reducers: {\r\n    initState(state) {\r\n      state.bgType = 'color';\r\n      state.title = '제목을 입력하세요';\r\n      state.subTitle = '';\r\n      state.textColor = '#333333';\r\n      state.bgColor = '#FFFFFF';\r\n      state.imgSrc = '';\r\n      state.imageY = 0;\r\n    },\r\n    setY(\r\n      state,\r\n      { payload, }: PayloadAction<{value: number}>\r\n    ) {\r\n      state.imageY = payload.value;\r\n    },\r\n  },\r\n});\r\n\r\nexport const {\r\n  initState, setBgType, setTitle, setSubTitle, setTextColor, setBgColor, setImg, setY,\r\n} = appReducer.actions;\r\n```\r\n</CodeBlock>\r\n\r\n`AppState` 타입에 `imageY`를 추가하고 `initialState`에도 추가를 해줍니다. `initState` 액션에서 `imageY`를 초기화하는 부분을 추가하고 `setY` 액션을 만들어서 내보냅니다. 자 이제 `BackgroundConfig` 컴포넌트로 가서 추가 로직을 구현해봅시다.\r\n\r\n## 새롭게 추가한 좌표 스테이트 적용하기\r\n\r\n<CodeBlock title='BackgroundConfig.tsx'>\r\n```tsx\r\nimport { setY as setImageY } from '@/redux';\r\n\r\nexport function BackgroundConfig() {\r\n  const [ y, setY, ] = useState(0);\r\n\r\n  const onChangeY = useCallback(\r\n    (event: ChangeEvent<HTMLInputElement>) => {\r\n      setY(+event.target.value);\r\n      dispatch(setImageY({\r\n        value: +event.target.value,\r\n      }));\r\n    },\r\n    []\r\n  );\r\n\r\n  return (\r\n    <>\r\n      {/* --- */}\r\n      {bgType === 'image' && (\r\n        <div css={style.tabBottom}>\r\n          {/* --- */}\r\n\r\n          <label htmlFor='image-y' css={style.input}>\r\n            <span>Y좌표</span>\r\n            <input\r\n              type='text'\r\n              id='image-y'\r\n              placeholder='원하는 좌표를 입력하세요'\r\n              value={y}\r\n              onChange={onChangeY}\r\n            />\r\n          </label>\r\n        </div>\r\n      )}\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n<Image src='https://drive.google.com/file/d/1sN-U2AR27Zw_S9cOSeQuYrRtNRjF-ZG_/view?usp=drive_link' alt='좌표를 설정할 수 있게 개선' drive />\r\n\r\ny 좌표는 숫자를 입력하면 입력한 만큼 아래로 내리는 역할을 하게 됩니다. 기본값은 0이고 그 이후에는 원하는 값을 입력하면 되겠죠. `setY` 로는 컴포넌트 내에서 저장을 하고, `setImageY` 액션으로는 중앙 저장소에 저장을 해둡니다.\r\n\r\n자 모든 준비가 끝났습니다. 그럼 이제 마지막으로 `Thumbnail` 컴포넌트에서 적용해보도록 합시다. CSS만 살짝 건드리면 됩니다.\r\n\r\n<CodeBlock title='title'>\r\n```tsx {14}\r\nconst style = {\r\n  frame: css([\r\n    tw` box-content border-2 border-black-600 aspect-video mb-10 relative `,\r\n    (css`\r\n      color: ${textColor};\r\n    `),\r\n    bgType === 'color' && (css`\r\n      background-color: ${bgColor};\r\n    `),\r\n    bgType === 'image' && (css`\r\n      background-image: url(${imgSrc});\r\n      background-size: cover;\r\n      /* background-position-y: -220px; */\r\n      background-position-y: -${imageY}px;\r\n    `),\r\n  ]),\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n숫자 220이 들어가 있던 자리에 변수를 넣어서 대체합니다. **-** 기호를 남겨두는 이유는 매번 - 기호를 입력하는 것보다 그냥 숫자만 입력하는 게 더 사용하기에 편하기 때문입니다. 이렇게 하면 원하는 값을 입력했을 때 썸네일에도 그대로 적용되겠죠.\r\n\r\n<Image src='https://drive.google.com/file/d/1d6x6zT4DKZkfZrnzTK_ADk7LipHJyTMs/view?usp=drive_link' alt='350을 입력함' drive />\r\n<Image src='https://drive.google.com/file/d/1srcRb_oRo8tWuXKMMXtrwePPcV-KTW86/view?usp=drive_link' alt='원하는 위치를 선택할 수 있다!' drive />\r\n\r\n# 색상 슬라이더 보완하기\r\n색상 슬라이더에 문제가 있었습니다. 미리 테스트를 해봤는데 초기화 버튼을 클릭해도 슬라이더의 상태는 초기화되지 않았던 것입니다. 이건 문제가 있기 때문에 해결해야합니다. 해결을 위해 생각을 해본 결과 색상코드 자체를 저장하는 게 아니라 빨간색, 초록색, 파란색 정보를 따로 저장하는 것이 좋겠다라는 결론에 이르렀습니다.\r\n\r\n이를 위해 리듀서를 수정해야합니다.\r\n\r\n## 리듀서 수정하기\r\n<CodeBlock title='app.reducer.ts'>\r\n```ts {1-5, 11-12, 21-30}\r\ntype Color = {\r\n  red: number;\r\n  green: number;\r\n  blue: number;\r\n}\r\n\r\ntype AppState = {\r\n  bgType: ('color' | 'image');\r\n  title: string;\r\n  subTitle: string;\r\n  textColor: Color;\r\n  bgColor: Color;\r\n  imgSrc: string;\r\n  imageY: number;\r\n}\r\n\r\nconst initialState: AppState = {\r\n  bgType: 'color',\r\n  title: '제목을 입력하세요',\r\n  subTitle: '',\r\n  textColor: {\r\n    red: 51,\r\n    green: 51,\r\n    blue: 51,\r\n  },\r\n  bgColor: {\r\n    red: 255,\r\n    green: 255,\r\n    blue: 255,\r\n  },\r\n  imgSrc: '',\r\n  imageY: 0,\r\n};\r\n```\r\n</CodeBlock>\r\n\r\n이런식으로 숫자값 자체를 저장하게 만들어뒀습니다. 이렇게 하지 않으면 값을 인식 못하는 것 같더군요. 그럼 이제 액션도 수정을 해야합니다. 액션도 뭐 간단합니다.\r\n\r\n<CodeBlock title='app.reducer.ts'>\r\n```ts {9-18, 24, 26, 30, 32}\r\nconst appReducer = createSlice({\r\n  name: 'app',\r\n  initialState,\r\n  reducers: {\r\n    initState(state) {\r\n      state.bgType = 'color';\r\n      state.title = '제목을 입력하세요';\r\n      state.subTitle = '';\r\n      state.textColor = {\r\n        red: 51,\r\n        green: 51,\r\n        blue: 51,\r\n      };\r\n      state.bgColor = {\r\n        red: 255,\r\n        green: 255,\r\n        blue: 255,\r\n      };\r\n      state.imgSrc = '';\r\n      state.imageY = 0;\r\n    },\r\n    setTextColor(\r\n      state,\r\n      { payload, }: PayloadAction<{value: Color}>\r\n    ) {\r\n      state.textColor = payload.value;\r\n    },\r\n    setBgColor(\r\n      state,\r\n      { payload, }: PayloadAction<{value: Color}>\r\n    ) {\r\n      state.bgColor = payload.value;\r\n    },\r\n  },\r\n});\r\n```\r\n</CodeBlock>\r\n\r\n이런식으로 기존의 문자열이 아니라 객체를 받게끔 만들어줬습니다. 이렇게 하면 값을 하나 하나 받기 때문에 뿌릴 때에도 하나 하나 뿌려줄 수가 있을 겁니다.\r\n\r\n## ColorSlider 컴포넌트 수정하기\r\n<CodeBlock title='ColorSlider.tsx'>\r\n```tsx\r\nexport default function ColorSlider() {\r\n  const [ red, setRed, ] = useState(type === 'text' ? 51 : 255);\r\n  const [ green, setGreen, ] = useState(type === 'text' ? 51 : 255);\r\n  const [ blue, setBlue, ] = useState(type === 'text' ? 51 : 255);\r\n\r\n  const dispatch = useAppDispatch();\r\n\r\n  useEffect(() => {\r\n    setColor([ red, green, blue, ]);\r\n  }, []);\r\n\r\n  const onChangeRed = useCallback(\r\n    (event: ChangeEvent<HTMLInputElement>) => {\r\n      setRed(+event.target.value);\r\n      setColor([ +event.target.value, green, blue, ]);\r\n    },\r\n    [ green, blue, ]\r\n  );\r\n\r\n  const onChangeGreen = useCallback(\r\n    (event: ChangeEvent<HTMLInputElement>) => {\r\n      setGreen(+event.target.value);\r\n      setColor([ red, +event.target.value, blue, ]);\r\n    },\r\n    [ red, blue, ]\r\n  );\r\n\r\n  const onChangeBlue = useCallback(\r\n    (event: ChangeEvent<HTMLInputElement>) => {\r\n      setBlue(+event.target.value);\r\n      setColor([ red, green, +event.target.value, ]);\r\n    },\r\n    [ red, green, ]\r\n  );\r\n\r\n  function convertHex(number: number) {\r\n    const hex = number.toString(16).toUpperCase();\r\n\r\n    return hex.length > 1\r\n      ? hex\r\n      : `0${hex}`;\r\n  }\r\n\r\n  function setColor(colors: number[]) {\r\n    const hex = colors.map((color) => convertHex(color));\r\n\r\n    if (type === 'background') {\r\n      dispatch(setBgColor({\r\n        value: `#${hex.join('')}`,\r\n      }));\r\n    } else {\r\n      dispatch(setTextColor({\r\n        value: `#${hex.join('')}`,\r\n      }));\r\n    }\r\n  }\r\n\r\n  const hexCode = useMemo(() => {\r\n    const hex = [ red, green, blue, ]\r\n      .map((color) => convertHex(color));\r\n\r\n    return `#${hex.join('')}`;\r\n  }, [ red, green, blue, ]);\r\n\r\n  return (\r\n    // 생략\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n이 코드는 기존의 상태 관리를 하던 로직인데 이제 기존의 스테이트는 필요가 없습니다. 과감하게 지워버리고 다시 작성해봅시다. hex로 변환하는 과정도 이제는 필요가 없죠. 따라서 이 함수들도 지워버려도 됩니다.\r\n\r\n<CodeBlock title='ColorSlider.tsx'>\r\n```tsx\r\n// 변경전\r\nconst [ red, setRed, ] = useState(type === 'text' ? 51 : 255);\r\nconst [ green, setGreen, ] = useState(type === 'text' ? 51 : 255);\r\nconst [ blue, setBlue, ] = useState(type === 'text' ? 51 : 255);\r\n\r\n// 변경후\r\nconst { textColor, bgColor, } = useAppSelector(\r\n  (state) => state.app\r\n);\r\n\r\nconst color = useMemo(() => {\r\n  return type === 'text'\r\n    ? textColor\r\n    : bgColor;\r\n}, [ textColor, bgColor, ]);\r\n```\r\n</CodeBlock>\r\n\r\n스테이트 부분은 이렇게 처리를 했습니다. 여전히 `type` 프롭에 따라서 결정되긴 하지만 중앙 저장소에서 직접 가져오게끔 설정해줬습니다.\r\n\r\n<CodeBlock title='ColorSlider.tsx'>\r\n```tsx\r\n// 변경전\r\nuseEffect(() => {\r\n  setColor([ red, green, blue, ]);\r\n}, []);\r\n\r\n// 변경후\r\nuseEffect(() => {\r\n  setColor([ color.red, color.green, color.blue, ]);\r\n}, []);\r\n```\r\n</CodeBlock>\r\n\r\n`useEffect` 훅 부분은 그냥 변수 호출만 바꿔주면 되죠.\r\n\r\n<CodeBlock title='ColorSlider.tsx'>\r\n```tsx\r\n// 변경전\r\nconst onChangeRed = useCallback(\r\n  (event: ChangeEvent<HTMLInputElement>) => {\r\n    setRed(+event.target.value);\r\n    setColor([ +event.target.value, green, blue, ]);\r\n  },\r\n  [ green, blue, ]\r\n);\r\n\r\nconst onChangeGreen = useCallback(\r\n  (event: ChangeEvent<HTMLInputElement>) => {\r\n    setGreen(+event.target.value);\r\n    setColor([ red, +event.target.value, blue, ]);\r\n  },\r\n  [ red, blue, ]\r\n);\r\n\r\nconst onChangeBlue = useCallback(\r\n  (event: ChangeEvent<HTMLInputElement>) => {\r\n    setBlue(+event.target.value);\r\n    setColor([ red, green, +event.target.value, ]);\r\n  },\r\n  [ red, green, ]\r\n);\r\n\r\nfunction convertHex(number: number) {\r\n  const hex = number.toString(16).toUpperCase();\r\n\r\n  return hex.length > 1\r\n    ? hex\r\n    : `0${hex}`;\r\n}\r\n\r\nfunction setColor(colors: number[]) {\r\n  const hex = colors.map((color) => convertHex(color));\r\n\r\n  if (type === 'background') {\r\n    dispatch(setBgColor({\r\n      value: `#${hex.join('')}`,\r\n    }));\r\n  } else {\r\n    dispatch(setTextColor({\r\n      value: `#${hex.join('')}`,\r\n    }));\r\n  }\r\n}\r\n\r\nconst hexCode = useMemo(() => {\r\n  const hex = [ red, green, blue, ]\r\n    .map((color) => convertHex(color));\r\n\r\n  return `#${hex.join('')}`;\r\n}, [ red, green, blue, ]);\r\n\r\n// 변경후\r\nconst onChangeRed = useCallback(\r\n  (event: ChangeEvent<HTMLInputElement>) => {\r\n    setColor([ +event.target.value, color.green, color.blue, ]);\r\n  },\r\n  [ color.green, color.blue, ]\r\n);\r\n\r\nconst onChangeGreen = useCallback(\r\n  (event: ChangeEvent<HTMLInputElement>) => {\r\n    setColor([ color.red, +event.target.value, color.blue, ]);\r\n  },\r\n  [ color.red, color.blue, ]\r\n);\r\n\r\nconst onChangeBlue = useCallback(\r\n  (event: ChangeEvent<HTMLInputElement>) => {\r\n    setColor([ color.red, color.green, +event.target.value, ]);\r\n  },\r\n  [ color.red, color.green, ]\r\n);\r\n\r\nfunction setColor(colors: number[]) {\r\n  if (type === 'background') {\r\n    dispatch(setBgColor({\r\n      value: {\r\n        red: colors[0],\r\n        green: colors[1],\r\n        blue: colors[2],\r\n      },\r\n    }));\r\n  } else {\r\n    dispatch(setTextColor({\r\n      value: {\r\n        red: colors[0],\r\n        green: colors[1],\r\n        blue: colors[2],\r\n      },\r\n    }));\r\n  }\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n이런식으로 세팅을 바꿔줬더니 기능동작이 잘 되는 것을 볼 수 있었습니다. 초기화가 안되는 문제로 며칠동안 고민했었는데 이제야 해결이 되어 참 다행입니다. 며칠 더 머리아플 뻔 했습니다. 이제 수정의 마무리로 `Thumbnail` 컴포넌트의 일부를 수정하면 됩니다.\r\n\r\n## Thumbnail 컴포넌트 수정하기\r\n<CodeBlock title='Thumbnail.tsx'>\r\n```tsx\r\n// 변경전\r\nconst style = {\r\n  frame: css([\r\n    (css`\r\n      color: ${textColor};\r\n    `),\r\n    bgType === 'color' && (css`\r\n      background-color: ${bgColor};\r\n    `),\r\n  ]),\r\n};\r\n\r\n// 변경후\r\nconst style = {\r\n  frame: css([\r\n    (css`\r\n      color: rgb(${textColor.red}, ${textColor.green}, ${textColor.blue});\r\n    `),\r\n    bgType === 'color' && (css`\r\n      background-color: rgb(${bgColor.red}, ${bgColor.green}, ${bgColor.blue});\r\n    `),\r\n  ]),\r\n};\r\n```\r\n</CodeBlock>\r\n\r\n이제 슬라이더 관련해서는 더 이상 수정할 것이 없습니다. 다음 스텝으로 넘어가봅시다.\r\n\r\n# 이미지 생성하기\r\n아직 많은 부분을 추가하고 보완해야겠지만 원하는 기능은 전부 존재합니다. 텍스트를 입력하고, 배경을 설정할 수 있죠. 이제 마지막, 이미지를 생성하는 일만 남았습니다. 라이브러리를 이용해서 HTML을 CANVAS로 만드는 방법도 있는 것 같고 여러가지 방법있는 것 같은데, 역시 목적 달성을 위해 라이브러리를 사용하도록 합시다.\r\n\r\n<CodeBlock title=''>\r\n```bash\r\nyarn add html2canvas\r\n```\r\n</CodeBlock>\r\n\r\n라이브러리를 설치합니다. 설치할 라이브러리의 이름은 **html2canvas** 입니다. 간단하게 HTML 요소를 캡처해서 파일로 저장할 수 있다고 합니다. 한 번 사용해봅시다. 일단 이렇게 설치를 합니다. 그리고 `index.tsx` 에서 불러와서 사용 해봅시다.\r\n\r\n설정을 한 후에 이미지로 저장 버튼을 클릭하면 이미지로 저장이 되어야합니다. 이걸 건드리면 되겠죠. 초기화 버튼은 이후에 처리하도록 하겠습니다. 일단 이미지부터 만들어봅시다. 아, 생각을 해보니까 버튼의 위치가 애매한 거 같아요. `Thumbnail` 컴포넌트 안으로 옮기도록 하겠습니다.\r\n\r\n<Image src='https://drive.google.com/file/d/1JcwRkJ__MRdK0lPxqIHpKZeINwNHawlO/view?usp=drive_link' alt='기존의 구조' drive />\r\n\r\n원래는 이런 모습이었습니다. 그런데 아래처럼 바꿨습니다. 그러면 `index.tsx` 가 아니라 `Thumbnail` 컴포넌트에서 작업을 하면 되겠죠. 하지만 뭐 코드는 뻔하니까 생략하도록 하고 아래처럼 바꿨습니다.\r\n\r\n<Image src='https://drive.google.com/file/d/1AuVjt5H_IHGBsFXPFGbmvaG4-ip79KGh/view?usp=drive_link' alt='버튼 위치 바꾸기' drive />\r\n\r\n자 아무튼 버튼의 위치를 바꿨으니까 이제 본격적으로 버튼에 기능을 붙여보도록 하겠습니다. 두개의 버튼이 있어요. 초기화 버튼과 이미지로 저장 버튼이 있죠. 이 중에서 이미지로 저장 버튼을 먼저 건드려봅시다.\r\n\r\n<CodeBlock title='Thumbnail.tsx'>\r\n```tsx\r\nexport function Thumbnail() {\r\n  const [ isClick, setIsClick, ] = useState(false);\r\n  const thRef = useRef<HTMLDivElement>(null);\r\n  const imageRef = useRef<HTMLDivElement>(null);\r\n\r\n  const onClickDownload = useCallback(\r\n    () => {\r\n      html2canvas(thRef.current, { allowTaint: true, useCORS: true, }).then((canvas) => {\r\n        const img = document.createElement('img');\r\n        img.src = canvas.toDataURL('image/png');\r\n\r\n        imageRef.current.innerHTML = '';\r\n        imageRef.current.appendChild(img);\r\n      });\r\n\r\n      setIsClick(true);\r\n    },\r\n    [ thRef, imageRef, ]\r\n  );\r\n\r\n  return (\r\n    <>\r\n      {isClick && (\r\n        <div css={style.image} ref={imageRef} onClick={onClickClose} />\r\n      )}\r\n      <div css={style.buttons}>\r\n        <button onClick={onClickDownload}>이미지로 저장</button>\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n가장 먼저 `useState` 훅으로 스테이트를 하나 만듭니다. 여기서만 쓰일 것이기 때문에 중앙 저장소에 만들 필요는 없습니다. 클릭했을 때 이미지가 보이는가 아닌가에 대한 여부를 결정하는 스테이트입니다.\r\n\r\n그 후에 `html2canvas` 함수를 임포트하고 첫번째 인수에 이미지화 하려는 타겟을 넣어줍니다. `thRef.current` 를 넣어줬습니다. 두번째 인수에는 옵션이 들어갑니다. 이미지 관련해서 적용될 수 있도록 세팅을 해줬습니다. `html2canvas`는 비동기이기 때문에 `then` 을 이용해서 성공했을 때의 처리를 해줍니다.\r\n\r\n매개변수 `canvas` 에는 html이 canvas로 변환된 요소가 들어있습니다. 이 요소를 이용해서 이미지를 다운받거나 이미지를 보이게 할 수 있습니다. 저는 이미지 다운로드 쪽으로 가려고 했지만 다운로드는 직접 우클릭해서 하게 하는 게 나을 것 같아서 변환된 이미지를 보여주는 것으로 진행했습니다. 클릭하면 이미지가 나타나게 설계되어 있습니다. 그리고 이미지가 생성 되었어도 취소하고 수정을 할 수 있도록 이미지를 닫을 수 있는 기능도 마련되어 있습니다.\r\n\r\n<Image src='https://drive.google.com/file/d/1UigJi-RmIsnGW29d3tRHr-Pd38XZrEeE/view?usp=drive_link' alt='이미지 생성 성공!' drive />\r\n\r\n이제 초기화 버튼의 기능을 추가해봅시다. 여긴 간단합니다. 이전에 만들어놓은 액션 중에는 스테이트들을 초기화하는 액션도 있었습니다. 그 액션을 사용하면 됩니다.\r\n\r\n<CodeBlock title='Thumbnail.tsx'>\r\n```tsx\r\nexport function Thumbnail() {\r\n  const dispatch = useAppDispatch();\r\n\r\n  const onClickReset = useCallback(\r\n    () => {\r\n      dispatch(initState());\r\n    },\r\n    []\r\n  );\r\n\r\n  return (\r\n    <>\r\n      {isClick && (\r\n        <div css={style.image} ref={imageRef} onClick={onClickClose} />\r\n      )}\r\n      <div css={style.buttons}>\r\n      <button onClick={onClickReset}>초기화</button>\r\n        <button onClick={onClickDownload}>이미지로 저장</button>\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n초기화 버튼을 클릭함으로써 `onClickReset` 함수가 실행되면 `initState` 액션을 통해서 각 스테이트들을 초기화합니다. 그러면 색상이나 텍스트들이 초기화되겠죠.\r\n\r\n아래는 최종 결과물입니다.\r\n\r\n<CodeBlock title='Thumbnail.tsx'>\r\n```tsx\r\nimport React, {\r\n  useCallback, useEffect, useRef, useState\r\n} from 'react';\r\nimport tw, { css } from 'twin.macro';\r\nimport html2canvas from 'html2canvas';\r\nimport { useAppDispatch, useAppSelector } from '@/hooks/rtk';\r\nimport { initState } from '@/redux';\r\n\r\nexport function Thumbnail() {\r\n  const [ isClick, setIsClick, ] = useState(false);\r\n\r\n  const thRef = useRef<HTMLDivElement>(null);\r\n  const imageRef = useRef<HTMLDivElement>(null);\r\n  const dispatch = useAppDispatch();\r\n\r\n  const {\r\n    title, subTitle, bgType, imgSrc, bgColor, textColor, imageY,\r\n  } = useAppSelector(\r\n    (state) => state.app\r\n  );\r\n\r\n  useEffect(() => {\r\n    dispatch(initState());\r\n  }, []);\r\n\r\n  const onClickReset = useCallback(\r\n    () => {\r\n      dispatch(initState());\r\n    },\r\n    []\r\n  );\r\n\r\n  const onClickDownload = useCallback(\r\n    () => {\r\n      html2canvas(thRef.current, { allowTaint: true, useCORS: true, }).then((canvas) => {\r\n        const img = document.createElement('img');\r\n        img.src = canvas.toDataURL('image/png');\r\n\r\n        imageRef.current.innerHTML = '';\r\n        imageRef.current.appendChild(img);\r\n      });\r\n\r\n      setIsClick(true);\r\n    },\r\n    [ thRef, imageRef, ]\r\n  );\r\n\r\n  const onClickClose = useCallback(\r\n    () => {\r\n      setIsClick(false);\r\n    },\r\n    []\r\n  );\r\n\r\n  // 스타일 중략\r\n\r\n  return (\r\n    <>\r\n      {isClick && (\r\n        <div css={style.image} ref={imageRef} onClick={onClickClose} />\r\n      )}\r\n\r\n      <div id='th-container' css={style.container} ref={thRef}>\r\n        <div id='th-frame' css={style.frame}>\r\n          <div id='th-titles' css={style.titles}>\r\n            <h1 id='th-title' css={style.title}>\r\n              {title.split('\\\\n').map((item, index) => (\r\n              // eslint-disable-next-line react/no-array-index-key\r\n                <React.Fragment key={`${item}-${index}`}>{item}<br /></React.Fragment>\r\n              ))}\r\n            </h1>\r\n            <h2 id='th-sub-title' css={style.subTitle}>{subTitle}</h2>\r\n          </div>\r\n        </div>\r\n      </div>\r\n\r\n      <div css={style.buttons}>\r\n        <button onClick={onClickReset}>초기화</button>\r\n        <button onClick={onClickDownload}>이미지로 저장</button>\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n```\r\n</CodeBlock>\r\n\r\n이렇게 해서 이미지 생성과 초기화까지 마쳤습니다. 사실 이제야 기본적인 기능이 갖춰진 것입니다. 앞으로 보완하면서 다듬고 추가적인 기능을 붙이면 될 것 같습니다. 이미지가 생성되었을 때 닫을 수 있다는 것을 의미하는 UI도 만들어야 하겠죠. 예를 들어 X 표시를 만들어둔다던가 해서 이 모달창은 닫을 수 있습니다 라는 메시지를 텍스트 없이도 전달할 수 있겠죠.\r\n\r\n앞으로 해야할 것은 이미지를 생성했을 때 설정 정보가 저장된 json을 자신의 구글 드라이브에 저장할 수 있는 기능과 불러올 수 있는 기능입니다. 이 구글 드라이브 연동 기능도 선택에 따라서 할 수 있게끔 만들 예정입니다. 단발적으로만 사용하고 싶을 경우에는 그냥 구글 드라이브 연동 없이 이미지 생성하면 그만이고\r\n\r\n이 이미지들을 계속해서 관리하고 싶다면 json 데이터를 만들어서 구글 드라이브에 저장하면 이 저장된 데이터를 이용해서 파일들을 불러올 수 있도록 하는 것이죠. 이 프로그램 자체에 회원 관리 시스템이 없더라도 할 수 있게끔 만들어볼 생각입니다.\r\n\r\n이제 슬슬 일정 관리 프로그램도 만들기 시작해야겠습니다. 다음 글이 일정 관리 시작이 될 지 썸네일 생성기 보완이 될 지는 저도 모르겠습니다. 아무튼 이번 목표는 마쳤으니 이만 글을 줄이도록 해야겠습니다.\r\n"},{"id":9,"content":"\r\n# 개요\r\n구글 드라이브와 연동하는 것을 제외하면 기본적인 기능은 완성되었습니다. 하지만 자잘한 문제가 하나 있었습니다. 이번 글에서는 이 문제를 해결하고 다음 스텝으로 나아갈 준비를 하려고 합니다.\r\n\r\n# 문제점 파악\r\n자 그럼 어떤 문제가 있었는지 정리해보도록 합시다. 총 두가지의 문제가 있었습니다. 둘 다 이미지 생성과 관련된 문제였습니다. 하나는 텍스트가 아래로 쏠리는 문제였고, 다른 하나는 이미지가 생성됐을 때 정상적으로 생성되지 않는 문제였습니다. 대강 문제에 대해 살펴보고 어떻게 해결했는지 남기려고 합니다.\r\n\r\n## 이미지 생성시 텍스트가 아래로 쏠리는 문제\r\n이 문제는 텍스트를 입력할 때에는 인지를 못하다가 이미지 생성 테스트를 여러번 해보면서 발견한 문제였습니다.\r\n\r\n<Image src='https://drive.google.com/file/d/15fZdM2rXBS7SBEx8fGlXtMs2YfirQtLW/view?usp=drive_link' alt='썸네일 미리보기에는 문제가 없다' drive />\r\n\r\n위 이미지처럼 썸네일 미리보기에는 텍스트가 올바른 위치에 있는데..\r\n\r\n<Image src='https://drive.google.com/file/d/1g0x9xkrSgT1sJdeTI2qtF_U1AxkKFpQT/view?usp=drive_link' alt='생성된 썸네일에 문제가 있다' drive />\r\n\r\n썸네일 이미지가 생성된 결과물은 그렇지가 않았던 것이죠. 잘 보면 텍스트가 미리보기랑 다르게 아래로 내려가 있던 겁니다. 의도한 모습이 아니니까 이대로 넘어갈 수가 없죠. 그래서 이것이 대체 어떤 일인가 하고 계속 검색을 해봤는데 <A href='https://github.com/niklasvh/html2canvas/issues/2775' external>깃허브 이슈</A>에서 단서를 얻었습니다.\r\n\r\n### 해결\r\n\r\n<CodeBlock>\r\n```tsx {8}\r\nconst onClickDownload = useCallback(\r\n  () => {\r\n    window.scrollTo(0, 0);\r\n\r\n    html2canvas(thRef.current, {\r\n      allowTaint: true,\r\n      useCORS: true,\r\n      foreignObjectRendering: true, // 이 부분 추가\r\n    }).then((canvas) => {\r\n      const img = document.createElement('img');\r\n      img.src = canvas.toDataURL('image/png');\r\n\r\n      imageRef.current.innerHTML = '';\r\n      imageRef.current.appendChild(img);\r\n    });\r\n\r\n    setIsClick(true);\r\n  },\r\n  [ thRef, imageRef, ]\r\n);\r\n```\r\n</CodeBlock>\r\n\r\n이 코드는 이미지 생성 버튼을 눌렀을 때 실행되는 함수입니다. 이 코드에서 표시된 부분을 추가했더니 문제가 사라졌습니다. 설정 관련된 문제였던 것 같아요. 사실 구글링하다가 얻어 걸린 느낌도 있긴한데 아무튼 찾았으니 다행이었습니다. 이 프로젝트가 끝나면 구글링하면서 사용방법을 상세히 알아봐야겠습니다.\r\n\r\n## 브라우저 창의 너비에 따라 이미지가 정상적으로 생성되지 않는 문제\r\n설정을 하나 추가해서 텍스트 문제는 해결을 했는데 이렇게 추가를 하니까 문제점이 또 발생했습니다. 색상을 변경하거나 텍스트 값들이 초기값일 때에 이미지가 정상적으로 생성되지 않는 문제였..다고 생각했으나 알고보니 브라우저 창의 너비 때문이었습니다.\r\n\r\n<Image src='https://drive.google.com/file/d/1vJ-IY7ZfkbqrQhDYZiT9hWSXYUbtihJb/view?usp=drive_link' alt='새로운 문제...' drive />\r\n\r\n도저히 무엇이 문제인지 모르겠어서 구글링만 겁나게 했지만 그렇다할 자료는 찾지 못했는데, html2canvas에서 지원하는 로깅 기능을 켜봤습니다.\r\n\r\n<CodeBlock title=''>\r\n```tsx {5}\r\nhtml2canvas(thRef.current, {\r\n  allowTaint: true,\r\n  useCORS: true,\r\n  foreignObjectRendering: true,\r\n  logging: true,\r\n}).then((canvas) => {\r\n  const img = document.createElement('img');\r\n  img.src = canvas.toDataURL('image/png');\r\n  img.style.display = 'block';\r\n\r\n  imageRef.current.innerHTML = '';\r\n  imageRef.current.appendChild(img);\r\n});\r\n```\r\n</CodeBlock>\r\n\r\n이렇게 하면 자동으로 로깅이 되는데 이미지가 생성 될 때마다 로그가 쌓이게 됩니다. 그럼 이제 이미지를 생성해봅시다.\r\n\r\n<Image src='https://drive.google.com/file/d/1oSZdRiz-VeQM7jsyCs0VVAQN5Kf3Vh9T/view?usp=drive_link' alt='' drive />\r\n\r\n이미지를 보면 어떤 상태인지 알 수 있는데, 빨간 사각형으로 표시된 부분에 중요한 정보가 있었습니다. **(1280x720 at 297,0)** 이미지의 해상도가 나타나고, 297과 0은 포지션을 의미하는 것 같습니다. 이 297이 뭘 의미하는 것인가를 알 수가 없어서 몇번을 더 테스트해봤는데 바로 요소의 양 옆 `margin` 값이었습니다.\r\n\r\n`margin` 값이었다는 것을 알게 되었으니 이걸 해결하려면 `margin` 값을 알아내야합니다.\r\n\r\n### 해결\r\nmargin 값을 알아내기 위해서는 일단 페이지의 전체 너비 값을 알아야하고 그 다음에 요소의 너비 값을 알아야 했습니다. 이 부분은 뭐 어렵지 않죠.\r\n\r\n<CodeBlock title=''>\r\n```tsx {3-10}\r\nconst onClickDownload = useCallback(\r\n  () => {\r\n    const bodyWidth = document.documentElement.clientWidth;\r\n    const thRefWidth = thRef.current.clientWidth;\r\n\r\n    let formula: number;\r\n\r\n    if (thRefWidth < bodyWidth) {\r\n      formula = (bodyWidth - thRefWidth) / 2;\r\n    }\r\n\r\n    window.scrollTo(0, 0);\r\n\r\n    html2canvas(thRef.current, {\r\n      allowTaint: true,\r\n      useCORS: true,\r\n      foreignObjectRendering: true,\r\n      x: thRefWidth < bodyWidth ? -formula : 0,\r\n      logging: true,\r\n    }).then((canvas) => {\r\n      const img = document.createElement('img');\r\n      img.src = canvas.toDataURL('image/png');\r\n      img.style.display = 'block';\r\n\r\n      imageRef.current.innerHTML = '';\r\n      imageRef.current.appendChild(img);\r\n    });\r\n\r\n    setIsClick(true);\r\n  },\r\n  [ thRef, imageRef, bgColor, ]\r\n);\r\n```\r\n</CodeBlock>\r\n\r\n3번은 전체 너비입니다. 4번은 요소의 너비입니다. 8-10번은 요소의 너비보다 전체 너비가 클 때에만 전체 너비에서 요소의 너비를 뺀 수의 절반을 가져오는 것이죠. 이게 바로 `margin` 값입니다. 이 `margin` 값을 저장해두고 설정을 하나 더 추가해야합니다.\r\n\r\n\r\n"}]